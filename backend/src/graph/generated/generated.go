// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/hotbrainy/go-betting/backend/graph/model"
	"github.com/hotbrainy/go-betting/backend/graph/scalar"
	"github.com/hotbrainy/go-betting/backend/internal/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"gorm.io/gorm"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Announcement() AnnouncementResolver
	Log() LogResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	HasRole func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	AdminPermission struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Dwdelete    func(childComplexity int) int
		Financials  func(childComplexity int) int
		Game        func(childComplexity int) int
		ID          func(childComplexity int) int
		IP          func(childComplexity int) int
		Membership  func(childComplexity int) int
		Qna         func(childComplexity int) int
		Sale        func(childComplexity int) int
		Settlement  func(childComplexity int) int
		Statistical func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	AdminPermissionList struct {
		AdminPermissions func(childComplexity int) int
		Total            func(childComplexity int) int
	}

	Announcement struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ShowFrom    func(childComplexity int) int
		ShowTo      func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	AnnouncementList struct {
		Announcements func(childComplexity int) int
		Total         func(childComplexity int) int
	}

	Bank struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		OrderNum  func(childComplexity int) int
		Status    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	BankList struct {
		Banks func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Domain struct {
		AutoReg           func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Description       func(childComplexity int) int
		DistributorLevel  func(childComplexity int) int
		ID                func(childComplexity int) int
		KakaoTalk         func(childComplexity int) int
		KakaoTalkLink     func(childComplexity int) int
		LiveDomain        func(childComplexity int) int
		LiveDomainLink    func(childComplexity int) int
		MemberLevel       func(childComplexity int) int
		Name              func(childComplexity int) int
		OrderNum          func(childComplexity int) int
		ServiceCenter     func(childComplexity int) int
		ServiceCenterLink func(childComplexity int) int
		Status            func(childComplexity int) int
		Telegram          func(childComplexity int) int
		TelegramLink      func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UseKakaoTalk      func(childComplexity int) int
		UseLiveDomain     func(childComplexity int) int
		UseServiceCenter  func(childComplexity int) int
		UseTelegram       func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	DomainList struct {
		Domains func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Event struct {
		Category    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedDate func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Domain      func(childComplexity int) int
		DomainID    func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUpload func(childComplexity int) int
		Level       func(childComplexity int) int
		MainImage   func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ShowFrom    func(childComplexity int) int
		ShowTo      func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
		Views       func(childComplexity int) int
	}

	EventList struct {
		Events func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	GameAPI struct {
		APICompanyName  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		GameAPIName     func(childComplexity int) int
		GameCompanyName func(childComplexity int) int
		GameType        func(childComplexity int) int
		ID              func(childComplexity int) int
		Order           func(childComplexity int) int
		Other           func(childComplexity int) int
		Type            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		WhetherToUse    func(childComplexity int) int
	}

	GameAPIList struct {
		GameApis func(childComplexity int) int
		Total    func(childComplexity int) int
	}

	Inbox struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		FromID      func(childComplexity int) int
		FromUser    func(childComplexity int) int
		ID          func(childComplexity int) int
		OpenedAt    func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	InboxList struct {
		Inboxes func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Log struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Device    func(childComplexity int) int
		Host      func(childComplexity int) int
		ID        func(childComplexity int) int
		IP        func(childComplexity int) int
		Method    func(childComplexity int) int
		OS        func(childComplexity int) int
		Path      func(childComplexity int) int
		Phone     func(childComplexity int) int
		Status    func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	LogList struct {
		Logs  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Menu struct {
		Children    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Icon        func(childComplexity int) int
		Key         func(childComplexity int) int
		Label       func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ParentID    func(childComplexity int) int
		Path        func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	MenuList struct {
		Menus func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Mutation struct {
		ApproveTransaction    func(childComplexity int, id uint) int
		ApproveUser           func(childComplexity int, id uint) int
		BlockTransaction      func(childComplexity int, id uint) int
		BlockUser             func(childComplexity int, id uint) int
		CancelTransaction     func(childComplexity int, id uint) int
		CompleteQna           func(childComplexity int, id uint) int
		CreateAdminPermission func(childComplexity int, input model.NewAdminPermission) int
		CreateAnnouncement    func(childComplexity int, input model.NewAnnouncementInput) int
		CreateBank            func(childComplexity int, input model.NewBankInput) int
		CreateDomain          func(childComplexity int, input model.NewDomainInput) int
		CreateEvent           func(childComplexity int, input model.NewEventInput) int
		CreateGameAPI         func(childComplexity int, input model.NewGameAPIInput) int
		CreateInbox           func(childComplexity int, input model.NewInboxInput) int
		CreateLog             func(childComplexity int, input model.NewLogInput) int
		CreateMenu            func(childComplexity int, input model.NewMenuInput) int
		CreateNotification    func(childComplexity int, input model.NewNotificationInput) int
		CreateQna             func(childComplexity int, input model.NewQnaInput) int
		CreateSMSApi          func(childComplexity int, input model.NewSMSApiInput) int
		CreateSetting         func(childComplexity int, input model.NewSettingInput) int
		CreateTodo            func(childComplexity int, input model.NewTodo) int
		CreateTransaction     func(childComplexity int, input model.NewTransactionInput) int
		CreateUser            func(childComplexity int, input *model.NewUser) int
		DeleteAnnouncement    func(childComplexity int, id uint) int
		DeleteBank            func(childComplexity int, id uint) int
		DeleteDomain          func(childComplexity int, id uint) int
		DeleteEvent           func(childComplexity int, id uint) int
		DeleteGameAPI         func(childComplexity int, id uint) int
		DeleteInbox           func(childComplexity int, id uint) int
		DeleteLog             func(childComplexity int, id uint) int
		DeleteMenu            func(childComplexity int, id uint) int
		DeleteNotification    func(childComplexity int, id uint) int
		DeleteProfile         func(childComplexity int, id uint) int
		DeleteQna             func(childComplexity int, id uint) int
		DeleteSMSApi          func(childComplexity int, id uint) int
		DeleteSetting         func(childComplexity int, id uint) int
		DeleteTransaction     func(childComplexity int, id uint) int
		ReplyQna              func(childComplexity int, id uint, input model.UpdateQnaInput) int
		Time                  func(childComplexity int) int
		UpdateAdminPermission func(childComplexity int, id uint, input model.UpdateAdminPermissionInput) int
		UpdateAnnouncement    func(childComplexity int, id uint, input model.UpdateAnnouncementInput) int
		UpdateBank            func(childComplexity int, id uint, input model.UpdateBankInput) int
		UpdateDomain          func(childComplexity int, id uint, input model.UpdateDomainInput) int
		UpdateEvent           func(childComplexity int, id uint, input model.UpdateEventInput) int
		UpdateGameAPI         func(childComplexity int, id uint, input model.UpdateGameAPIInput) int
		UpdateInbox           func(childComplexity int, id uint, input model.UpdateInboxInput) int
		UpdateMenu            func(childComplexity int, id uint, input model.UpdateMenuInput) int
		UpdateNotification    func(childComplexity int, id uint, input model.UpdateNotificationInput) int
		UpdateProfile         func(childComplexity int, id uint, input model.UpdateProfile) int
		UpdateQna             func(childComplexity int, id uint, input model.UpdateQnaInput) int
		UpdateSMSApi          func(childComplexity int, id uint, input model.UpdateSMSApiInput) int
		UpdateSetting         func(childComplexity int, id uint, input model.UpdateSettingInput) int
		UpdateTransaction     func(childComplexity int, id uint, input model.UpdateTransactionInput) int
		UpdateUser            func(childComplexity int, id uint, input model.UpdateUser) int
		UploadFile            func(childComplexity int, file graphql.Upload) int
		WaitingTransaction    func(childComplexity int, id uint) int
	}

	Notification struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		Domain       func(childComplexity int) int
		DomainID     func(childComplexity int) int
		ID           func(childComplexity int) int
		ImageUpload  func(childComplexity int) int
		Level        func(childComplexity int) int
		MainImage    func(childComplexity int) int
		NoticeType   func(childComplexity int) int
		OrderNum     func(childComplexity int) int
		RegisterDate func(childComplexity int) int
		ShowFrom     func(childComplexity int) int
		ShowTo       func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Views        func(childComplexity int) int
	}

	NotificationList struct {
		Notifications func(childComplexity int) int
		Total         func(childComplexity int) int
	}

	Profile struct {
		AccountNumber func(childComplexity int) int
		AvatarURL     func(childComplexity int) int
		Balance       func(childComplexity int) int
		BankName      func(childComplexity int) int
		Bio           func(childComplexity int) int
		Birthday      func(childComplexity int) int
		Comp          func(childComplexity int) int
		Coupon        func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Favorites     func(childComplexity int) int
		HolderName    func(childComplexity int) int
		ID            func(childComplexity int) int
		LastDeposit   func(childComplexity int) int
		LastWithdraw  func(childComplexity int) int
		Level         func(childComplexity int) int
		Mobile        func(childComplexity int) int
		Name          func(childComplexity int) int
		Nickname      func(childComplexity int) int
		OrderNum      func(childComplexity int) int
		Phone         func(childComplexity int) int
		PhoneVerified func(childComplexity int) int
		Point         func(childComplexity int) int
		Referral      func(childComplexity int) int
		Roll          func(childComplexity int) int
		SocialLinks   func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	Qna struct {
		Answer        func(childComplexity int) int
		AnswerTitle   func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Domain        func(childComplexity int) int
		DomainID      func(childComplexity int) int
		ID            func(childComplexity int) int
		Question      func(childComplexity int) int
		QuestionTitle func(childComplexity int) int
		RepliedAt     func(childComplexity int) int
		Status        func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	QnaList struct {
		Qnas  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Query struct {
		AdminPermissions      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Announcements         func(childComplexity int) int
		ConnectedUsers        func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Domains               func(childComplexity int) int
		Events                func(childComplexity int) int
		FilterUsers           func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetAnnouncements      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetBanks              func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDistributorDetails func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDistributors       func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDomains            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetEvents             func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetGameApis           func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetInboxes            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetLogs               func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetMenus              func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetNotifications      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetQnas               func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetSMSApis            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetSetting            func(childComplexity int) int
		GetTransactions       func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetUserMenus          func(childComplexity int) int
		GetWeeklyLosingData   func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Logs                  func(childComplexity int) int
		Me                    func(childComplexity int) int
		Notifications         func(childComplexity int) int
		Profile               func(childComplexity int) int
		Time                  func(childComplexity int) int
		Todos                 func(childComplexity int) int
		TopEvents             func(childComplexity int) int
		User                  func(childComplexity int, id uint) int
		Users                 func(childComplexity int) int
	}

	SMSApi struct {
		Agent     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		OrderNum  func(childComplexity int) int
		Password  func(childComplexity int) int
		Status    func(childComplexity int) int
		Token     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		Url       func(childComplexity int) int
	}

	SMSApiList struct {
		SmsApis func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Setting struct {
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		OrderNum      func(childComplexity int) int
		PrimaryDomain func(childComplexity int) int
		Status        func(childComplexity int) int
		Title         func(childComplexity int) int
		TotalExFrom   func(childComplexity int) int
		TotalExStatus func(childComplexity int) int
		TotalExTo     func(childComplexity int) int
		TotalReFrom   func(childComplexity int) int
		TotalReStatus func(childComplexity int) int
		TotalReTo     func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserExFrom    func(childComplexity int) int
		UserExStatus  func(childComplexity int) int
		UserExTo      func(childComplexity int) int
		UserID        func(childComplexity int) int
		UserReFrom    func(childComplexity int) int
		UserReStatus  func(childComplexity int) int
		UserReTo      func(childComplexity int) int
	}

	Subscription struct {
		Time func(childComplexity int) int
	}

	Todo struct {
		Done func(childComplexity int) int
		ID   func(childComplexity int) int
		Text func(childComplexity int) int
		User func(childComplexity int) int
	}

	Transaction struct {
		Amount        func(childComplexity int) int
		ApprovedAt    func(childComplexity int) int
		BalanceAfter  func(childComplexity int) int
		BalanceBefore func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		PointAfter    func(childComplexity int) int
		PointBefore   func(childComplexity int) int
		Shortcut      func(childComplexity int) int
		Status        func(childComplexity int) int
		TransactionAt func(childComplexity int) int
		Type          func(childComplexity int) int
		USDTDesc      func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	TransactionList struct {
		Total        func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	User struct {
		BlackMemo               func(childComplexity int) int
		Children                func(childComplexity int) int
		ChildrenCount           func(childComplexity int) int
		CreatedAt               func(childComplexity int) int
		CurrentIP               func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		Device                  func(childComplexity int) int
		EntireLosing            func(childComplexity int) int
		FingerPrint             func(childComplexity int) int
		Hold                    func(childComplexity int) int
		HoldLosingBeDang        func(childComplexity int) int
		HoldemBetting           func(childComplexity int) int
		HoldemWinning           func(childComplexity int) int
		ID                      func(childComplexity int) int
		IP                      func(childComplexity int) int
		Live                    func(childComplexity int) int
		LiveBetting             func(childComplexity int) int
		LiveLosingBeDang        func(childComplexity int) int
		LiveWinning             func(childComplexity int) int
		LosingMethod            func(childComplexity int) int
		LosingRate              func(childComplexity int) int
		LosingSettlement        func(childComplexity int) int
		LotusBetting            func(childComplexity int) int
		LotusLottery            func(childComplexity int) int
		LotusRolling            func(childComplexity int) int
		MembershipDeposit       func(childComplexity int) int
		MembershipWithdrawal    func(childComplexity int) int
		MgmBetting              func(childComplexity int) int
		MgmRolling              func(childComplexity int) int
		MgmWinning              func(childComplexity int) int
		MiniCombinationBetting  func(childComplexity int) int
		MiniCombinationRolling  func(childComplexity int) int
		MiniCombinationWinnings func(childComplexity int) int
		MiniDanpolBetting       func(childComplexity int) int
		MiniDanpolRolling       func(childComplexity int) int
		MiniDanpolWinner        func(childComplexity int) int
		Name                    func(childComplexity int) int
		NumberOfMembers         func(childComplexity int) int
		OS                      func(childComplexity int) int
		OrderNum                func(childComplexity int) int
		Parent                  func(childComplexity int) int
		ParentID                func(childComplexity int) int
		PartnershipMoneyInHand  func(childComplexity int) int
		PartnershipRolling      func(childComplexity int) int
		Profile                 func(childComplexity int) int
		Role                    func(childComplexity int) int
		RollingHoldings         func(childComplexity int) int
		RollingRate             func(childComplexity int) int
		RollingTransition       func(childComplexity int) int
		Root                    func(childComplexity int) int
		RootID                  func(childComplexity int) int
		Slot                    func(childComplexity int) int
		SlotBetting             func(childComplexity int) int
		SlotJackpot             func(childComplexity int) int
		SlotLosingBeDang        func(childComplexity int) int
		Sports3PoleRolling      func(childComplexity int) int
		Sports3poleBetting      func(childComplexity int) int
		Sports3poleWinner       func(childComplexity int) int
		Sports4PoleRolling      func(childComplexity int) int
		Sports4poleBetting      func(childComplexity int) int
		Sports4poleWinner       func(childComplexity int) int
		Sports5PoleRolling      func(childComplexity int) int
		Sports5poleBetting      func(childComplexity int) int
		Sports5poleWinner       func(childComplexity int) int
		SportsDanpolBetting     func(childComplexity int) int
		SportsDanpolRolling     func(childComplexity int) int
		SportsDanpolWinner      func(childComplexity int) int
		SportsDapolBetting      func(childComplexity int) int
		SportsDapolRolling      func(childComplexity int) int
		SportsDapolWinner       func(childComplexity int) int
		SportsDupolBetting      func(childComplexity int) int
		SportsDupolRolling      func(childComplexity int) int
		SportsDupolWinner       func(childComplexity int) int
		Status                  func(childComplexity int) int
		TotalWithdrawal         func(childComplexity int) int
		TouchBetting            func(childComplexity int) int
		TouchRolling            func(childComplexity int) int
		TouchWinning            func(childComplexity int) int
		Type                    func(childComplexity int) int
		USDTAddress             func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		Userid                  func(childComplexity int) int
		VirtualGameBetting      func(childComplexity int) int
		VirtualGameRolling      func(childComplexity int) int
		VirtualGameWinnings     func(childComplexity int) int
	}

	UserList struct {
		Total func(childComplexity int) int
		Users func(childComplexity int) int
	}

	WeeklyLosingData struct {
		Alias            func(childComplexity int) int
		ApplicationDate  func(childComplexity int) int
		Depositor        func(childComplexity int) int
		DistributorID    func(childComplexity int) int
		DistributorLevel func(childComplexity int) int
		DistributorName  func(childComplexity int) int
		Nickname         func(childComplexity int) int
		ProcessingDate   func(childComplexity int) int
		SettlementAmount func(childComplexity int) int
		Site             func(childComplexity int) int
		Situation        func(childComplexity int) int
		TotalBet         func(childComplexity int) int
		TotalLosingMoney func(childComplexity int) int
		TotalWinner      func(childComplexity int) int
		UserCount        func(childComplexity int) int
		WeekEnd          func(childComplexity int) int
		WeekStart        func(childComplexity int) int
	}

	WeeklyLosingDataList struct {
		Total            func(childComplexity int) int
		WeeklyLosingData func(childComplexity int) int
	}
}

type AnnouncementResolver interface {
	ShowFrom(ctx context.Context, obj *models.Announcement) (*time.Time, error)
	ShowTo(ctx context.Context, obj *models.Announcement) (*time.Time, error)
}
type LogResolver interface {
	DeletedAt(ctx context.Context, obj *models.Log) (*gorm.DeletedAt, error)
}
type MutationResolver interface {
	Time(ctx context.Context) (*time.Time, error)
	UploadFile(ctx context.Context, file graphql.Upload) (string, error)
	CreateAdminPermission(ctx context.Context, input model.NewAdminPermission) (*models.AdminPermission, error)
	UpdateAdminPermission(ctx context.Context, id uint, input model.UpdateAdminPermissionInput) (*models.AdminPermission, error)
	CreateAnnouncement(ctx context.Context, input model.NewAnnouncementInput) (*models.Announcement, error)
	UpdateAnnouncement(ctx context.Context, id uint, input model.UpdateAnnouncementInput) (*models.Announcement, error)
	DeleteAnnouncement(ctx context.Context, id uint) (bool, error)
	CreateBank(ctx context.Context, input model.NewBankInput) (*models.Bank, error)
	UpdateBank(ctx context.Context, id uint, input model.UpdateBankInput) (*models.Bank, error)
	DeleteBank(ctx context.Context, id uint) (bool, error)
	CreateDomain(ctx context.Context, input model.NewDomainInput) (*models.Domain, error)
	UpdateDomain(ctx context.Context, id uint, input model.UpdateDomainInput) (*models.Domain, error)
	DeleteDomain(ctx context.Context, id uint) (bool, error)
	CreateEvent(ctx context.Context, input model.NewEventInput) (*models.Event, error)
	UpdateEvent(ctx context.Context, id uint, input model.UpdateEventInput) (*models.Event, error)
	DeleteEvent(ctx context.Context, id uint) (bool, error)
	CreateGameAPI(ctx context.Context, input model.NewGameAPIInput) (*model.GameAPI, error)
	UpdateGameAPI(ctx context.Context, id uint, input model.UpdateGameAPIInput) (*model.GameAPI, error)
	DeleteGameAPI(ctx context.Context, id uint) (bool, error)
	CreateInbox(ctx context.Context, input model.NewInboxInput) (*models.Inbox, error)
	UpdateInbox(ctx context.Context, id uint, input model.UpdateInboxInput) (*models.Inbox, error)
	DeleteInbox(ctx context.Context, id uint) (bool, error)
	CreateLog(ctx context.Context, input model.NewLogInput) (*models.Log, error)
	DeleteLog(ctx context.Context, id uint) (bool, error)
	CreateMenu(ctx context.Context, input model.NewMenuInput) (*models.Menu, error)
	UpdateMenu(ctx context.Context, id uint, input model.UpdateMenuInput) (*models.Menu, error)
	DeleteMenu(ctx context.Context, id uint) (bool, error)
	CreateNotification(ctx context.Context, input model.NewNotificationInput) (*models.Notification, error)
	UpdateNotification(ctx context.Context, id uint, input model.UpdateNotificationInput) (*models.Notification, error)
	DeleteNotification(ctx context.Context, id uint) (bool, error)
	CreateQna(ctx context.Context, input model.NewQnaInput) (*models.Qna, error)
	UpdateQna(ctx context.Context, id uint, input model.UpdateQnaInput) (*models.Qna, error)
	ReplyQna(ctx context.Context, id uint, input model.UpdateQnaInput) (*models.Qna, error)
	DeleteQna(ctx context.Context, id uint) (bool, error)
	CompleteQna(ctx context.Context, id uint) (bool, error)
	CreateSetting(ctx context.Context, input model.NewSettingInput) (*model.Setting, error)
	UpdateSetting(ctx context.Context, id uint, input model.UpdateSettingInput) (*model.Setting, error)
	DeleteSetting(ctx context.Context, id uint) (bool, error)
	CreateSMSApi(ctx context.Context, input model.NewSMSApiInput) (*models.SMSApi, error)
	UpdateSMSApi(ctx context.Context, id uint, input model.UpdateSMSApiInput) (*models.SMSApi, error)
	DeleteSMSApi(ctx context.Context, id uint) (bool, error)
	CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error)
	CreateTransaction(ctx context.Context, input model.NewTransactionInput) (*models.Transaction, error)
	UpdateTransaction(ctx context.Context, id uint, input model.UpdateTransactionInput) (*models.Transaction, error)
	DeleteTransaction(ctx context.Context, id uint) (bool, error)
	ApproveTransaction(ctx context.Context, id uint) (bool, error)
	BlockTransaction(ctx context.Context, id uint) (bool, error)
	WaitingTransaction(ctx context.Context, id uint) (bool, error)
	CancelTransaction(ctx context.Context, id uint) (bool, error)
	UpdateProfile(ctx context.Context, id uint, input model.UpdateProfile) (*models.Profile, error)
	DeleteProfile(ctx context.Context, id uint) (bool, error)
	CreateUser(ctx context.Context, input *model.NewUser) (bool, error)
	ApproveUser(ctx context.Context, id uint) (bool, error)
	BlockUser(ctx context.Context, id uint) (bool, error)
	UpdateUser(ctx context.Context, id uint, input model.UpdateUser) (bool, error)
}
type NotificationResolver interface {
	ShowFrom(ctx context.Context, obj *models.Notification) (*time.Time, error)

	ShowTo(ctx context.Context, obj *models.Notification) (*time.Time, error)
}
type QueryResolver interface {
	Time(ctx context.Context) (*time.Time, error)
	AdminPermissions(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.AdminPermissionList, error)
	Announcements(ctx context.Context) ([]*models.Announcement, error)
	GetAnnouncements(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.AnnouncementList, error)
	GetBanks(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.BankList, error)
	Domains(ctx context.Context) ([]*models.Domain, error)
	GetDomains(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.DomainList, error)
	TopEvents(ctx context.Context) ([]*models.Event, error)
	Events(ctx context.Context) ([]*models.Event, error)
	GetEvents(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.EventList, error)
	GetGameApis(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.GameAPIList, error)
	GetInboxes(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.InboxList, error)
	Logs(ctx context.Context) ([]*models.Log, error)
	GetLogs(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.LogList, error)
	GetUserMenus(ctx context.Context) ([]*models.Menu, error)
	GetMenus(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.MenuList, error)
	Notifications(ctx context.Context) ([]*models.Notification, error)
	GetNotifications(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.NotificationList, error)
	GetQnas(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.QnaList, error)
	GetSetting(ctx context.Context) (*model.Setting, error)
	GetSMSApis(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.SMSApiList, error)
	Todos(ctx context.Context) ([]*model.Todo, error)
	GetTransactions(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.TransactionList, error)
	GetWeeklyLosingData(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.WeeklyLosingDataList, error)
	Profile(ctx context.Context) (*models.Profile, error)
	Me(ctx context.Context) (*models.User, error)
	Users(ctx context.Context) ([]*models.User, error)
	FilterUsers(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	ConnectedUsers(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	User(ctx context.Context, id uint) (*models.User, error)
	GetDistributors(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	GetDistributorDetails(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
}
type SubscriptionResolver interface {
	Time(ctx context.Context) (<-chan string, error)
}
type UserResolver interface {
	Type(ctx context.Context, obj *models.User) (model.UserType, error)

	Status(ctx context.Context, obj *models.User) (model.UserStatus, error)

	NumberOfMembers(ctx context.Context, obj *models.User) (*int32, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AdminPermission.createdAt":
		if e.complexity.AdminPermission.CreatedAt == nil {
			break
		}

		return e.complexity.AdminPermission.CreatedAt(childComplexity), true

	case "AdminPermission.deletedAt":
		if e.complexity.AdminPermission.DeletedAt == nil {
			break
		}

		return e.complexity.AdminPermission.DeletedAt(childComplexity), true

	case "AdminPermission.dwdelete":
		if e.complexity.AdminPermission.Dwdelete == nil {
			break
		}

		return e.complexity.AdminPermission.Dwdelete(childComplexity), true

	case "AdminPermission.financials":
		if e.complexity.AdminPermission.Financials == nil {
			break
		}

		return e.complexity.AdminPermission.Financials(childComplexity), true

	case "AdminPermission.game":
		if e.complexity.AdminPermission.Game == nil {
			break
		}

		return e.complexity.AdminPermission.Game(childComplexity), true

	case "AdminPermission.id":
		if e.complexity.AdminPermission.ID == nil {
			break
		}

		return e.complexity.AdminPermission.ID(childComplexity), true

	case "AdminPermission.ip":
		if e.complexity.AdminPermission.IP == nil {
			break
		}

		return e.complexity.AdminPermission.IP(childComplexity), true

	case "AdminPermission.membership":
		if e.complexity.AdminPermission.Membership == nil {
			break
		}

		return e.complexity.AdminPermission.Membership(childComplexity), true

	case "AdminPermission.qna":
		if e.complexity.AdminPermission.Qna == nil {
			break
		}

		return e.complexity.AdminPermission.Qna(childComplexity), true

	case "AdminPermission.sale":
		if e.complexity.AdminPermission.Sale == nil {
			break
		}

		return e.complexity.AdminPermission.Sale(childComplexity), true

	case "AdminPermission.settlement":
		if e.complexity.AdminPermission.Settlement == nil {
			break
		}

		return e.complexity.AdminPermission.Settlement(childComplexity), true

	case "AdminPermission.statistical":
		if e.complexity.AdminPermission.Statistical == nil {
			break
		}

		return e.complexity.AdminPermission.Statistical(childComplexity), true

	case "AdminPermission.status":
		if e.complexity.AdminPermission.Status == nil {
			break
		}

		return e.complexity.AdminPermission.Status(childComplexity), true

	case "AdminPermission.updatedAt":
		if e.complexity.AdminPermission.UpdatedAt == nil {
			break
		}

		return e.complexity.AdminPermission.UpdatedAt(childComplexity), true

	case "AdminPermission.user":
		if e.complexity.AdminPermission.User == nil {
			break
		}

		return e.complexity.AdminPermission.User(childComplexity), true

	case "AdminPermission.userId":
		if e.complexity.AdminPermission.UserID == nil {
			break
		}

		return e.complexity.AdminPermission.UserID(childComplexity), true

	case "AdminPermissionList.adminPermissions":
		if e.complexity.AdminPermissionList.AdminPermissions == nil {
			break
		}

		return e.complexity.AdminPermissionList.AdminPermissions(childComplexity), true

	case "AdminPermissionList.total":
		if e.complexity.AdminPermissionList.Total == nil {
			break
		}

		return e.complexity.AdminPermissionList.Total(childComplexity), true

	case "Announcement.createdAt":
		if e.complexity.Announcement.CreatedAt == nil {
			break
		}

		return e.complexity.Announcement.CreatedAt(childComplexity), true

	case "Announcement.deletedAt":
		if e.complexity.Announcement.DeletedAt == nil {
			break
		}

		return e.complexity.Announcement.DeletedAt(childComplexity), true

	case "Announcement.description":
		if e.complexity.Announcement.Description == nil {
			break
		}

		return e.complexity.Announcement.Description(childComplexity), true

	case "Announcement.id":
		if e.complexity.Announcement.ID == nil {
			break
		}

		return e.complexity.Announcement.ID(childComplexity), true

	case "Announcement.orderNum":
		if e.complexity.Announcement.OrderNum == nil {
			break
		}

		return e.complexity.Announcement.OrderNum(childComplexity), true

	case "Announcement.showFrom":
		if e.complexity.Announcement.ShowFrom == nil {
			break
		}

		return e.complexity.Announcement.ShowFrom(childComplexity), true

	case "Announcement.showTo":
		if e.complexity.Announcement.ShowTo == nil {
			break
		}

		return e.complexity.Announcement.ShowTo(childComplexity), true

	case "Announcement.status":
		if e.complexity.Announcement.Status == nil {
			break
		}

		return e.complexity.Announcement.Status(childComplexity), true

	case "Announcement.title":
		if e.complexity.Announcement.Title == nil {
			break
		}

		return e.complexity.Announcement.Title(childComplexity), true

	case "Announcement.updatedAt":
		if e.complexity.Announcement.UpdatedAt == nil {
			break
		}

		return e.complexity.Announcement.UpdatedAt(childComplexity), true

	case "Announcement.user":
		if e.complexity.Announcement.User == nil {
			break
		}

		return e.complexity.Announcement.User(childComplexity), true

	case "Announcement.userId":
		if e.complexity.Announcement.UserID == nil {
			break
		}

		return e.complexity.Announcement.UserID(childComplexity), true

	case "AnnouncementList.announcements":
		if e.complexity.AnnouncementList.Announcements == nil {
			break
		}

		return e.complexity.AnnouncementList.Announcements(childComplexity), true

	case "AnnouncementList.total":
		if e.complexity.AnnouncementList.Total == nil {
			break
		}

		return e.complexity.AnnouncementList.Total(childComplexity), true

	case "Bank.createdAt":
		if e.complexity.Bank.CreatedAt == nil {
			break
		}

		return e.complexity.Bank.CreatedAt(childComplexity), true

	case "Bank.deletedAt":
		if e.complexity.Bank.DeletedAt == nil {
			break
		}

		return e.complexity.Bank.DeletedAt(childComplexity), true

	case "Bank.id":
		if e.complexity.Bank.ID == nil {
			break
		}

		return e.complexity.Bank.ID(childComplexity), true

	case "Bank.name":
		if e.complexity.Bank.Name == nil {
			break
		}

		return e.complexity.Bank.Name(childComplexity), true

	case "Bank.orderNum":
		if e.complexity.Bank.OrderNum == nil {
			break
		}

		return e.complexity.Bank.OrderNum(childComplexity), true

	case "Bank.status":
		if e.complexity.Bank.Status == nil {
			break
		}

		return e.complexity.Bank.Status(childComplexity), true

	case "Bank.updatedAt":
		if e.complexity.Bank.UpdatedAt == nil {
			break
		}

		return e.complexity.Bank.UpdatedAt(childComplexity), true

	case "BankList.banks":
		if e.complexity.BankList.Banks == nil {
			break
		}

		return e.complexity.BankList.Banks(childComplexity), true

	case "BankList.total":
		if e.complexity.BankList.Total == nil {
			break
		}

		return e.complexity.BankList.Total(childComplexity), true

	case "Domain.autoReg":
		if e.complexity.Domain.AutoReg == nil {
			break
		}

		return e.complexity.Domain.AutoReg(childComplexity), true

	case "Domain.createdAt":
		if e.complexity.Domain.CreatedAt == nil {
			break
		}

		return e.complexity.Domain.CreatedAt(childComplexity), true

	case "Domain.deletedAt":
		if e.complexity.Domain.DeletedAt == nil {
			break
		}

		return e.complexity.Domain.DeletedAt(childComplexity), true

	case "Domain.description":
		if e.complexity.Domain.Description == nil {
			break
		}

		return e.complexity.Domain.Description(childComplexity), true

	case "Domain.distributorLevel":
		if e.complexity.Domain.DistributorLevel == nil {
			break
		}

		return e.complexity.Domain.DistributorLevel(childComplexity), true

	case "Domain.id":
		if e.complexity.Domain.ID == nil {
			break
		}

		return e.complexity.Domain.ID(childComplexity), true

	case "Domain.kakaoTalk":
		if e.complexity.Domain.KakaoTalk == nil {
			break
		}

		return e.complexity.Domain.KakaoTalk(childComplexity), true

	case "Domain.kakaoTalkLink":
		if e.complexity.Domain.KakaoTalkLink == nil {
			break
		}

		return e.complexity.Domain.KakaoTalkLink(childComplexity), true

	case "Domain.liveDomain":
		if e.complexity.Domain.LiveDomain == nil {
			break
		}

		return e.complexity.Domain.LiveDomain(childComplexity), true

	case "Domain.liveDomainLink":
		if e.complexity.Domain.LiveDomainLink == nil {
			break
		}

		return e.complexity.Domain.LiveDomainLink(childComplexity), true

	case "Domain.memberLevel":
		if e.complexity.Domain.MemberLevel == nil {
			break
		}

		return e.complexity.Domain.MemberLevel(childComplexity), true

	case "Domain.name":
		if e.complexity.Domain.Name == nil {
			break
		}

		return e.complexity.Domain.Name(childComplexity), true

	case "Domain.orderNum":
		if e.complexity.Domain.OrderNum == nil {
			break
		}

		return e.complexity.Domain.OrderNum(childComplexity), true

	case "Domain.serviceCenter":
		if e.complexity.Domain.ServiceCenter == nil {
			break
		}

		return e.complexity.Domain.ServiceCenter(childComplexity), true

	case "Domain.serviceCenterLink":
		if e.complexity.Domain.ServiceCenterLink == nil {
			break
		}

		return e.complexity.Domain.ServiceCenterLink(childComplexity), true

	case "Domain.status":
		if e.complexity.Domain.Status == nil {
			break
		}

		return e.complexity.Domain.Status(childComplexity), true

	case "Domain.telegram":
		if e.complexity.Domain.Telegram == nil {
			break
		}

		return e.complexity.Domain.Telegram(childComplexity), true

	case "Domain.telegramLink":
		if e.complexity.Domain.TelegramLink == nil {
			break
		}

		return e.complexity.Domain.TelegramLink(childComplexity), true

	case "Domain.updatedAt":
		if e.complexity.Domain.UpdatedAt == nil {
			break
		}

		return e.complexity.Domain.UpdatedAt(childComplexity), true

	case "Domain.useKakaoTalk":
		if e.complexity.Domain.UseKakaoTalk == nil {
			break
		}

		return e.complexity.Domain.UseKakaoTalk(childComplexity), true

	case "Domain.useLiveDomain":
		if e.complexity.Domain.UseLiveDomain == nil {
			break
		}

		return e.complexity.Domain.UseLiveDomain(childComplexity), true

	case "Domain.useServiceCenter":
		if e.complexity.Domain.UseServiceCenter == nil {
			break
		}

		return e.complexity.Domain.UseServiceCenter(childComplexity), true

	case "Domain.useTelegram":
		if e.complexity.Domain.UseTelegram == nil {
			break
		}

		return e.complexity.Domain.UseTelegram(childComplexity), true

	case "Domain.user":
		if e.complexity.Domain.User == nil {
			break
		}

		return e.complexity.Domain.User(childComplexity), true

	case "Domain.userId":
		if e.complexity.Domain.UserID == nil {
			break
		}

		return e.complexity.Domain.UserID(childComplexity), true

	case "DomainList.domains":
		if e.complexity.DomainList.Domains == nil {
			break
		}

		return e.complexity.DomainList.Domains(childComplexity), true

	case "DomainList.total":
		if e.complexity.DomainList.Total == nil {
			break
		}

		return e.complexity.DomainList.Total(childComplexity), true

	case "Event.category":
		if e.complexity.Event.Category == nil {
			break
		}

		return e.complexity.Event.Category(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.createdDate":
		if e.complexity.Event.CreatedDate == nil {
			break
		}

		return e.complexity.Event.CreatedDate(childComplexity), true

	case "Event.deletedAt":
		if e.complexity.Event.DeletedAt == nil {
			break
		}

		return e.complexity.Event.DeletedAt(childComplexity), true

	case "Event.description":
		if e.complexity.Event.Description == nil {
			break
		}

		return e.complexity.Event.Description(childComplexity), true

	case "Event.domain":
		if e.complexity.Event.Domain == nil {
			break
		}

		return e.complexity.Event.Domain(childComplexity), true

	case "Event.domainId":
		if e.complexity.Event.DomainID == nil {
			break
		}

		return e.complexity.Event.DomainID(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.imageUpload":
		if e.complexity.Event.ImageUpload == nil {
			break
		}

		return e.complexity.Event.ImageUpload(childComplexity), true

	case "Event.level":
		if e.complexity.Event.Level == nil {
			break
		}

		return e.complexity.Event.Level(childComplexity), true

	case "Event.mainImage":
		if e.complexity.Event.MainImage == nil {
			break
		}

		return e.complexity.Event.MainImage(childComplexity), true

	case "Event.orderNum":
		if e.complexity.Event.OrderNum == nil {
			break
		}

		return e.complexity.Event.OrderNum(childComplexity), true

	case "Event.showFrom":
		if e.complexity.Event.ShowFrom == nil {
			break
		}

		return e.complexity.Event.ShowFrom(childComplexity), true

	case "Event.showTo":
		if e.complexity.Event.ShowTo == nil {
			break
		}

		return e.complexity.Event.ShowTo(childComplexity), true

	case "Event.status":
		if e.complexity.Event.Status == nil {
			break
		}

		return e.complexity.Event.Status(childComplexity), true

	case "Event.title":
		if e.complexity.Event.Title == nil {
			break
		}

		return e.complexity.Event.Title(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "Event.user":
		if e.complexity.Event.User == nil {
			break
		}

		return e.complexity.Event.User(childComplexity), true

	case "Event.userId":
		if e.complexity.Event.UserID == nil {
			break
		}

		return e.complexity.Event.UserID(childComplexity), true

	case "Event.views":
		if e.complexity.Event.Views == nil {
			break
		}

		return e.complexity.Event.Views(childComplexity), true

	case "EventList.events":
		if e.complexity.EventList.Events == nil {
			break
		}

		return e.complexity.EventList.Events(childComplexity), true

	case "EventList.total":
		if e.complexity.EventList.Total == nil {
			break
		}

		return e.complexity.EventList.Total(childComplexity), true

	case "GameAPI.apiCompanyName":
		if e.complexity.GameAPI.APICompanyName == nil {
			break
		}

		return e.complexity.GameAPI.APICompanyName(childComplexity), true

	case "GameAPI.createdAt":
		if e.complexity.GameAPI.CreatedAt == nil {
			break
		}

		return e.complexity.GameAPI.CreatedAt(childComplexity), true

	case "GameAPI.deletedAt":
		if e.complexity.GameAPI.DeletedAt == nil {
			break
		}

		return e.complexity.GameAPI.DeletedAt(childComplexity), true

	case "GameAPI.gameApiName":
		if e.complexity.GameAPI.GameAPIName == nil {
			break
		}

		return e.complexity.GameAPI.GameAPIName(childComplexity), true

	case "GameAPI.gameCompanyName":
		if e.complexity.GameAPI.GameCompanyName == nil {
			break
		}

		return e.complexity.GameAPI.GameCompanyName(childComplexity), true

	case "GameAPI.gameType":
		if e.complexity.GameAPI.GameType == nil {
			break
		}

		return e.complexity.GameAPI.GameType(childComplexity), true

	case "GameAPI.id":
		if e.complexity.GameAPI.ID == nil {
			break
		}

		return e.complexity.GameAPI.ID(childComplexity), true

	case "GameAPI.order":
		if e.complexity.GameAPI.Order == nil {
			break
		}

		return e.complexity.GameAPI.Order(childComplexity), true

	case "GameAPI.other":
		if e.complexity.GameAPI.Other == nil {
			break
		}

		return e.complexity.GameAPI.Other(childComplexity), true

	case "GameAPI.type":
		if e.complexity.GameAPI.Type == nil {
			break
		}

		return e.complexity.GameAPI.Type(childComplexity), true

	case "GameAPI.updatedAt":
		if e.complexity.GameAPI.UpdatedAt == nil {
			break
		}

		return e.complexity.GameAPI.UpdatedAt(childComplexity), true

	case "GameAPI.whetherToUse":
		if e.complexity.GameAPI.WhetherToUse == nil {
			break
		}

		return e.complexity.GameAPI.WhetherToUse(childComplexity), true

	case "GameAPIList.gameApis":
		if e.complexity.GameAPIList.GameApis == nil {
			break
		}

		return e.complexity.GameAPIList.GameApis(childComplexity), true

	case "GameAPIList.total":
		if e.complexity.GameAPIList.Total == nil {
			break
		}

		return e.complexity.GameAPIList.Total(childComplexity), true

	case "Inbox.createdAt":
		if e.complexity.Inbox.CreatedAt == nil {
			break
		}

		return e.complexity.Inbox.CreatedAt(childComplexity), true

	case "Inbox.deletedAt":
		if e.complexity.Inbox.DeletedAt == nil {
			break
		}

		return e.complexity.Inbox.DeletedAt(childComplexity), true

	case "Inbox.description":
		if e.complexity.Inbox.Description == nil {
			break
		}

		return e.complexity.Inbox.Description(childComplexity), true

	case "Inbox.fromId":
		if e.complexity.Inbox.FromID == nil {
			break
		}

		return e.complexity.Inbox.FromID(childComplexity), true

	case "Inbox.FromUser":
		if e.complexity.Inbox.FromUser == nil {
			break
		}

		return e.complexity.Inbox.FromUser(childComplexity), true

	case "Inbox.id":
		if e.complexity.Inbox.ID == nil {
			break
		}

		return e.complexity.Inbox.ID(childComplexity), true

	case "Inbox.openedAt":
		if e.complexity.Inbox.OpenedAt == nil {
			break
		}

		return e.complexity.Inbox.OpenedAt(childComplexity), true

	case "Inbox.orderNum":
		if e.complexity.Inbox.OrderNum == nil {
			break
		}

		return e.complexity.Inbox.OrderNum(childComplexity), true

	case "Inbox.status":
		if e.complexity.Inbox.Status == nil {
			break
		}

		return e.complexity.Inbox.Status(childComplexity), true

	case "Inbox.title":
		if e.complexity.Inbox.Title == nil {
			break
		}

		return e.complexity.Inbox.Title(childComplexity), true

	case "Inbox.type":
		if e.complexity.Inbox.Type == nil {
			break
		}

		return e.complexity.Inbox.Type(childComplexity), true

	case "Inbox.updatedAt":
		if e.complexity.Inbox.UpdatedAt == nil {
			break
		}

		return e.complexity.Inbox.UpdatedAt(childComplexity), true

	case "Inbox.user":
		if e.complexity.Inbox.User == nil {
			break
		}

		return e.complexity.Inbox.User(childComplexity), true

	case "Inbox.userId":
		if e.complexity.Inbox.UserID == nil {
			break
		}

		return e.complexity.Inbox.UserID(childComplexity), true

	case "InboxList.inboxes":
		if e.complexity.InboxList.Inboxes == nil {
			break
		}

		return e.complexity.InboxList.Inboxes(childComplexity), true

	case "InboxList.total":
		if e.complexity.InboxList.Total == nil {
			break
		}

		return e.complexity.InboxList.Total(childComplexity), true

	case "Log.createdAt":
		if e.complexity.Log.CreatedAt == nil {
			break
		}

		return e.complexity.Log.CreatedAt(childComplexity), true

	case "Log.data":
		if e.complexity.Log.Data == nil {
			break
		}

		return e.complexity.Log.Data(childComplexity), true

	case "Log.deletedAt":
		if e.complexity.Log.DeletedAt == nil {
			break
		}

		return e.complexity.Log.DeletedAt(childComplexity), true

	case "Log.device":
		if e.complexity.Log.Device == nil {
			break
		}

		return e.complexity.Log.Device(childComplexity), true

	case "Log.host":
		if e.complexity.Log.Host == nil {
			break
		}

		return e.complexity.Log.Host(childComplexity), true

	case "Log.id":
		if e.complexity.Log.ID == nil {
			break
		}

		return e.complexity.Log.ID(childComplexity), true

	case "Log.ip":
		if e.complexity.Log.IP == nil {
			break
		}

		return e.complexity.Log.IP(childComplexity), true

	case "Log.method":
		if e.complexity.Log.Method == nil {
			break
		}

		return e.complexity.Log.Method(childComplexity), true

	case "Log.os":
		if e.complexity.Log.OS == nil {
			break
		}

		return e.complexity.Log.OS(childComplexity), true

	case "Log.path":
		if e.complexity.Log.Path == nil {
			break
		}

		return e.complexity.Log.Path(childComplexity), true

	case "Log.phone":
		if e.complexity.Log.Phone == nil {
			break
		}

		return e.complexity.Log.Phone(childComplexity), true

	case "Log.status":
		if e.complexity.Log.Status == nil {
			break
		}

		return e.complexity.Log.Status(childComplexity), true

	case "Log.type":
		if e.complexity.Log.Type == nil {
			break
		}

		return e.complexity.Log.Type(childComplexity), true

	case "Log.updatedAt":
		if e.complexity.Log.UpdatedAt == nil {
			break
		}

		return e.complexity.Log.UpdatedAt(childComplexity), true

	case "Log.user":
		if e.complexity.Log.User == nil {
			break
		}

		return e.complexity.Log.User(childComplexity), true

	case "Log.userId":
		if e.complexity.Log.UserID == nil {
			break
		}

		return e.complexity.Log.UserID(childComplexity), true

	case "LogList.logs":
		if e.complexity.LogList.Logs == nil {
			break
		}

		return e.complexity.LogList.Logs(childComplexity), true

	case "LogList.total":
		if e.complexity.LogList.Total == nil {
			break
		}

		return e.complexity.LogList.Total(childComplexity), true

	case "Menu.children":
		if e.complexity.Menu.Children == nil {
			break
		}

		return e.complexity.Menu.Children(childComplexity), true

	case "Menu.createdAt":
		if e.complexity.Menu.CreatedAt == nil {
			break
		}

		return e.complexity.Menu.CreatedAt(childComplexity), true

	case "Menu.deletedAt":
		if e.complexity.Menu.DeletedAt == nil {
			break
		}

		return e.complexity.Menu.DeletedAt(childComplexity), true

	case "Menu.description":
		if e.complexity.Menu.Description == nil {
			break
		}

		return e.complexity.Menu.Description(childComplexity), true

	case "Menu.id":
		if e.complexity.Menu.ID == nil {
			break
		}

		return e.complexity.Menu.ID(childComplexity), true

	case "Menu.icon":
		if e.complexity.Menu.Icon == nil {
			break
		}

		return e.complexity.Menu.Icon(childComplexity), true

	case "Menu.key":
		if e.complexity.Menu.Key == nil {
			break
		}

		return e.complexity.Menu.Key(childComplexity), true

	case "Menu.label":
		if e.complexity.Menu.Label == nil {
			break
		}

		return e.complexity.Menu.Label(childComplexity), true

	case "Menu.orderNum":
		if e.complexity.Menu.OrderNum == nil {
			break
		}

		return e.complexity.Menu.OrderNum(childComplexity), true

	case "Menu.parentId":
		if e.complexity.Menu.ParentID == nil {
			break
		}

		return e.complexity.Menu.ParentID(childComplexity), true

	case "Menu.path":
		if e.complexity.Menu.Path == nil {
			break
		}

		return e.complexity.Menu.Path(childComplexity), true

	case "Menu.status":
		if e.complexity.Menu.Status == nil {
			break
		}

		return e.complexity.Menu.Status(childComplexity), true

	case "Menu.updatedAt":
		if e.complexity.Menu.UpdatedAt == nil {
			break
		}

		return e.complexity.Menu.UpdatedAt(childComplexity), true

	case "MenuList.menus":
		if e.complexity.MenuList.Menus == nil {
			break
		}

		return e.complexity.MenuList.Menus(childComplexity), true

	case "MenuList.total":
		if e.complexity.MenuList.Total == nil {
			break
		}

		return e.complexity.MenuList.Total(childComplexity), true

	case "Mutation.approveTransaction":
		if e.complexity.Mutation.ApproveTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_approveTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.approveUser":
		if e.complexity.Mutation.ApproveUser == nil {
			break
		}

		args, err := ec.field_Mutation_approveUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveUser(childComplexity, args["id"].(uint)), true

	case "Mutation.blockTransaction":
		if e.complexity.Mutation.BlockTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_blockTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BlockTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.blockUser":
		if e.complexity.Mutation.BlockUser == nil {
			break
		}

		args, err := ec.field_Mutation_blockUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BlockUser(childComplexity, args["id"].(uint)), true

	case "Mutation.cancelTransaction":
		if e.complexity.Mutation.CancelTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_cancelTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.completeQna":
		if e.complexity.Mutation.CompleteQna == nil {
			break
		}

		args, err := ec.field_Mutation_completeQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CompleteQna(childComplexity, args["id"].(uint)), true

	case "Mutation.createAdminPermission":
		if e.complexity.Mutation.CreateAdminPermission == nil {
			break
		}

		args, err := ec.field_Mutation_createAdminPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAdminPermission(childComplexity, args["input"].(model.NewAdminPermission)), true

	case "Mutation.createAnnouncement":
		if e.complexity.Mutation.CreateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_createAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAnnouncement(childComplexity, args["input"].(model.NewAnnouncementInput)), true

	case "Mutation.createBank":
		if e.complexity.Mutation.CreateBank == nil {
			break
		}

		args, err := ec.field_Mutation_createBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBank(childComplexity, args["input"].(model.NewBankInput)), true

	case "Mutation.createDomain":
		if e.complexity.Mutation.CreateDomain == nil {
			break
		}

		args, err := ec.field_Mutation_createDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDomain(childComplexity, args["input"].(model.NewDomainInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(model.NewEventInput)), true

	case "Mutation.createGameApi":
		if e.complexity.Mutation.CreateGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_createGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGameAPI(childComplexity, args["input"].(model.NewGameAPIInput)), true

	case "Mutation.createInbox":
		if e.complexity.Mutation.CreateInbox == nil {
			break
		}

		args, err := ec.field_Mutation_createInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateInbox(childComplexity, args["input"].(model.NewInboxInput)), true

	case "Mutation.createLog":
		if e.complexity.Mutation.CreateLog == nil {
			break
		}

		args, err := ec.field_Mutation_createLog_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLog(childComplexity, args["input"].(model.NewLogInput)), true

	case "Mutation.createMenu":
		if e.complexity.Mutation.CreateMenu == nil {
			break
		}

		args, err := ec.field_Mutation_createMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMenu(childComplexity, args["input"].(model.NewMenuInput)), true

	case "Mutation.createNotification":
		if e.complexity.Mutation.CreateNotification == nil {
			break
		}

		args, err := ec.field_Mutation_createNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNotification(childComplexity, args["input"].(model.NewNotificationInput)), true

	case "Mutation.createQna":
		if e.complexity.Mutation.CreateQna == nil {
			break
		}

		args, err := ec.field_Mutation_createQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQna(childComplexity, args["input"].(model.NewQnaInput)), true

	case "Mutation.createSMSApi":
		if e.complexity.Mutation.CreateSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_createSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSMSApi(childComplexity, args["input"].(model.NewSMSApiInput)), true

	case "Mutation.createSetting":
		if e.complexity.Mutation.CreateSetting == nil {
			break
		}

		args, err := ec.field_Mutation_createSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSetting(childComplexity, args["input"].(model.NewSettingInput)), true

	case "Mutation.createTodo":
		if e.complexity.Mutation.CreateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_createTodo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTodo(childComplexity, args["input"].(model.NewTodo)), true

	case "Mutation.createTransaction":
		if e.complexity.Mutation.CreateTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_createTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransaction(childComplexity, args["input"].(model.NewTransactionInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(*model.NewUser)), true

	case "Mutation.deleteAnnouncement":
		if e.complexity.Mutation.DeleteAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAnnouncement(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteBank":
		if e.complexity.Mutation.DeleteBank == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBank(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteDomain":
		if e.complexity.Mutation.DeleteDomain == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDomain(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteGameApi":
		if e.complexity.Mutation.DeleteGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGameAPI(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteInbox":
		if e.complexity.Mutation.DeleteInbox == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInbox(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteLog":
		if e.complexity.Mutation.DeleteLog == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLog_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLog(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteMenu":
		if e.complexity.Mutation.DeleteMenu == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMenu(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteNotification":
		if e.complexity.Mutation.DeleteNotification == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNotification(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteProfile":
		if e.complexity.Mutation.DeleteProfile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProfile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProfile(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteQna":
		if e.complexity.Mutation.DeleteQna == nil {
			break
		}

		args, err := ec.field_Mutation_deleteQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteQna(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteSMSApi":
		if e.complexity.Mutation.DeleteSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSMSApi(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteSetting":
		if e.complexity.Mutation.DeleteSetting == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSetting(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteTransaction":
		if e.complexity.Mutation.DeleteTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.replyQna":
		if e.complexity.Mutation.ReplyQna == nil {
			break
		}

		args, err := ec.field_Mutation_replyQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReplyQna(childComplexity, args["id"].(uint), args["input"].(model.UpdateQnaInput)), true

	case "Mutation.time":
		if e.complexity.Mutation.Time == nil {
			break
		}

		return e.complexity.Mutation.Time(childComplexity), true

	case "Mutation.updateAdminPermission":
		if e.complexity.Mutation.UpdateAdminPermission == nil {
			break
		}

		args, err := ec.field_Mutation_updateAdminPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAdminPermission(childComplexity, args["id"].(uint), args["input"].(model.UpdateAdminPermissionInput)), true

	case "Mutation.updateAnnouncement":
		if e.complexity.Mutation.UpdateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_updateAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAnnouncement(childComplexity, args["id"].(uint), args["input"].(model.UpdateAnnouncementInput)), true

	case "Mutation.updateBank":
		if e.complexity.Mutation.UpdateBank == nil {
			break
		}

		args, err := ec.field_Mutation_updateBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBank(childComplexity, args["id"].(uint), args["input"].(model.UpdateBankInput)), true

	case "Mutation.updateDomain":
		if e.complexity.Mutation.UpdateDomain == nil {
			break
		}

		args, err := ec.field_Mutation_updateDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDomain(childComplexity, args["id"].(uint), args["input"].(model.UpdateDomainInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["id"].(uint), args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateGameApi":
		if e.complexity.Mutation.UpdateGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_updateGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGameAPI(childComplexity, args["id"].(uint), args["input"].(model.UpdateGameAPIInput)), true

	case "Mutation.updateInbox":
		if e.complexity.Mutation.UpdateInbox == nil {
			break
		}

		args, err := ec.field_Mutation_updateInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInbox(childComplexity, args["id"].(uint), args["input"].(model.UpdateInboxInput)), true

	case "Mutation.updateMenu":
		if e.complexity.Mutation.UpdateMenu == nil {
			break
		}

		args, err := ec.field_Mutation_updateMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMenu(childComplexity, args["id"].(uint), args["input"].(model.UpdateMenuInput)), true

	case "Mutation.updateNotification":
		if e.complexity.Mutation.UpdateNotification == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotification(childComplexity, args["id"].(uint), args["input"].(model.UpdateNotificationInput)), true

	case "Mutation.updateProfile":
		if e.complexity.Mutation.UpdateProfile == nil {
			break
		}

		args, err := ec.field_Mutation_updateProfile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProfile(childComplexity, args["id"].(uint), args["input"].(model.UpdateProfile)), true

	case "Mutation.updateQna":
		if e.complexity.Mutation.UpdateQna == nil {
			break
		}

		args, err := ec.field_Mutation_updateQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateQna(childComplexity, args["id"].(uint), args["input"].(model.UpdateQnaInput)), true

	case "Mutation.updateSMSApi":
		if e.complexity.Mutation.UpdateSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_updateSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSMSApi(childComplexity, args["id"].(uint), args["input"].(model.UpdateSMSApiInput)), true

	case "Mutation.updateSetting":
		if e.complexity.Mutation.UpdateSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSetting(childComplexity, args["id"].(uint), args["input"].(model.UpdateSettingInput)), true

	case "Mutation.updateTransaction":
		if e.complexity.Mutation.UpdateTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTransaction(childComplexity, args["id"].(uint), args["input"].(model.UpdateTransactionInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(uint), args["input"].(model.UpdateUser)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload)), true

	case "Mutation.waitingTransaction":
		if e.complexity.Mutation.WaitingTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_waitingTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WaitingTransaction(childComplexity, args["id"].(uint)), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.deletedAt":
		if e.complexity.Notification.DeletedAt == nil {
			break
		}

		return e.complexity.Notification.DeletedAt(childComplexity), true

	case "Notification.description":
		if e.complexity.Notification.Description == nil {
			break
		}

		return e.complexity.Notification.Description(childComplexity), true

	case "Notification.domain":
		if e.complexity.Notification.Domain == nil {
			break
		}

		return e.complexity.Notification.Domain(childComplexity), true

	case "Notification.domainId":
		if e.complexity.Notification.DomainID == nil {
			break
		}

		return e.complexity.Notification.DomainID(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.imageUpload":
		if e.complexity.Notification.ImageUpload == nil {
			break
		}

		return e.complexity.Notification.ImageUpload(childComplexity), true

	case "Notification.level":
		if e.complexity.Notification.Level == nil {
			break
		}

		return e.complexity.Notification.Level(childComplexity), true

	case "Notification.mainImage":
		if e.complexity.Notification.MainImage == nil {
			break
		}

		return e.complexity.Notification.MainImage(childComplexity), true

	case "Notification.noticeType":
		if e.complexity.Notification.NoticeType == nil {
			break
		}

		return e.complexity.Notification.NoticeType(childComplexity), true

	case "Notification.orderNum":
		if e.complexity.Notification.OrderNum == nil {
			break
		}

		return e.complexity.Notification.OrderNum(childComplexity), true

	case "Notification.registerDate":
		if e.complexity.Notification.RegisterDate == nil {
			break
		}

		return e.complexity.Notification.RegisterDate(childComplexity), true

	case "Notification.showFrom":
		if e.complexity.Notification.ShowFrom == nil {
			break
		}

		return e.complexity.Notification.ShowFrom(childComplexity), true

	case "Notification.showTo":
		if e.complexity.Notification.ShowTo == nil {
			break
		}

		return e.complexity.Notification.ShowTo(childComplexity), true

	case "Notification.status":
		if e.complexity.Notification.Status == nil {
			break
		}

		return e.complexity.Notification.Status(childComplexity), true

	case "Notification.title":
		if e.complexity.Notification.Title == nil {
			break
		}

		return e.complexity.Notification.Title(childComplexity), true

	case "Notification.updatedAt":
		if e.complexity.Notification.UpdatedAt == nil {
			break
		}

		return e.complexity.Notification.UpdatedAt(childComplexity), true

	case "Notification.views":
		if e.complexity.Notification.Views == nil {
			break
		}

		return e.complexity.Notification.Views(childComplexity), true

	case "NotificationList.notifications":
		if e.complexity.NotificationList.Notifications == nil {
			break
		}

		return e.complexity.NotificationList.Notifications(childComplexity), true

	case "NotificationList.total":
		if e.complexity.NotificationList.Total == nil {
			break
		}

		return e.complexity.NotificationList.Total(childComplexity), true

	case "Profile.accountNumber":
		if e.complexity.Profile.AccountNumber == nil {
			break
		}

		return e.complexity.Profile.AccountNumber(childComplexity), true

	case "Profile.avatarUrl":
		if e.complexity.Profile.AvatarURL == nil {
			break
		}

		return e.complexity.Profile.AvatarURL(childComplexity), true

	case "Profile.balance":
		if e.complexity.Profile.Balance == nil {
			break
		}

		return e.complexity.Profile.Balance(childComplexity), true

	case "Profile.bankName":
		if e.complexity.Profile.BankName == nil {
			break
		}

		return e.complexity.Profile.BankName(childComplexity), true

	case "Profile.bio":
		if e.complexity.Profile.Bio == nil {
			break
		}

		return e.complexity.Profile.Bio(childComplexity), true

	case "Profile.birthday":
		if e.complexity.Profile.Birthday == nil {
			break
		}

		return e.complexity.Profile.Birthday(childComplexity), true

	case "Profile.comp":
		if e.complexity.Profile.Comp == nil {
			break
		}

		return e.complexity.Profile.Comp(childComplexity), true

	case "Profile.coupon":
		if e.complexity.Profile.Coupon == nil {
			break
		}

		return e.complexity.Profile.Coupon(childComplexity), true

	case "Profile.createdAt":
		if e.complexity.Profile.CreatedAt == nil {
			break
		}

		return e.complexity.Profile.CreatedAt(childComplexity), true

	case "Profile.deletedAt":
		if e.complexity.Profile.DeletedAt == nil {
			break
		}

		return e.complexity.Profile.DeletedAt(childComplexity), true

	case "Profile.favorites":
		if e.complexity.Profile.Favorites == nil {
			break
		}

		return e.complexity.Profile.Favorites(childComplexity), true

	case "Profile.holderName":
		if e.complexity.Profile.HolderName == nil {
			break
		}

		return e.complexity.Profile.HolderName(childComplexity), true

	case "Profile.id":
		if e.complexity.Profile.ID == nil {
			break
		}

		return e.complexity.Profile.ID(childComplexity), true

	case "Profile.lastDeposit":
		if e.complexity.Profile.LastDeposit == nil {
			break
		}

		return e.complexity.Profile.LastDeposit(childComplexity), true

	case "Profile.lastWithdraw":
		if e.complexity.Profile.LastWithdraw == nil {
			break
		}

		return e.complexity.Profile.LastWithdraw(childComplexity), true

	case "Profile.level":
		if e.complexity.Profile.Level == nil {
			break
		}

		return e.complexity.Profile.Level(childComplexity), true

	case "Profile.mobile":
		if e.complexity.Profile.Mobile == nil {
			break
		}

		return e.complexity.Profile.Mobile(childComplexity), true

	case "Profile.name":
		if e.complexity.Profile.Name == nil {
			break
		}

		return e.complexity.Profile.Name(childComplexity), true

	case "Profile.nickname":
		if e.complexity.Profile.Nickname == nil {
			break
		}

		return e.complexity.Profile.Nickname(childComplexity), true

	case "Profile.orderNum":
		if e.complexity.Profile.OrderNum == nil {
			break
		}

		return e.complexity.Profile.OrderNum(childComplexity), true

	case "Profile.phone":
		if e.complexity.Profile.Phone == nil {
			break
		}

		return e.complexity.Profile.Phone(childComplexity), true

	case "Profile.phoneVerified":
		if e.complexity.Profile.PhoneVerified == nil {
			break
		}

		return e.complexity.Profile.PhoneVerified(childComplexity), true

	case "Profile.point":
		if e.complexity.Profile.Point == nil {
			break
		}

		return e.complexity.Profile.Point(childComplexity), true

	case "Profile.referral":
		if e.complexity.Profile.Referral == nil {
			break
		}

		return e.complexity.Profile.Referral(childComplexity), true

	case "Profile.roll":
		if e.complexity.Profile.Roll == nil {
			break
		}

		return e.complexity.Profile.Roll(childComplexity), true

	case "Profile.socialLinks":
		if e.complexity.Profile.SocialLinks == nil {
			break
		}

		return e.complexity.Profile.SocialLinks(childComplexity), true

	case "Profile.updatedAt":
		if e.complexity.Profile.UpdatedAt == nil {
			break
		}

		return e.complexity.Profile.UpdatedAt(childComplexity), true

	case "Profile.userId":
		if e.complexity.Profile.UserID == nil {
			break
		}

		return e.complexity.Profile.UserID(childComplexity), true

	case "Qna.answer":
		if e.complexity.Qna.Answer == nil {
			break
		}

		return e.complexity.Qna.Answer(childComplexity), true

	case "Qna.answerTitle":
		if e.complexity.Qna.AnswerTitle == nil {
			break
		}

		return e.complexity.Qna.AnswerTitle(childComplexity), true

	case "Qna.createdAt":
		if e.complexity.Qna.CreatedAt == nil {
			break
		}

		return e.complexity.Qna.CreatedAt(childComplexity), true

	case "Qna.deletedAt":
		if e.complexity.Qna.DeletedAt == nil {
			break
		}

		return e.complexity.Qna.DeletedAt(childComplexity), true

	case "Qna.domain":
		if e.complexity.Qna.Domain == nil {
			break
		}

		return e.complexity.Qna.Domain(childComplexity), true

	case "Qna.domainId":
		if e.complexity.Qna.DomainID == nil {
			break
		}

		return e.complexity.Qna.DomainID(childComplexity), true

	case "Qna.id":
		if e.complexity.Qna.ID == nil {
			break
		}

		return e.complexity.Qna.ID(childComplexity), true

	case "Qna.question":
		if e.complexity.Qna.Question == nil {
			break
		}

		return e.complexity.Qna.Question(childComplexity), true

	case "Qna.questionTitle":
		if e.complexity.Qna.QuestionTitle == nil {
			break
		}

		return e.complexity.Qna.QuestionTitle(childComplexity), true

	case "Qna.repliedAt":
		if e.complexity.Qna.RepliedAt == nil {
			break
		}

		return e.complexity.Qna.RepliedAt(childComplexity), true

	case "Qna.status":
		if e.complexity.Qna.Status == nil {
			break
		}

		return e.complexity.Qna.Status(childComplexity), true

	case "Qna.type":
		if e.complexity.Qna.Type == nil {
			break
		}

		return e.complexity.Qna.Type(childComplexity), true

	case "Qna.updatedAt":
		if e.complexity.Qna.UpdatedAt == nil {
			break
		}

		return e.complexity.Qna.UpdatedAt(childComplexity), true

	case "Qna.user":
		if e.complexity.Qna.User == nil {
			break
		}

		return e.complexity.Qna.User(childComplexity), true

	case "Qna.userId":
		if e.complexity.Qna.UserID == nil {
			break
		}

		return e.complexity.Qna.UserID(childComplexity), true

	case "QnaList.qnas":
		if e.complexity.QnaList.Qnas == nil {
			break
		}

		return e.complexity.QnaList.Qnas(childComplexity), true

	case "QnaList.total":
		if e.complexity.QnaList.Total == nil {
			break
		}

		return e.complexity.QnaList.Total(childComplexity), true

	case "Query.adminPermissions":
		if e.complexity.Query.AdminPermissions == nil {
			break
		}

		args, err := ec.field_Query_adminPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminPermissions(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.announcements":
		if e.complexity.Query.Announcements == nil {
			break
		}

		return e.complexity.Query.Announcements(childComplexity), true

	case "Query.connectedUsers":
		if e.complexity.Query.ConnectedUsers == nil {
			break
		}

		args, err := ec.field_Query_connectedUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectedUsers(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.domains":
		if e.complexity.Query.Domains == nil {
			break
		}

		return e.complexity.Query.Domains(childComplexity), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		return e.complexity.Query.Events(childComplexity), true

	case "Query.filterUsers":
		if e.complexity.Query.FilterUsers == nil {
			break
		}

		args, err := ec.field_Query_filterUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FilterUsers(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getAnnouncements":
		if e.complexity.Query.GetAnnouncements == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncements_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncements(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getBanks":
		if e.complexity.Query.GetBanks == nil {
			break
		}

		args, err := ec.field_Query_getBanks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBanks(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDistributorDetails":
		if e.complexity.Query.GetDistributorDetails == nil {
			break
		}

		args, err := ec.field_Query_getDistributorDetails_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDistributorDetails(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDistributors":
		if e.complexity.Query.GetDistributors == nil {
			break
		}

		args, err := ec.field_Query_getDistributors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDistributors(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDomains":
		if e.complexity.Query.GetDomains == nil {
			break
		}

		args, err := ec.field_Query_getDomains_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDomains(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getEvents":
		if e.complexity.Query.GetEvents == nil {
			break
		}

		args, err := ec.field_Query_getEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvents(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getGameApis":
		if e.complexity.Query.GetGameApis == nil {
			break
		}

		args, err := ec.field_Query_getGameApis_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGameApis(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getInboxes":
		if e.complexity.Query.GetInboxes == nil {
			break
		}

		args, err := ec.field_Query_getInboxes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInboxes(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getLogs":
		if e.complexity.Query.GetLogs == nil {
			break
		}

		args, err := ec.field_Query_getLogs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLogs(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getMenus":
		if e.complexity.Query.GetMenus == nil {
			break
		}

		args, err := ec.field_Query_getMenus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMenus(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getNotifications":
		if e.complexity.Query.GetNotifications == nil {
			break
		}

		args, err := ec.field_Query_getNotifications_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNotifications(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getQnas":
		if e.complexity.Query.GetQnas == nil {
			break
		}

		args, err := ec.field_Query_getQnas_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetQnas(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getSMSApis":
		if e.complexity.Query.GetSMSApis == nil {
			break
		}

		args, err := ec.field_Query_getSMSApis_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMSApis(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getSetting":
		if e.complexity.Query.GetSetting == nil {
			break
		}

		return e.complexity.Query.GetSetting(childComplexity), true

	case "Query.getTransactions":
		if e.complexity.Query.GetTransactions == nil {
			break
		}

		args, err := ec.field_Query_getTransactions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTransactions(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getUserMenus":
		if e.complexity.Query.GetUserMenus == nil {
			break
		}

		return e.complexity.Query.GetUserMenus(childComplexity), true

	case "Query.getWeeklyLosingData":
		if e.complexity.Query.GetWeeklyLosingData == nil {
			break
		}

		args, err := ec.field_Query_getWeeklyLosingData_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWeeklyLosingData(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.logs":
		if e.complexity.Query.Logs == nil {
			break
		}

		return e.complexity.Query.Logs(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		return e.complexity.Query.Notifications(childComplexity), true

	case "Query.profile":
		if e.complexity.Query.Profile == nil {
			break
		}

		return e.complexity.Query.Profile(childComplexity), true

	case "Query.time":
		if e.complexity.Query.Time == nil {
			break
		}

		return e.complexity.Query.Time(childComplexity), true

	case "Query.todos":
		if e.complexity.Query.Todos == nil {
			break
		}

		return e.complexity.Query.Todos(childComplexity), true

	case "Query.topEvents":
		if e.complexity.Query.TopEvents == nil {
			break
		}

		return e.complexity.Query.TopEvents(childComplexity), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(uint)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "SMSApi.agent":
		if e.complexity.SMSApi.Agent == nil {
			break
		}

		return e.complexity.SMSApi.Agent(childComplexity), true

	case "SMSApi.createdAt":
		if e.complexity.SMSApi.CreatedAt == nil {
			break
		}

		return e.complexity.SMSApi.CreatedAt(childComplexity), true

	case "SMSApi.deletedAt":
		if e.complexity.SMSApi.DeletedAt == nil {
			break
		}

		return e.complexity.SMSApi.DeletedAt(childComplexity), true

	case "SMSApi.id":
		if e.complexity.SMSApi.ID == nil {
			break
		}

		return e.complexity.SMSApi.ID(childComplexity), true

	case "SMSApi.name":
		if e.complexity.SMSApi.Name == nil {
			break
		}

		return e.complexity.SMSApi.Name(childComplexity), true

	case "SMSApi.orderNum":
		if e.complexity.SMSApi.OrderNum == nil {
			break
		}

		return e.complexity.SMSApi.OrderNum(childComplexity), true

	case "SMSApi.password":
		if e.complexity.SMSApi.Password == nil {
			break
		}

		return e.complexity.SMSApi.Password(childComplexity), true

	case "SMSApi.status":
		if e.complexity.SMSApi.Status == nil {
			break
		}

		return e.complexity.SMSApi.Status(childComplexity), true

	case "SMSApi.token":
		if e.complexity.SMSApi.Token == nil {
			break
		}

		return e.complexity.SMSApi.Token(childComplexity), true

	case "SMSApi.updatedAt":
		if e.complexity.SMSApi.UpdatedAt == nil {
			break
		}

		return e.complexity.SMSApi.UpdatedAt(childComplexity), true

	case "SMSApi.url":
		if e.complexity.SMSApi.Url == nil {
			break
		}

		return e.complexity.SMSApi.Url(childComplexity), true

	case "SMSApiList.smsApis":
		if e.complexity.SMSApiList.SmsApis == nil {
			break
		}

		return e.complexity.SMSApiList.SmsApis(childComplexity), true

	case "SMSApiList.total":
		if e.complexity.SMSApiList.Total == nil {
			break
		}

		return e.complexity.SMSApiList.Total(childComplexity), true

	case "Setting.createdAt":
		if e.complexity.Setting.CreatedAt == nil {
			break
		}

		return e.complexity.Setting.CreatedAt(childComplexity), true

	case "Setting.deletedAt":
		if e.complexity.Setting.DeletedAt == nil {
			break
		}

		return e.complexity.Setting.DeletedAt(childComplexity), true

	case "Setting.description":
		if e.complexity.Setting.Description == nil {
			break
		}

		return e.complexity.Setting.Description(childComplexity), true

	case "Setting.id":
		if e.complexity.Setting.ID == nil {
			break
		}

		return e.complexity.Setting.ID(childComplexity), true

	case "Setting.orderNum":
		if e.complexity.Setting.OrderNum == nil {
			break
		}

		return e.complexity.Setting.OrderNum(childComplexity), true

	case "Setting.primaryDomain":
		if e.complexity.Setting.PrimaryDomain == nil {
			break
		}

		return e.complexity.Setting.PrimaryDomain(childComplexity), true

	case "Setting.status":
		if e.complexity.Setting.Status == nil {
			break
		}

		return e.complexity.Setting.Status(childComplexity), true

	case "Setting.title":
		if e.complexity.Setting.Title == nil {
			break
		}

		return e.complexity.Setting.Title(childComplexity), true

	case "Setting.totalExFrom":
		if e.complexity.Setting.TotalExFrom == nil {
			break
		}

		return e.complexity.Setting.TotalExFrom(childComplexity), true

	case "Setting.totalExStatus":
		if e.complexity.Setting.TotalExStatus == nil {
			break
		}

		return e.complexity.Setting.TotalExStatus(childComplexity), true

	case "Setting.totalExTo":
		if e.complexity.Setting.TotalExTo == nil {
			break
		}

		return e.complexity.Setting.TotalExTo(childComplexity), true

	case "Setting.totalReFrom":
		if e.complexity.Setting.TotalReFrom == nil {
			break
		}

		return e.complexity.Setting.TotalReFrom(childComplexity), true

	case "Setting.totalReStatus":
		if e.complexity.Setting.TotalReStatus == nil {
			break
		}

		return e.complexity.Setting.TotalReStatus(childComplexity), true

	case "Setting.totalReTo":
		if e.complexity.Setting.TotalReTo == nil {
			break
		}

		return e.complexity.Setting.TotalReTo(childComplexity), true

	case "Setting.updatedAt":
		if e.complexity.Setting.UpdatedAt == nil {
			break
		}

		return e.complexity.Setting.UpdatedAt(childComplexity), true

	case "Setting.user":
		if e.complexity.Setting.User == nil {
			break
		}

		return e.complexity.Setting.User(childComplexity), true

	case "Setting.userExFrom":
		if e.complexity.Setting.UserExFrom == nil {
			break
		}

		return e.complexity.Setting.UserExFrom(childComplexity), true

	case "Setting.userExStatus":
		if e.complexity.Setting.UserExStatus == nil {
			break
		}

		return e.complexity.Setting.UserExStatus(childComplexity), true

	case "Setting.userExTo":
		if e.complexity.Setting.UserExTo == nil {
			break
		}

		return e.complexity.Setting.UserExTo(childComplexity), true

	case "Setting.userId":
		if e.complexity.Setting.UserID == nil {
			break
		}

		return e.complexity.Setting.UserID(childComplexity), true

	case "Setting.userReFrom":
		if e.complexity.Setting.UserReFrom == nil {
			break
		}

		return e.complexity.Setting.UserReFrom(childComplexity), true

	case "Setting.userReStatus":
		if e.complexity.Setting.UserReStatus == nil {
			break
		}

		return e.complexity.Setting.UserReStatus(childComplexity), true

	case "Setting.userReTo":
		if e.complexity.Setting.UserReTo == nil {
			break
		}

		return e.complexity.Setting.UserReTo(childComplexity), true

	case "Subscription.time":
		if e.complexity.Subscription.Time == nil {
			break
		}

		return e.complexity.Subscription.Time(childComplexity), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.text":
		if e.complexity.Todo.Text == nil {
			break
		}

		return e.complexity.Todo.Text(childComplexity), true

	case "Todo.user":
		if e.complexity.Todo.User == nil {
			break
		}

		return e.complexity.Todo.User(childComplexity), true

	case "Transaction.amount":
		if e.complexity.Transaction.Amount == nil {
			break
		}

		return e.complexity.Transaction.Amount(childComplexity), true

	case "Transaction.approvedAt":
		if e.complexity.Transaction.ApprovedAt == nil {
			break
		}

		return e.complexity.Transaction.ApprovedAt(childComplexity), true

	case "Transaction.balanceAfter":
		if e.complexity.Transaction.BalanceAfter == nil {
			break
		}

		return e.complexity.Transaction.BalanceAfter(childComplexity), true

	case "Transaction.balanceBefore":
		if e.complexity.Transaction.BalanceBefore == nil {
			break
		}

		return e.complexity.Transaction.BalanceBefore(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.deletedAt":
		if e.complexity.Transaction.DeletedAt == nil {
			break
		}

		return e.complexity.Transaction.DeletedAt(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.pointAfter":
		if e.complexity.Transaction.PointAfter == nil {
			break
		}

		return e.complexity.Transaction.PointAfter(childComplexity), true

	case "Transaction.pointBefore":
		if e.complexity.Transaction.PointBefore == nil {
			break
		}

		return e.complexity.Transaction.PointBefore(childComplexity), true

	case "Transaction.shortcut":
		if e.complexity.Transaction.Shortcut == nil {
			break
		}

		return e.complexity.Transaction.Shortcut(childComplexity), true

	case "Transaction.status":
		if e.complexity.Transaction.Status == nil {
			break
		}

		return e.complexity.Transaction.Status(childComplexity), true

	case "Transaction.transactionAt":
		if e.complexity.Transaction.TransactionAt == nil {
			break
		}

		return e.complexity.Transaction.TransactionAt(childComplexity), true

	case "Transaction.type":
		if e.complexity.Transaction.Type == nil {
			break
		}

		return e.complexity.Transaction.Type(childComplexity), true

	case "Transaction.usdtDesc":
		if e.complexity.Transaction.USDTDesc == nil {
			break
		}

		return e.complexity.Transaction.USDTDesc(childComplexity), true

	case "Transaction.updatedAt":
		if e.complexity.Transaction.UpdatedAt == nil {
			break
		}

		return e.complexity.Transaction.UpdatedAt(childComplexity), true

	case "Transaction.user":
		if e.complexity.Transaction.User == nil {
			break
		}

		return e.complexity.Transaction.User(childComplexity), true

	case "Transaction.userId":
		if e.complexity.Transaction.UserID == nil {
			break
		}

		return e.complexity.Transaction.UserID(childComplexity), true

	case "TransactionList.total":
		if e.complexity.TransactionList.Total == nil {
			break
		}

		return e.complexity.TransactionList.Total(childComplexity), true

	case "TransactionList.transactions":
		if e.complexity.TransactionList.Transactions == nil {
			break
		}

		return e.complexity.TransactionList.Transactions(childComplexity), true

	case "User.blackMemo":
		if e.complexity.User.BlackMemo == nil {
			break
		}

		return e.complexity.User.BlackMemo(childComplexity), true

	case "User.children":
		if e.complexity.User.Children == nil {
			break
		}

		return e.complexity.User.Children(childComplexity), true

	case "User.childrenCount":
		if e.complexity.User.ChildrenCount == nil {
			break
		}

		return e.complexity.User.ChildrenCount(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.currentIP":
		if e.complexity.User.CurrentIP == nil {
			break
		}

		return e.complexity.User.CurrentIP(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.device":
		if e.complexity.User.Device == nil {
			break
		}

		return e.complexity.User.Device(childComplexity), true

	case "User.entireLosing":
		if e.complexity.User.EntireLosing == nil {
			break
		}

		return e.complexity.User.EntireLosing(childComplexity), true

	case "User.fingerPrint":
		if e.complexity.User.FingerPrint == nil {
			break
		}

		return e.complexity.User.FingerPrint(childComplexity), true

	case "User.hold":
		if e.complexity.User.Hold == nil {
			break
		}

		return e.complexity.User.Hold(childComplexity), true

	case "User.holdLosingBeDang":
		if e.complexity.User.HoldLosingBeDang == nil {
			break
		}

		return e.complexity.User.HoldLosingBeDang(childComplexity), true

	case "User.holdemBetting":
		if e.complexity.User.HoldemBetting == nil {
			break
		}

		return e.complexity.User.HoldemBetting(childComplexity), true

	case "User.holdemWinning":
		if e.complexity.User.HoldemWinning == nil {
			break
		}

		return e.complexity.User.HoldemWinning(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.IP":
		if e.complexity.User.IP == nil {
			break
		}

		return e.complexity.User.IP(childComplexity), true

	case "User.live":
		if e.complexity.User.Live == nil {
			break
		}

		return e.complexity.User.Live(childComplexity), true

	case "User.liveBetting":
		if e.complexity.User.LiveBetting == nil {
			break
		}

		return e.complexity.User.LiveBetting(childComplexity), true

	case "User.liveLosingBeDang":
		if e.complexity.User.LiveLosingBeDang == nil {
			break
		}

		return e.complexity.User.LiveLosingBeDang(childComplexity), true

	case "User.liveWinning":
		if e.complexity.User.LiveWinning == nil {
			break
		}

		return e.complexity.User.LiveWinning(childComplexity), true

	case "User.losingMethod":
		if e.complexity.User.LosingMethod == nil {
			break
		}

		return e.complexity.User.LosingMethod(childComplexity), true

	case "User.losingRate":
		if e.complexity.User.LosingRate == nil {
			break
		}

		return e.complexity.User.LosingRate(childComplexity), true

	case "User.losingSettlement":
		if e.complexity.User.LosingSettlement == nil {
			break
		}

		return e.complexity.User.LosingSettlement(childComplexity), true

	case "User.lotusBetting":
		if e.complexity.User.LotusBetting == nil {
			break
		}

		return e.complexity.User.LotusBetting(childComplexity), true

	case "User.lotusLottery":
		if e.complexity.User.LotusLottery == nil {
			break
		}

		return e.complexity.User.LotusLottery(childComplexity), true

	case "User.lotusRolling":
		if e.complexity.User.LotusRolling == nil {
			break
		}

		return e.complexity.User.LotusRolling(childComplexity), true

	case "User.membershipDeposit":
		if e.complexity.User.MembershipDeposit == nil {
			break
		}

		return e.complexity.User.MembershipDeposit(childComplexity), true

	case "User.membershipWithdrawal":
		if e.complexity.User.MembershipWithdrawal == nil {
			break
		}

		return e.complexity.User.MembershipWithdrawal(childComplexity), true

	case "User.mgmBetting":
		if e.complexity.User.MgmBetting == nil {
			break
		}

		return e.complexity.User.MgmBetting(childComplexity), true

	case "User.mgmRolling":
		if e.complexity.User.MgmRolling == nil {
			break
		}

		return e.complexity.User.MgmRolling(childComplexity), true

	case "User.mgmWinning":
		if e.complexity.User.MgmWinning == nil {
			break
		}

		return e.complexity.User.MgmWinning(childComplexity), true

	case "User.miniCombinationBetting":
		if e.complexity.User.MiniCombinationBetting == nil {
			break
		}

		return e.complexity.User.MiniCombinationBetting(childComplexity), true

	case "User.miniCombinationRolling":
		if e.complexity.User.MiniCombinationRolling == nil {
			break
		}

		return e.complexity.User.MiniCombinationRolling(childComplexity), true

	case "User.miniCombinationWinnings":
		if e.complexity.User.MiniCombinationWinnings == nil {
			break
		}

		return e.complexity.User.MiniCombinationWinnings(childComplexity), true

	case "User.miniDanpolBetting":
		if e.complexity.User.MiniDanpolBetting == nil {
			break
		}

		return e.complexity.User.MiniDanpolBetting(childComplexity), true

	case "User.miniDanpolRolling":
		if e.complexity.User.MiniDanpolRolling == nil {
			break
		}

		return e.complexity.User.MiniDanpolRolling(childComplexity), true

	case "User.miniDanpolWinner":
		if e.complexity.User.MiniDanpolWinner == nil {
			break
		}

		return e.complexity.User.MiniDanpolWinner(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.numberOfMembers":
		if e.complexity.User.NumberOfMembers == nil {
			break
		}

		return e.complexity.User.NumberOfMembers(childComplexity), true

	case "User.os":
		if e.complexity.User.OS == nil {
			break
		}

		return e.complexity.User.OS(childComplexity), true

	case "User.orderNum":
		if e.complexity.User.OrderNum == nil {
			break
		}

		return e.complexity.User.OrderNum(childComplexity), true

	case "User.parent":
		if e.complexity.User.Parent == nil {
			break
		}

		return e.complexity.User.Parent(childComplexity), true

	case "User.parentId":
		if e.complexity.User.ParentID == nil {
			break
		}

		return e.complexity.User.ParentID(childComplexity), true

	case "User.partnershipMoneyInHand":
		if e.complexity.User.PartnershipMoneyInHand == nil {
			break
		}

		return e.complexity.User.PartnershipMoneyInHand(childComplexity), true

	case "User.partnershipRolling":
		if e.complexity.User.PartnershipRolling == nil {
			break
		}

		return e.complexity.User.PartnershipRolling(childComplexity), true

	case "User.profile":
		if e.complexity.User.Profile == nil {
			break
		}

		return e.complexity.User.Profile(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.rollingHoldings":
		if e.complexity.User.RollingHoldings == nil {
			break
		}

		return e.complexity.User.RollingHoldings(childComplexity), true

	case "User.rollingRate":
		if e.complexity.User.RollingRate == nil {
			break
		}

		return e.complexity.User.RollingRate(childComplexity), true

	case "User.rollingTransition":
		if e.complexity.User.RollingTransition == nil {
			break
		}

		return e.complexity.User.RollingTransition(childComplexity), true

	case "User.root":
		if e.complexity.User.Root == nil {
			break
		}

		return e.complexity.User.Root(childComplexity), true

	case "User.rootId":
		if e.complexity.User.RootID == nil {
			break
		}

		return e.complexity.User.RootID(childComplexity), true

	case "User.slot":
		if e.complexity.User.Slot == nil {
			break
		}

		return e.complexity.User.Slot(childComplexity), true

	case "User.slotBetting":
		if e.complexity.User.SlotBetting == nil {
			break
		}

		return e.complexity.User.SlotBetting(childComplexity), true

	case "User.slotJackpot":
		if e.complexity.User.SlotJackpot == nil {
			break
		}

		return e.complexity.User.SlotJackpot(childComplexity), true

	case "User.slotLosingBeDang":
		if e.complexity.User.SlotLosingBeDang == nil {
			break
		}

		return e.complexity.User.SlotLosingBeDang(childComplexity), true

	case "User.sports3PoleRolling":
		if e.complexity.User.Sports3PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports3PoleRolling(childComplexity), true

	case "User.sports3poleBetting":
		if e.complexity.User.Sports3poleBetting == nil {
			break
		}

		return e.complexity.User.Sports3poleBetting(childComplexity), true

	case "User.sports3poleWinner":
		if e.complexity.User.Sports3poleWinner == nil {
			break
		}

		return e.complexity.User.Sports3poleWinner(childComplexity), true

	case "User.sports4PoleRolling":
		if e.complexity.User.Sports4PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports4PoleRolling(childComplexity), true

	case "User.sports4poleBetting":
		if e.complexity.User.Sports4poleBetting == nil {
			break
		}

		return e.complexity.User.Sports4poleBetting(childComplexity), true

	case "User.sports4poleWinner":
		if e.complexity.User.Sports4poleWinner == nil {
			break
		}

		return e.complexity.User.Sports4poleWinner(childComplexity), true

	case "User.sports5PoleRolling":
		if e.complexity.User.Sports5PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports5PoleRolling(childComplexity), true

	case "User.sports5poleBetting":
		if e.complexity.User.Sports5poleBetting == nil {
			break
		}

		return e.complexity.User.Sports5poleBetting(childComplexity), true

	case "User.sports5poleWinner":
		if e.complexity.User.Sports5poleWinner == nil {
			break
		}

		return e.complexity.User.Sports5poleWinner(childComplexity), true

	case "User.sportsDanpolBetting":
		if e.complexity.User.SportsDanpolBetting == nil {
			break
		}

		return e.complexity.User.SportsDanpolBetting(childComplexity), true

	case "User.sportsDanpolRolling":
		if e.complexity.User.SportsDanpolRolling == nil {
			break
		}

		return e.complexity.User.SportsDanpolRolling(childComplexity), true

	case "User.sportsDanpolWinner":
		if e.complexity.User.SportsDanpolWinner == nil {
			break
		}

		return e.complexity.User.SportsDanpolWinner(childComplexity), true

	case "User.sportsDapolBetting":
		if e.complexity.User.SportsDapolBetting == nil {
			break
		}

		return e.complexity.User.SportsDapolBetting(childComplexity), true

	case "User.sportsDapolRolling":
		if e.complexity.User.SportsDapolRolling == nil {
			break
		}

		return e.complexity.User.SportsDapolRolling(childComplexity), true

	case "User.sportsDapolWinner":
		if e.complexity.User.SportsDapolWinner == nil {
			break
		}

		return e.complexity.User.SportsDapolWinner(childComplexity), true

	case "User.sportsDupolBetting":
		if e.complexity.User.SportsDupolBetting == nil {
			break
		}

		return e.complexity.User.SportsDupolBetting(childComplexity), true

	case "User.sportsDupolRolling":
		if e.complexity.User.SportsDupolRolling == nil {
			break
		}

		return e.complexity.User.SportsDupolRolling(childComplexity), true

	case "User.sportsDupolWinner":
		if e.complexity.User.SportsDupolWinner == nil {
			break
		}

		return e.complexity.User.SportsDupolWinner(childComplexity), true

	case "User.status":
		if e.complexity.User.Status == nil {
			break
		}

		return e.complexity.User.Status(childComplexity), true

	case "User.totalWithdrawal":
		if e.complexity.User.TotalWithdrawal == nil {
			break
		}

		return e.complexity.User.TotalWithdrawal(childComplexity), true

	case "User.touchBetting":
		if e.complexity.User.TouchBetting == nil {
			break
		}

		return e.complexity.User.TouchBetting(childComplexity), true

	case "User.touchRolling":
		if e.complexity.User.TouchRolling == nil {
			break
		}

		return e.complexity.User.TouchRolling(childComplexity), true

	case "User.touchWinning":
		if e.complexity.User.TouchWinning == nil {
			break
		}

		return e.complexity.User.TouchWinning(childComplexity), true

	case "User.type":
		if e.complexity.User.Type == nil {
			break
		}

		return e.complexity.User.Type(childComplexity), true

	case "User.usdtAddress":
		if e.complexity.User.USDTAddress == nil {
			break
		}

		return e.complexity.User.USDTAddress(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.userid":
		if e.complexity.User.Userid == nil {
			break
		}

		return e.complexity.User.Userid(childComplexity), true

	case "User.virtualGameBetting":
		if e.complexity.User.VirtualGameBetting == nil {
			break
		}

		return e.complexity.User.VirtualGameBetting(childComplexity), true

	case "User.virtualGameRolling":
		if e.complexity.User.VirtualGameRolling == nil {
			break
		}

		return e.complexity.User.VirtualGameRolling(childComplexity), true

	case "User.virtualGameWinnings":
		if e.complexity.User.VirtualGameWinnings == nil {
			break
		}

		return e.complexity.User.VirtualGameWinnings(childComplexity), true

	case "UserList.total":
		if e.complexity.UserList.Total == nil {
			break
		}

		return e.complexity.UserList.Total(childComplexity), true

	case "UserList.users":
		if e.complexity.UserList.Users == nil {
			break
		}

		return e.complexity.UserList.Users(childComplexity), true

	case "WeeklyLosingData.alias":
		if e.complexity.WeeklyLosingData.Alias == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Alias(childComplexity), true

	case "WeeklyLosingData.applicationDate":
		if e.complexity.WeeklyLosingData.ApplicationDate == nil {
			break
		}

		return e.complexity.WeeklyLosingData.ApplicationDate(childComplexity), true

	case "WeeklyLosingData.depositor":
		if e.complexity.WeeklyLosingData.Depositor == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Depositor(childComplexity), true

	case "WeeklyLosingData.distributorID":
		if e.complexity.WeeklyLosingData.DistributorID == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorID(childComplexity), true

	case "WeeklyLosingData.distributorLevel":
		if e.complexity.WeeklyLosingData.DistributorLevel == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorLevel(childComplexity), true

	case "WeeklyLosingData.distributorName":
		if e.complexity.WeeklyLosingData.DistributorName == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorName(childComplexity), true

	case "WeeklyLosingData.nickname":
		if e.complexity.WeeklyLosingData.Nickname == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Nickname(childComplexity), true

	case "WeeklyLosingData.processingDate":
		if e.complexity.WeeklyLosingData.ProcessingDate == nil {
			break
		}

		return e.complexity.WeeklyLosingData.ProcessingDate(childComplexity), true

	case "WeeklyLosingData.settlementAmount":
		if e.complexity.WeeklyLosingData.SettlementAmount == nil {
			break
		}

		return e.complexity.WeeklyLosingData.SettlementAmount(childComplexity), true

	case "WeeklyLosingData.site":
		if e.complexity.WeeklyLosingData.Site == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Site(childComplexity), true

	case "WeeklyLosingData.situation":
		if e.complexity.WeeklyLosingData.Situation == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Situation(childComplexity), true

	case "WeeklyLosingData.totalBet":
		if e.complexity.WeeklyLosingData.TotalBet == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalBet(childComplexity), true

	case "WeeklyLosingData.totalLosingMoney":
		if e.complexity.WeeklyLosingData.TotalLosingMoney == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalLosingMoney(childComplexity), true

	case "WeeklyLosingData.totalWinner":
		if e.complexity.WeeklyLosingData.TotalWinner == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalWinner(childComplexity), true

	case "WeeklyLosingData.userCount":
		if e.complexity.WeeklyLosingData.UserCount == nil {
			break
		}

		return e.complexity.WeeklyLosingData.UserCount(childComplexity), true

	case "WeeklyLosingData.weekEnd":
		if e.complexity.WeeklyLosingData.WeekEnd == nil {
			break
		}

		return e.complexity.WeeklyLosingData.WeekEnd(childComplexity), true

	case "WeeklyLosingData.weekStart":
		if e.complexity.WeeklyLosingData.WeekStart == nil {
			break
		}

		return e.complexity.WeeklyLosingData.WeekStart(childComplexity), true

	case "WeeklyLosingDataList.total":
		if e.complexity.WeeklyLosingDataList.Total == nil {
			break
		}

		return e.complexity.WeeklyLosingDataList.Total(childComplexity), true

	case "WeeklyLosingDataList.weeklyLosingData":
		if e.complexity.WeeklyLosingDataList.WeeklyLosingData == nil {
			break
		}

		return e.complexity.WeeklyLosingDataList.WeeklyLosingData(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputFilter,
		ec.unmarshalInputNewAdminPermission,
		ec.unmarshalInputNewAnnouncementInput,
		ec.unmarshalInputNewBankInput,
		ec.unmarshalInputNewDomainInput,
		ec.unmarshalInputNewEventInput,
		ec.unmarshalInputNewGameApiInput,
		ec.unmarshalInputNewInboxInput,
		ec.unmarshalInputNewLogInput,
		ec.unmarshalInputNewMenuInput,
		ec.unmarshalInputNewNotificationInput,
		ec.unmarshalInputNewProfile,
		ec.unmarshalInputNewQnaInput,
		ec.unmarshalInputNewSMSApiInput,
		ec.unmarshalInputNewSettingInput,
		ec.unmarshalInputNewTodo,
		ec.unmarshalInputNewTransactionInput,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputOrder,
		ec.unmarshalInputPagination,
		ec.unmarshalInputUpdateAdminPermissionInput,
		ec.unmarshalInputUpdateAnnouncementInput,
		ec.unmarshalInputUpdateBankInput,
		ec.unmarshalInputUpdateDomainInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateGameApiInput,
		ec.unmarshalInputUpdateInboxInput,
		ec.unmarshalInputUpdateMenuInput,
		ec.unmarshalInputUpdateNotificationInput,
		ec.unmarshalInputUpdateProfile,
		ec.unmarshalInputUpdateQnaInput,
		ec.unmarshalInputUpdateSMSApiInput,
		ec.unmarshalInputUpdateSettingInput,
		ec.unmarshalInputUpdateTransactionInput,
		ec.unmarshalInputUpdateUser,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/admin_permission.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type AdminPermission {
  id: ID!
  userId: ID!
  user: User!
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  statistical: Boolean
  ip: Boolean
  dwdelete: Boolean
  status: Boolean
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewAdminPermission {
  userId: ID!
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  status: Boolean
  statistical: Boolean
  ip: Boolean
  dwdelete: Boolean
}
input UpdateAdminPermissionInput {
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  statistical: Boolean
  status: Boolean
  ip: Boolean
  dwdelete: Boolean
}

type AdminPermissionList {
  adminPermissions: [AdminPermission!]!
  total: Int!
}

extend type Query {
  adminPermissions(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): AdminPermissionList!
}

extend type Mutation {
  createAdminPermission(input: NewAdminPermission!): AdminPermission! @hasRole(role: A)
  updateAdminPermission(id:ID!, input: UpdateAdminPermissionInput!): AdminPermission! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/announcement.graphql", Input: `type Announcement {
  id: ID!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  user: User!
  userId: Uint!
  showFrom: Time
  showTo: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateAnnouncementInput {
  title: String
  description: String
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
  level: Uint
}

input NewAnnouncementInput {
  title: String!
  description: String!
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
}

type AnnouncementList {
  announcements: [Announcement!]!
  total: Int!
}

extend type Query {
  announcements: [Announcement!]!
  getAnnouncements(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): AnnouncementList! @hasRole(role: A)
}

extend type Mutation {
  createAnnouncement(input: NewAnnouncementInput!): Announcement!
    @hasRole(role: A)
  updateAnnouncement(id: ID!, input: UpdateAnnouncementInput!): Announcement!
    @hasRole(role: A)
  deleteAnnouncement(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/bank.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Bank {
  id: ID!
  name: String!
  orderNum: Uint
  status: Boolean!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewBankInput {
  name: String!
  orderNum: Uint
  status: Boolean
}

input UpdateBankInput {
  name: String
  orderNum: Uint
  status: Boolean
}

type BankList {
  banks: [Bank!]!
  total: Int!
}

extend type Query {
  getBanks(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): BankList! @hasRole(role: A)
}

extend type Mutation {
  createBank(input: NewBankInput!): Bank! @hasRole(role: A)
  updateBank(id: ID!, input: UpdateBankInput!): Bank! @hasRole(role: A)
  deleteBank(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/domain.graphql", Input: `type Domain {
  id: ID!
  name: String!
  description: String!
  status: Boolean!
  autoReg: Boolean!

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint

  orderNum: Uint
  userId: ID!
  user: User!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateDomainInput {
  name: String
  description: String
  status: Boolean
  userId: ID
  autoReg: Boolean
  orderNum: Uint

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint
}

input NewDomainInput {
  name: String!
  description: String!
  status: Boolean
  userId: ID!
  autoReg: Boolean
  orderNum: Uint

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint
}

type DomainList {
  domains: [Domain!]!
  total: Int!
}

extend type Query {
  domains: [Domain!]
  getDomains(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): DomainList! @hasRole(role: A)
}

extend type Mutation {
  createDomain(input: NewDomainInput!): Domain! @hasRole(role: A)
  updateDomain(id: ID!, input: UpdateDomainInput!): Domain! @hasRole(role: A)
  deleteDomain(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/event.graphql", Input: `type Event {
  id: ID!
  title: String!
  type: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  user: User!
  userId: Uint!
  domainId: Uint
  domain: Domain
  showFrom: Time
  showTo: Time
  category: Uint
  views: Uint
  mainImage: String
  imageUpload: String
  level: Uint
  createdDate: Time!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateEventInput {
  title: String
  type: String
  description: String
  status: Boolean
  orderNum: Uint
  domainId: Uint
  showFrom: Time
  showTo: Time
  level: Uint
  author: String
  category: Uint
  views: Uint
  createdDate: Time
  mainImage: String
  imageUpload: String
}

input NewEventInput {
  title: String!
  author: String!
  category: Uint
  views: Uint
  createdDate: Time
  showFrom: Time
  showTo: Time
  description: String!
  mainImage: String
  imageUpload: String
}

type EventList {
  events: [Event!]!
  total: Int!
}

extend type Query {
  topEvents: [Event!]
  events: [Event!]
  getEvents(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): EventList! @hasRole(role: A)
}

extend type Mutation {
  createEvent(input: NewEventInput!): Event! @hasRole(role: A)
  updateEvent(id: ID!, input: UpdateEventInput!): Event! @hasRole(role: A)
  deleteEvent(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/game_api.graphql", Input: `# Represents a third-party game API configuration in the system.
type GameAPI {
  id: ID!
  apiCompanyName: String!
  gameApiName: String!
  gameCompanyName: String!
  gameType: String!
  other: String
  whetherToUse: Boolean!
  order: Int
  type: String
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewGameApiInput {
  apiCompanyName: String!
  gameApiName: String!
  gameCompanyName: String!
  gameType: String!
  other: String
  whetherToUse: Boolean
  order: Int
  type: String
}

input UpdateGameApiInput {
  apiCompanyName: String
  gameApiName: String
  gameCompanyName: String
  gameType: String
  other: String
  whetherToUse: Boolean
  order: Int
  type: String
}

type GameAPIList {
  gameApis: [GameAPI!]!
  total: Int!
}

extend type Query {
  getGameApis(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): GameAPIList! @hasRole(role: A)
}

extend type Mutation {
  createGameApi(input: NewGameApiInput!): GameAPI! @hasRole(role: A)
  updateGameApi(id: ID!, input: UpdateGameApiInput!): GameAPI! @hasRole(role: A)
  deleteGameApi(id: ID!): Boolean! @hasRole(role: A)
} `, BuiltIn: false},
	{Name: "../schema/inbox.graphql", Input: `type Inbox {
  id: ID!
  type: String!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  userId: Uint!
  user: User!
  fromId: Uint!
  FromUser: User!
  openedAt: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateInboxInput {
  type: String
  title: String
  description: String
  status: Boolean
  userId: Uint
  orderNum: Uint
  openedAt: Time
}

input NewInboxInput {
  type: String
  title: String!
  description: String!
  status: Boolean
  userId: Uint!
  orderNum: Uint
  openedAt: Time
}

type InboxList {
  inboxes: [Inbox!]!
  total: Int!
}

extend type Query {
  getInboxes(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): InboxList! @hasRole(role: A)
}

extend type Mutation {
  createInbox(input: NewInboxInput!): Inbox!
    @hasRole(role: A)
  updateInbox(id: ID!, input: UpdateInboxInput!): Inbox!
    @hasRole(role: A)
  deleteInbox(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/log.graphql", Input: `type Log {
  id: ID!
  data: String
  path: String!
  phone: String!
  method: String!
  type: String!
  ip: String!
  userId: ID
  user: User
  status: String
  os: String
  device: String
  host: String
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewLogInput {
  data: String!
  path: String!
  method: String!
  ip: String!
  type: String!
  phone: String
  status: String
}

type LogList {
  logs: [Log!]!
  total: Int!
}

extend type Query {
  logs: [Log!]
  getLogs(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): LogList! @hasRole(role: A)
}

extend type Mutation {
  createLog(input: NewLogInput!): Log! @hasRole(role: A)
  deleteLog(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/main.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Upload
scalar Time
scalar Uint
scalar DeletedAt
scalar MyCustomBooleanScalar

directive @auth on FIELD_DEFINITION

directive @hasRole(role: Role!) on FIELD_DEFINITION

enum OrderDirection {
  ASC
  DESC
}

enum Role {
  A
  P
  U
}

enum Op {
  eq         # =
  neq        # != or <>
  gt         # >
  gte        # >=
  lt         # <
  lte        # <=
  in         # IN (...)
  not_in     # NOT IN (...)
  like       # LIKE
  not_like   # NOT LIKE
  ilike      # ILIKE (PostgreSQL)
  not_ilike  # NOT ILIKE
  between    # BETWEEN
  not_between # NOT BETWEEN
  is_null    # IS NULL
  is_not_null # IS NOT NULL
}

input Pagination {
  limit: Int = 10
  offset: Int = 0
}

input Order {
  field: String!
  direction: OrderDirection = ASC
}


input Filter {
  field: String
  value: String     # You can keep it String and parse to correct type in Go
  op: Op = eq  
  
  or: [Filter]
  and: [Filter]
}

type Query {
  time: Time
}

type Mutation {
  time: Time!
  uploadFile(file: Upload!): String!
}

type Subscription {
  time: String!
}
`, BuiltIn: false},
	{Name: "../schema/menu.graphql", Input: `type Menu {
  id: ID!
  path: String!
  label: String!
  key: String!
  icon: String
  description: String
  status: Boolean
  parentId: Uint
  children: [Menu!]
  orderNum: Uint
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateMenuInput {
  label: String
  key: String
  icon: String
  path: String
  parentId: Uint
  description: String
  status: Boolean
  orderNum: Uint
}

input NewMenuInput {
  label: String!
  key: String!
  path: String!
  icon: String
  parentId: Uint
  description: String
  status: Boolean
  orderNum: Uint
  openedAt: Time
}

type MenuList {
  menus: [Menu!]!
  total: Int!
}

extend type Query {
  getUserMenus: [Menu]!
  getMenus(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): MenuList! @hasRole(role: A)
}

extend type Mutation {
  createMenu(input: NewMenuInput!): Menu!
    @hasRole(role: A)
  updateMenu(id: ID!, input: UpdateMenuInput!): Menu!
    @hasRole(role: A)
  deleteMenu(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/notification.graphql", Input: `type Notification {
  id: ID!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  showFrom: Time!
  mainImage: String!
  imageUpload: String!
  noticeType: String!
  registerDate: Time!
  level: Uint
  domainId: Uint
  domain: Domain
  views: Uint
  showTo: Time!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateNotificationInput {
  title: String
  description: String
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
  level: Uint
  mainImage: String
  imageUpload: String
  noticeType: String
  registerDate: Time
  views: Uint
}

input NewNotificationInput {
  title: String!
  description: String!
  mainImage: String!
  imageUpload: String!
  noticeType: String!
  registerDate: Time!
  views: Uint
}

type NotificationList {
  notifications: [Notification!]!
  total: Int!
}

extend type Query {
  notifications: [Notification!]
  getNotifications(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): NotificationList! @hasRole(role: A)
}

extend type Mutation {
  createNotification(input: NewNotificationInput!): Notification!
    @hasRole(role: A)
  updateNotification(id: ID!, input: UpdateNotificationInput!): Notification!
    @hasRole(role: A)
  deleteNotification(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/qna.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Qna {
  id: ID!

  userId: Uint!
  user: User

  domainId: Uint
  domain: Domain
  
  type: String
  question: String
  questionTitle: String
  answer: String
  answerTitle: String

  status: String

  repliedAt: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewQnaInput {
  question: String!
  questionTitle: String!
  type: String
  status: String
}

input UpdateQnaInput {
  type: String
  question: String
  questionTitle: String
  answer: String
  answerTitle: String
  status: String
}

type QnaList {
  qnas: [Qna!]!
  total: Int!
}

extend type Query {
  getQnas(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): QnaList! @hasRole(role: A)
}

extend type Mutation {
  createQna(input: NewQnaInput!): Qna! @auth
  updateQna(id: ID!, input: UpdateQnaInput!): Qna! @auth
  replyQna(id: ID!, input: UpdateQnaInput!): Qna! @hasRole(role: A)
  deleteQna(id: ID!): Boolean! @hasRole(role: A)
  completeQna(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/setting.graphql", Input: `type Setting {
  id: ID!

  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID
  user: User

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time

  createdAt: Time
  updatedAt: Time
  deletedAt: DeletedAt
}

input UpdateSettingInput {
  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID 

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time
}

input NewSettingInput {
  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID 

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time
}
 

extend type Query {  
  getSetting: Setting! @hasRole(role: A)
}

extend type Mutation {
  createSetting(input: NewSettingInput!): Setting! @hasRole(role: A)
  updateSetting(id: ID!, input: UpdateSettingInput!): Setting! @hasRole(role: A)
  deleteSetting(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/sms_api.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type SMSApi {
  id: ID!
  name: String!
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewSMSApiInput {
  name: String!
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean
}

input UpdateSMSApiInput {
  name: String
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean
}

type SMSApiList {
  smsApis: [SMSApi!]!
  total: Int!
}

extend type Query {
  getSMSApis(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): SMSApiList! @hasRole(role: A)
}

extend type Mutation {
  createSMSApi(input: NewSMSApiInput!): SMSApi! @hasRole(role: A)
  updateSMSApi(id: ID!, input: UpdateSMSApiInput!): SMSApi! @hasRole(role: A)
  deleteSMSApi(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/todo.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

input NewTodo {
  text: String!
  userId: String!
}

extend type Query {
  todos: [Todo!]!
}

extend type Mutation {
  createTodo(input: NewTodo!): Todo!
}
`, BuiltIn: false},
	{Name: "../schema/transaction.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Transaction {
  id: ID!

  userId: ID!
  user: User

  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String

  transactionAt: Time
  approvedAt: Time

  createdAt: Time
  updatedAt: Time
  deletedAt: DeletedAt
}

input NewTransactionInput {
  userId: ID!
  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String
}

input UpdateTransactionInput {
  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String
}

type TransactionList {
  transactions: [Transaction!]!
  total: Int!
}

type WeeklyLosingData {
  weekStart: String!
  weekEnd: String!
  site: String!
  distributorID: String!
  distributorName: String!
  distributorLevel: Int!
  nickname: String!
  depositor: String!
  alias: String!
  totalBet: Float!
  totalWinner: Float!
  totalLosingMoney: Float!
  settlementAmount: Float!
  applicationDate: String!
  processingDate: String!
  situation: String!
  userCount: Int!
}

type WeeklyLosingDataList {
  weeklyLosingData: [WeeklyLosingData!]!
  total: Int!
}

extend type Query {
  getTransactions(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): TransactionList! @hasRole(role: A)
  
  getWeeklyLosingData(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): WeeklyLosingDataList! @hasRole(role: A)
}

extend type Mutation {
  createTransaction(input: NewTransactionInput!): Transaction! @hasRole(role: A)
  updateTransaction(id: ID!, input: UpdateTransactionInput!): Transaction! @hasRole(role: A)
  deleteTransaction(id: ID!): Boolean! @hasRole(role: A)
  approveTransaction(id: ID!): Boolean! @hasRole(role: A)
  blockTransaction(id: ID!): Boolean! @hasRole(role: A)
  waitingTransaction(id: ID!): Boolean! @hasRole(role: A)
  cancelTransaction(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `enum UserStatus {
  A # approved
  B # blocked
  D # deleted
  I # inactivated
  S # suspended
  P # pending
}

enum UserType {
  G # general
  T # test
  I # interest
  W # working
}

type User {
  id: ID!
  name: String!
  userid: String!
  type: UserType!
  role: String!
  usdtAddress: String!
  currentIP: String!
  IP: String!
  rootId: ID
  root: User
  parentId: ID
  parent: User
  children: [User]
  childrenCount: Uint
  profile: Profile
  status: UserStatus!
  blackMemo: Boolean!
  orderNum: Uint
  os: String
  device: String
  fingerPrint: String

  live: Float
  slot: Float
  hold: Float  

  entireLosing : Float
  liveLosingBeDang: Float
  slotLosingBeDang: Float
  holdLosingBeDang: Float

  losingMethod: String

  # Additional rolling fields for different game types
  miniDanpolRolling: Float
  miniCombinationRolling: Float
  sportsDanpolRolling: Float
  sportsDupolRolling: Float
  sports3PoleRolling: Float
  sports4PoleRolling: Float
  sports5PoleRolling: Float
  sportsDapolRolling: Float
  virtualGameRolling: Float
  lotusRolling: Float
  mgmRolling: Float
  touchRolling: Float

  # Financial statistics
  membershipDeposit: Float
  membershipWithdrawal: Float
  totalWithdrawal: Float
  numberOfMembers: Int
  rollingHoldings: Float

  # Betting/Winning statistics
  liveBetting: Float
  liveWinning: Float
  slotBetting: Float
  slotJackpot: Float
  miniDanpolBetting: Float
  miniDanpolWinner: Float
  miniCombinationBetting: Float
  miniCombinationWinnings: Float
  sportsDanpolBetting: Float
  sportsDanpolWinner: Float
  sportsDupolBetting: Float
  sportsDupolWinner: Float
  sports3poleBetting: Float
  sports3poleWinner: Float
  sports4poleBetting: Float
  sports4poleWinner: Float
  sports5poleBetting: Float
  sports5poleWinner: Float
  sportsDapolBetting: Float
  sportsDapolWinner: Float
  virtualGameBetting: Float
  virtualGameWinnings: Float
  lotusBetting: Float
  lotusLottery: Float
  mgmBetting: Float
  mgmWinning: Float
  touchBetting: Float
  touchWinning: Float
  holdemBetting: Float
  holdemWinning: Float

  # Rolling statistics
  rollingRate: Float
  rollingTransition: Float

  # Losing statistics
  losingRate: Float
  losingSettlement: Float

  # Partnership statistics
  partnershipRolling: Float
  partnershipMoneyInHand: Float

  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

type Profile {
  id: ID!
  userId: ID!
  name: String!
  nickname: String!
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  phoneVerified: Boolean!
  balance: Float!
  roll: Float!
  point: Int!
  comp: Int!
  level: Int!
  coupon: Int!
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
  lastDeposit: Time
  lastWithdraw: Time
  orderNum: Uint
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewProfile {
  userId: ID!
  name: String!
  nickname: String!
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  balance: Float
  roll: Float
  point: Int
  comp: Int
  level: Int
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
}

input UpdateProfile {
  userid: String
  name: String
  nickname: String
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  balance: Float
  roll: Float
  point: Int
  comp: Int
  level: Int
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
  currentPassword: String
  confirmPassword: String
  newPassword: String
}

input UpdateUser {
  name: String
  userid: String
  rootId: ID
  partentId: ID
  type: UserType
  role: String
  usdtAddress: String
  status: UserStatus
  orderNum: Uint
  
  live: Float
  slot: Float
  hold: Float
  entireLosing: Float
  liveLosingBeDang: Float
  slotLosingBeDang: Float
  holdLosingBeDang: Float
  losingMethod: String
}

input NewUser {
  name: String
  userid: String!
  type: UserType!
  role: String!
  password: String!
  usdtAddress: String
  currentIP: String
  IP: String
  rootId: ID
  parentId: ID
  childrenCount: Uint
  status: UserStatus!
  blackMemo: Boolean
  orderNum: Uint
  os: String
  device: String
  fingerPrint: String

  domainId: ID
  bankId: ID
  holderName: String
  nickname: String
  phone: String
  settlementId: ID
}

type UserList {
  users: [User!]!
  total: Int!
}

extend type Query {
  profile: Profile! @auth
  me: User! @auth

  users: [User!]! @hasRole(role: A)

  filterUsers(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  connectedUsers(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  user(id: ID!): User @hasRole(role: A)

  getDistributors(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  getDistributorDetails(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)
}

extend type Mutation {
  updateProfile(id: ID!, input: UpdateProfile!): Profile! @auth
  deleteProfile(id: ID!): Boolean! @auth
  createUser(input: NewUser): Boolean! @hasRole(role: A)
  approveUser(id: ID!): Boolean! @hasRole(role: A)
  blockUser(id: ID!): Boolean! @hasRole(role: A)
  updateUser(id: ID!, input: UpdateUser!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_hasRole_argsRole(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["role"] = arg0
	return args, nil
}
func (ec *executionContext) dir_hasRole_argsRole(
	ctx context.Context,
	rawArgs map[string]any,
) (model.Role, error) {
	if _, ok := rawArgs["role"]; !ok {
		var zeroVal model.Role
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
	if tmp, ok := rawArgs["role"]; ok {
		return ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, tmp)
	}

	var zeroVal model.Role
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_approveTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_approveTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_approveTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_approveUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_approveUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_approveUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_blockTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_blockTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_blockTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_blockUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_blockUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_blockUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_cancelTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_cancelTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_cancelTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_completeQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_completeQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_completeQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createAdminPermission_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createAdminPermission_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createAdminPermission_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewAdminPermission, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewAdminPermission2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewAdminPermission(ctx, tmp)
	}

	var zeroVal model.NewAdminPermission
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createAnnouncement_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createAnnouncement_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewAnnouncementInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewAnnouncementInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewAnnouncementInput(ctx, tmp)
	}

	var zeroVal model.NewAnnouncementInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createBank_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createBank_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewBankInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewBankInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewBankInput(ctx, tmp)
	}

	var zeroVal model.NewBankInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createDomain_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createDomain_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewDomainInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewDomainInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewDomainInput(ctx, tmp)
	}

	var zeroVal model.NewDomainInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewEventInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewEventInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewEventInput(ctx, tmp)
	}

	var zeroVal model.NewEventInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createGameApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createGameApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewGameAPIInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewGameApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewGameAPIInput(ctx, tmp)
	}

	var zeroVal model.NewGameAPIInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createInbox_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createInbox_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewInboxInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewInboxInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewInboxInput(ctx, tmp)
	}

	var zeroVal model.NewInboxInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createLog_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createLog_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewLogInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewLogInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewLogInput(ctx, tmp)
	}

	var zeroVal model.NewLogInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMenu_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMenu_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewMenuInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewMenuInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewMenuInput(ctx, tmp)
	}

	var zeroVal model.NewMenuInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createNotification_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createNotification_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewNotificationInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewNotificationInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewNotificationInput(ctx, tmp)
	}

	var zeroVal model.NewNotificationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewQnaInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewQnaInput(ctx, tmp)
	}

	var zeroVal model.NewQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createSMSApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createSMSApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewSMSApiInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewSMSApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewSMSApiInput(ctx, tmp)
	}

	var zeroVal model.NewSMSApiInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createSetting_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createSetting_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewSettingInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewSettingInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewSettingInput(ctx, tmp)
	}

	var zeroVal model.NewSettingInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTodo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTodo_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTodo_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewTodo, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewTodo2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewTodo(ctx, tmp)
	}

	var zeroVal model.NewTodo
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTransaction_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTransaction_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewTransactionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewTransactionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewTransactionInput(ctx, tmp)
	}

	var zeroVal model.NewTransactionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.NewUser, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalONewUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewUser(ctx, tmp)
	}

	var zeroVal *model.NewUser
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteAnnouncement_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteAnnouncement_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteBank_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteBank_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteDomain_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteDomain_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteEvent_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteEvent_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteGameApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteGameApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteInbox_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteInbox_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteLog_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteLog_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMenu_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMenu_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteNotification_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteNotification_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteProfile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteProfile_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteProfile_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSMSApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSMSApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSetting_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSetting_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_replyQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_replyQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_replyQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_replyQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_replyQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateQnaInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateQnaInput(ctx, tmp)
	}

	var zeroVal model.UpdateQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAdminPermission_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateAdminPermission_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateAdminPermission_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateAdminPermission_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAdminPermission_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateAdminPermissionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateAdminPermissionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateAdminPermissionInput(ctx, tmp)
	}

	var zeroVal model.UpdateAdminPermissionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateAnnouncement_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateAnnouncement_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateAnnouncement_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateAnnouncementInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateAnnouncementInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateAnnouncementInput(ctx, tmp)
	}

	var zeroVal model.UpdateAnnouncementInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateBank_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateBank_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateBank_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBank_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateBankInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateBankInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateBankInput(ctx, tmp)
	}

	var zeroVal model.UpdateBankInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateDomain_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateDomain_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateDomain_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateDomain_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateDomainInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateDomainInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateDomainInput(ctx, tmp)
	}

	var zeroVal model.UpdateDomainInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateEvent_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateEvent_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateEventInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateEventInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateEventInput(ctx, tmp)
	}

	var zeroVal model.UpdateEventInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateGameApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateGameApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateGameApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateGameApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateGameAPIInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateGameApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateGameAPIInput(ctx, tmp)
	}

	var zeroVal model.UpdateGameAPIInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateInbox_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateInbox_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateInbox_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateInbox_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateInboxInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateInboxInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateInboxInput(ctx, tmp)
	}

	var zeroVal model.UpdateInboxInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMenu_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateMenu_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMenu_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMenu_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateMenuInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateMenuInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateMenuInput(ctx, tmp)
	}

	var zeroVal model.UpdateMenuInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateNotification_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateNotification_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateNotification_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateNotification_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateNotificationInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateNotificationInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateNotificationInput(ctx, tmp)
	}

	var zeroVal model.UpdateNotificationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateProfile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateProfile_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateProfile_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateProfile_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateProfile_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateProfile, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateProfile2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateProfile(ctx, tmp)
	}

	var zeroVal model.UpdateProfile
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateQnaInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateQnaInput(ctx, tmp)
	}

	var zeroVal model.UpdateQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSMSApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateSMSApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSMSApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSMSApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateSMSApiInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateSMSApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateSMSApiInput(ctx, tmp)
	}

	var zeroVal model.UpdateSMSApiInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSetting_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateSetting_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSetting_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSetting_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateSettingInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateSettingInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateSettingInput(ctx, tmp)
	}

	var zeroVal model.UpdateSettingInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateTransaction_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTransaction_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTransactionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTransactionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateTransactionInput(ctx, tmp)
	}

	var zeroVal model.UpdateTransactionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateUser, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateUser(ctx, tmp)
	}

	var zeroVal model.UpdateUser
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_uploadFile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_uploadFile_argsFile(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["file"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_uploadFile_argsFile(
	ctx context.Context,
	rawArgs map[string]any,
) (graphql.Upload, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
	if tmp, ok := rawArgs["file"]; ok {
		return ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, tmp)
	}

	var zeroVal graphql.Upload
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_waitingTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_waitingTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_waitingTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminPermissions_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_adminPermissions_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_adminPermissions_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_adminPermissions_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_connectedUsers_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_connectedUsers_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_connectedUsers_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_connectedUsers_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_filterUsers_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_filterUsers_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_filterUsers_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_filterUsers_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getAnnouncements_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getAnnouncements_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getAnnouncements_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getAnnouncements_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getBanks_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getBanks_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getBanks_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getBanks_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDistributorDetails_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDistributorDetails_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDistributorDetails_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDistributorDetails_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDistributors_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDistributors_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDistributors_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDistributors_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDomains_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDomains_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDomains_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDomains_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getEvents_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getEvents_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getEvents_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getEvents_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getGameApis_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getGameApis_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getGameApis_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getGameApis_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getInboxes_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getInboxes_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getInboxes_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getInboxes_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getLogs_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getLogs_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getLogs_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getLogs_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMenus_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getMenus_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getMenus_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMenus_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getNotifications_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getNotifications_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getNotifications_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getNotifications_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getQnas_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getQnas_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getQnas_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getQnas_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getSMSApis_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getSMSApis_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getSMSApis_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getSMSApis_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getTransactions_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getTransactions_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getTransactions_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getTransactions_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getWeeklyLosingData_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getWeeklyLosingData_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getWeeklyLosingData_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getWeeklyLosingData_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_user_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdminPermission_id(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_userId(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_user(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_membership(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_membership(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Membership, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_membership(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_financials(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_financials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Financials, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_financials(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_qna(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_qna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qna, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_qna(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_game(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_game(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_game(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_settlement(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_settlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_settlement(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_sale(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_sale(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sale, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_sale(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_statistical(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_statistical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_statistical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_ip(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_ip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_dwdelete(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_dwdelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dwdelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_dwdelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_status(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermissionList_adminPermissions(ctx context.Context, field graphql.CollectedField, obj *model.AdminPermissionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermissionList_adminPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminPermissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermissionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermissionList_adminPermissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermissionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermissionList_total(ctx context.Context, field graphql.CollectedField, obj *model.AdminPermissionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermissionList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermissionList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermissionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_id(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_title(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_description(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_status(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_user(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_userId(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Announcement().ShowFrom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Announcement().ShowTo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AnnouncementList_announcements(ctx context.Context, field graphql.CollectedField, obj *model.AnnouncementList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AnnouncementList_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Announcements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AnnouncementList_announcements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AnnouncementList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AnnouncementList_total(ctx context.Context, field graphql.CollectedField, obj *model.AnnouncementList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AnnouncementList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AnnouncementList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AnnouncementList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_id(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_name(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_status(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankList_banks(ctx context.Context, field graphql.CollectedField, obj *model.BankList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankList_banks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Bank)
	fc.Result = res
	return ec.marshalNBank2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBankᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankList_banks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankList_total(ctx context.Context, field graphql.CollectedField, obj *model.BankList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_id(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_name(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_description(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_status(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_autoReg(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_autoReg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoReg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_autoReg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useTelegram(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useTelegram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseTelegram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useTelegram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_telegram(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_telegram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telegram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_telegram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_telegramLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_telegramLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TelegramLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_telegramLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useKakaoTalk(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useKakaoTalk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseKakaoTalk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useKakaoTalk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_kakaoTalk(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_kakaoTalk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KakaoTalk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_kakaoTalk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_kakaoTalkLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KakaoTalkLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_kakaoTalkLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useServiceCenter(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useServiceCenter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseServiceCenter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useServiceCenter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_serviceCenter(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_serviceCenter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceCenter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_serviceCenter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_serviceCenterLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_serviceCenterLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceCenterLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_serviceCenterLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useLiveDomain(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useLiveDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseLiveDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useLiveDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_liveDomain(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_liveDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_liveDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_liveDomainLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_liveDomainLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveDomainLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_liveDomainLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_memberLevel(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_memberLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_memberLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_distributorLevel(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_distributorLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_distributorLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_userId(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_user(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DomainList_domains(ctx context.Context, field graphql.CollectedField, obj *model.DomainList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DomainList_domains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domains, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomainᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DomainList_domains(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DomainList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DomainList_total(ctx context.Context, field graphql.CollectedField, obj *model.DomainList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DomainList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DomainList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DomainList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_title(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_description(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_status(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_user(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_userId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_domain(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalODomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_category(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_views(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_mainImage(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_mainImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_mainImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_imageUpload(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_imageUpload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUpload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_imageUpload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_level(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventList_events(ctx context.Context, field graphql.CollectedField, obj *model.EventList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventList_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventList_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventList_total(ctx context.Context, field graphql.CollectedField, obj *model.EventList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_id(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_apiCompanyName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APICompanyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_apiCompanyName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameApiName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameApiName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameAPIName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameApiName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameCompanyName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameCompanyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameCompanyName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameType(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_other(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_other(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Other, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_other(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_whetherToUse(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_whetherToUse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WhetherToUse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_whetherToUse(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_order(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int32)
	fc.Result = res
	return ec.marshalOInt2ᚖint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_type(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPIList_gameApis(ctx context.Context, field graphql.CollectedField, obj *model.GameAPIList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPIList_gameApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameApis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPIᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPIList_gameApis(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPIList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPIList_total(ctx context.Context, field graphql.CollectedField, obj *model.GameAPIList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPIList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPIList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPIList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_id(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_type(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_title(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_description(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_status(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_userId(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_user(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_fromId(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_fromId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_fromId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_FromUser(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_FromUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_FromUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_openedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_openedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_openedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboxList_inboxes(ctx context.Context, field graphql.CollectedField, obj *model.InboxList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboxList_inboxes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inboxes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInboxᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboxList_inboxes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboxList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboxList_total(ctx context.Context, field graphql.CollectedField, obj *model.InboxList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboxList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboxList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboxList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_id(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_data(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_path(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_phone(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_method(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_type(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_ip(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_ip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_userId(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_user(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_status(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_os(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_device(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_device(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Device, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_device(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_host(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Log().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogList_logs(ctx context.Context, field graphql.CollectedField, obj *model.LogList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogList_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Log)
	fc.Result = res
	return ec.marshalNLog2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogList_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogList_total(ctx context.Context, field graphql.CollectedField, obj *model.LogList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_id(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_path(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_label(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_key(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_icon(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Icon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_description(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_status(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_parentId(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_parentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_parentId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_children(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Menu)
	fc.Result = res
	return ec.marshalOMenu2ᚕgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenuᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_children(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MenuList_menus(ctx context.Context, field graphql.CollectedField, obj *model.MenuList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MenuList_menus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Menus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenuᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MenuList_menus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MenuList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MenuList_total(ctx context.Context, field graphql.CollectedField, obj *model.MenuList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MenuList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MenuList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MenuList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_time(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UploadFile(rctx, fc.Args["file"].(graphql.Upload))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadFile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAdminPermission(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAdminPermission(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAdminPermission(rctx, fc.Args["input"].(model.NewAdminPermission))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.AdminPermission
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.AdminPermission
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.AdminPermission); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.AdminPermission`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermission(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAdminPermission(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAdminPermission_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAdminPermission(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAdminPermission(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAdminPermission(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateAdminPermissionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.AdminPermission
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.AdminPermission
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.AdminPermission); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.AdminPermission`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermission(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAdminPermission(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAdminPermission_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAnnouncement(rctx, fc.Args["input"].(model.NewAnnouncementInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Announcement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Announcement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAnnouncement(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateAnnouncementInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Announcement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Announcement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAnnouncement(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBank(rctx, fc.Args["input"].(model.NewBankInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Bank
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Bank
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Bank); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Bank`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Bank)
	fc.Result = res
	return ec.marshalNBank2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBank(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBank(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateBankInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Bank
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Bank
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Bank); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Bank`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Bank)
	fc.Result = res
	return ec.marshalNBank2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBank(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBank(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDomain(rctx, fc.Args["input"].(model.NewDomainInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Domain
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Domain
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Domain); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Domain`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDomain(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateDomainInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Domain
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Domain
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Domain); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Domain`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDomain(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(model.NewEventInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Event
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Event
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateEventInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Event
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Event
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateGameAPI(rctx, fc.Args["input"].(model.NewGameAPIInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPI
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPI
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPI); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPI`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPI(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGameAPI(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateGameAPIInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPI
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPI
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPI); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPI`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPI(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGameAPI(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateInbox(rctx, fc.Args["input"].(model.NewInboxInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Inbox
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Inbox
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Inbox); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Inbox`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInbox(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateInbox(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateInboxInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Inbox
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Inbox
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Inbox); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Inbox`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInbox(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteInbox(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateLog(rctx, fc.Args["input"].(model.NewLogInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Log
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Log
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Log); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Log`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Log)
	fc.Result = res
	return ec.marshalNLog2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLog(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteLog(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMenu(rctx, fc.Args["input"].(model.NewMenuInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Menu
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Menu
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Menu); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Menu`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMenu(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateMenuInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Menu
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Menu
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Menu); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Menu`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMenu(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateNotification(rctx, fc.Args["input"].(model.NewNotificationInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Notification
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Notification
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Notification); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Notification`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateNotification(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateNotificationInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Notification
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Notification
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Notification); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Notification`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteNotification(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateQna(rctx, fc.Args["input"].(model.NewQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateQna(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_replyQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_replyQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReplyQna(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Qna
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_replyQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_replyQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteQna(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_completeQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_completeQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CompleteQna(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_completeQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_completeQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSetting(rctx, fc.Args["input"].(model.NewSettingInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSetting(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateSettingInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSetting(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSMSApi(rctx, fc.Args["input"].(model.NewSMSApiInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.SMSApi
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.SMSApi
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.SMSApi); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.SMSApi`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApi(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSMSApi(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateSMSApiInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.SMSApi
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.SMSApi
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.SMSApi); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.SMSApi`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApi(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSMSApi(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTodo(rctx, fc.Args["input"].(model.NewTodo))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Todo)
	fc.Result = res
	return ec.marshalNTodo2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTodo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTransaction(rctx, fc.Args["input"].(model.NewTransactionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Transaction
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Transaction
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Transaction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Transaction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTransaction(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateTransactionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Transaction
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Transaction
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Transaction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Transaction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_blockTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_blockTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BlockTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_blockTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_blockTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_waitingTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_waitingTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WaitingTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_waitingTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_waitingTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateProfile(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateProfile))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Profile
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Profile); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Profile`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Profile)
	fc.Result = res
	return ec.marshalNProfile2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteProfile(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(*model.NewUser))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveUser(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_blockUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_blockUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BlockUser(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_blockUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_blockUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateUser))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Notification_id(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_title(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_description(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_status(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().ShowFrom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_mainImage(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_mainImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_mainImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_imageUpload(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_imageUpload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUpload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_imageUpload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_noticeType(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_noticeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoticeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_noticeType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_registerDate(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_registerDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegisterDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_registerDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_level(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_domain(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalODomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_views(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().ShowTo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationList_notifications(ctx context.Context, field graphql.CollectedField, obj *model.NotificationList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationList_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotificationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationList_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationList_total(ctx context.Context, field graphql.CollectedField, obj *model.NotificationList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_id(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_userId(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_name(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_nickname(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_nickname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_bankName(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_bankName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_bankName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_holderName(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_holderName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HolderName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_holderName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_accountNumber(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_accountNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_accountNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_birthday(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_birthday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Birthday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_birthday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_phone(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_mobile(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_mobile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mobile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_mobile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_phoneVerified(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_phoneVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhoneVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_phoneVerified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_balance(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_roll(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_roll(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roll, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_roll(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_point(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_point(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Point, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_point(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_comp(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_comp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_comp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_level(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_coupon(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_coupon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coupon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_coupon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_favorites(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_favorites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Favorites, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_favorites(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_referral(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_referral(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Referral, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_referral(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_avatarUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_bio(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_bio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_socialLinks(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_socialLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_socialLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_lastDeposit(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_lastDeposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDeposit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_lastDeposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_lastWithdraw(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_lastWithdraw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastWithdraw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_lastWithdraw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_id(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_userId(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_user(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_domain(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Domain)
	fc.Result = res
	return ec.marshalODomain2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_type(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_question(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_question(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Question, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_question(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_questionTitle(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_questionTitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuestionTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_questionTitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_answer(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_answer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Answer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_answer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_answerTitle(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_answerTitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnswerTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_answerTitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_status(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_repliedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_repliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_repliedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QnaList_qnas(ctx context.Context, field graphql.CollectedField, obj *model.QnaList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QnaList_qnas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qnas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Qna)
	fc.Result = res
	return ec.marshalNQna2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQnaᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QnaList_qnas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QnaList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QnaList_total(ctx context.Context, field graphql.CollectedField, obj *model.QnaList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QnaList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QnaList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QnaList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_time(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminPermissions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminPermissions(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminPermissionList)
	fc.Result = res
	return ec.marshalNAdminPermissionList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAdminPermissionList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminPermissions":
				return ec.fieldContext_AdminPermissionList_adminPermissions(ctx, field)
			case "total":
				return ec.fieldContext_AdminPermissionList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermissionList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_announcements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Announcements(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_announcements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAnnouncements(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.AnnouncementList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.AnnouncementList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.AnnouncementList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.AnnouncementList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AnnouncementList)
	fc.Result = res
	return ec.marshalNAnnouncementList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAnnouncementList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "announcements":
				return ec.fieldContext_AnnouncementList_announcements(ctx, field)
			case "total":
				return ec.fieldContext_AnnouncementList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AnnouncementList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncements_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBanks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBanks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBanks(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.BankList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.BankList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BankList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.BankList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BankList)
	fc.Result = res
	return ec.marshalNBankList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐBankList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBanks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banks":
				return ec.fieldContext_BankList_banks(ctx, field)
			case "total":
				return ec.fieldContext_BankList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BankList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBanks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_domains(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_domains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Domains(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Domain)
	fc.Result = res
	return ec.marshalODomain2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomainᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_domains(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDomains(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDomains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDomains(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.DomainList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.DomainList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DomainList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.DomainList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DomainList)
	fc.Result = res
	return ec.marshalNDomainList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐDomainList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDomains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "domains":
				return ec.fieldContext_DomainList_domains(ctx, field)
			case "total":
				return ec.fieldContext_DomainList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DomainList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDomains_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_topEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_topEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TopEvents(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_topEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEvents(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.EventList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.EventList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.EventList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.EventList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventList)
	fc.Result = res
	return ec.marshalNEventList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐEventList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_EventList_events(ctx, field)
			case "total":
				return ec.fieldContext_EventList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGameApis(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGameApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGameApis(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPIList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPIList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPIList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPIList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPIList)
	fc.Result = res
	return ec.marshalNGameAPIList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPIList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGameApis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gameApis":
				return ec.fieldContext_GameAPIList_gameApis(ctx, field)
			case "total":
				return ec.fieldContext_GameAPIList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPIList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGameApis_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInboxes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInboxes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInboxes(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.InboxList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.InboxList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InboxList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.InboxList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InboxList)
	fc.Result = res
	return ec.marshalNInboxList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐInboxList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInboxes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inboxes":
				return ec.fieldContext_InboxList_inboxes(ctx, field)
			case "total":
				return ec.fieldContext_InboxList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InboxList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInboxes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_logs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Logs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Log)
	fc.Result = res
	return ec.marshalOLog2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetLogs(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.LogList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.LogList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.LogList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.LogList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LogList)
	fc.Result = res
	return ec.marshalNLogList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐLogList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "logs":
				return ec.fieldContext_LogList_logs(ctx, field)
			case "total":
				return ec.fieldContext_LogList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUserMenus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUserMenus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUserMenus(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUserMenus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMenus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMenus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMenus(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.MenuList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MenuList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MenuList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.MenuList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MenuList)
	fc.Result = res
	return ec.marshalNMenuList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐMenuList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMenus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "menus":
				return ec.fieldContext_MenuList_menus(ctx, field)
			case "total":
				return ec.fieldContext_MenuList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MenuList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMenus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_notifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Notifications(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Notification)
	fc.Result = res
	return ec.marshalONotification2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotificationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetNotifications(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.NotificationList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.NotificationList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.NotificationList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.NotificationList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NotificationList)
	fc.Result = res
	return ec.marshalNNotificationList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNotificationList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "notifications":
				return ec.fieldContext_NotificationList_notifications(ctx, field)
			case "total":
				return ec.fieldContext_NotificationList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getNotifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getQnas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getQnas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetQnas(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.QnaList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.QnaList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.QnaList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.QnaList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.QnaList)
	fc.Result = res
	return ec.marshalNQnaList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐQnaList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getQnas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "qnas":
				return ec.fieldContext_QnaList_qnas(ctx, field)
			case "total":
				return ec.fieldContext_QnaList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QnaList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getQnas_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetSetting(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMSApis(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMSApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetSMSApis(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.SMSApiList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.SMSApiList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SMSApiList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.SMSApiList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SMSApiList)
	fc.Result = res
	return ec.marshalNSMSApiList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSMSApiList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMSApis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "smsApis":
				return ec.fieldContext_SMSApiList_smsApis(ctx, field)
			case "total":
				return ec.fieldContext_SMSApiList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApiList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMSApis_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_todos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_todos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Todos(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Todo)
	fc.Result = res
	return ec.marshalNTodo2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_todos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTransactions(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.TransactionList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.TransactionList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TransactionList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.TransactionList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TransactionList)
	fc.Result = res
	return ec.marshalNTransactionList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTransactionList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "transactions":
				return ec.fieldContext_TransactionList_transactions(ctx, field)
			case "total":
				return ec.fieldContext_TransactionList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getWeeklyLosingData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getWeeklyLosingData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWeeklyLosingData(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.WeeklyLosingDataList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.WeeklyLosingDataList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WeeklyLosingDataList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.WeeklyLosingDataList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WeeklyLosingDataList)
	fc.Result = res
	return ec.marshalNWeeklyLosingDataList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingDataList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getWeeklyLosingData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "weeklyLosingData":
				return ec.fieldContext_WeeklyLosingDataList_weeklyLosingData(ctx, field)
			case "total":
				return ec.fieldContext_WeeklyLosingDataList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeeklyLosingDataList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getWeeklyLosingData_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_profile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Profile(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Profile
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Profile); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Profile`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Profile)
	fc.Result = res
	return ec.marshalNProfile2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_profile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Me(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.User
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Users(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal []*models.User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*models.User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_filterUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_filterUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FilterUsers(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_filterUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_filterUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectedUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ConnectedUsers(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectedUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().User(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *models.User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDistributors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDistributors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDistributors(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDistributors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDistributors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDistributorDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDistributorDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDistributorDetails(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDistributorDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDistributorDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_id(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_name(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_url(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_agent(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_agent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_agent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_password(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_password(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_token(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_status(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApiList_smsApis(ctx context.Context, field graphql.CollectedField, obj *model.SMSApiList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApiList_smsApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SmsApis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApiᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApiList_smsApis(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApiList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApiList_total(ctx context.Context, field graphql.CollectedField, obj *model.SMSApiList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApiList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApiList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApiList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_id(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_status(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_title(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_description(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_primaryDomain(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_primaryDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_primaryDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userId(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_user(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_orderNum(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_time(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_time(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan string):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNString2string(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_id(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_text(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_done(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Done, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_done(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_user(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_userId(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_user(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_type(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_amount(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_balanceBefore(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_balanceBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_balanceBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_balanceAfter(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_balanceAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_balanceAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pointBefore(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pointBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pointBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pointAfter(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pointAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pointAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_status(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_shortcut(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_shortcut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shortcut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_shortcut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_usdtDesc(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_usdtDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.USDTDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_usdtDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_approvedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_approvedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_approvedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionList_transactions(ctx context.Context, field graphql.CollectedField, obj *model.TransactionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionList_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionList_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionList_total(ctx context.Context, field graphql.CollectedField, obj *model.TransactionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userid(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Userid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_type(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserType)
	fc.Result = res
	return ec.marshalNUserType2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_usdtAddress(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_usdtAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.USDTAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_usdtAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_currentIP(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_currentIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_currentIP(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_IP(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_IP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_IP(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rootId(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rootId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rootId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_root(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_root(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Root, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_root(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parentId(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parentId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parent(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_children(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.User)
	fc.Result = res
	return ec.marshalOUser2ᚕgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_children(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_childrenCount(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_childrenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildrenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_childrenCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_profile(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Profile)
	fc.Result = res
	return ec.marshalOProfile2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_profile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_status(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserStatus)
	fc.Result = res
	return ec.marshalNUserStatus2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_blackMemo(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_blackMemo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlackMemo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_blackMemo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_os(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_device(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_device(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Device, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_device(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_fingerPrint(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_fingerPrint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FingerPrint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_fingerPrint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_live(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_live(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Live, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_live(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slot(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_hold(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_hold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_hold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_entireLosing(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_entireLosing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntireLosing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_entireLosing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingMethod(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_membershipDeposit(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_membershipDeposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MembershipDeposit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_membershipDeposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_membershipWithdrawal(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_membershipWithdrawal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MembershipWithdrawal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_membershipWithdrawal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_totalWithdrawal(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_totalWithdrawal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWithdrawal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_totalWithdrawal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_numberOfMembers(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_numberOfMembers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().NumberOfMembers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int32)
	fc.Result = res
	return ec.marshalOInt2ᚖint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_numberOfMembers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingHoldings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingHoldings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingHoldings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingHoldings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotJackpot(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotJackpot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotJackpot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotJackpot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationWinnings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationWinnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationWinnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationWinnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameWinnings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameWinnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameWinnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameWinnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusLottery(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusLottery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusLottery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusLottery(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdemBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdemBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldemBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdemBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdemWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdemWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldemWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdemWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingRate(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingTransition(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingTransition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingTransition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingTransition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingRate(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingSettlement(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingSettlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingSettlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingSettlement(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_partnershipRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_partnershipRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartnershipRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_partnershipRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_partnershipMoneyInHand(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartnershipMoneyInHand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_partnershipMoneyInHand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserList_users(ctx context.Context, field graphql.CollectedField, obj *model.UserList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserList_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserList_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserList_total(ctx context.Context, field graphql.CollectedField, obj *model.UserList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_weekStart(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_weekStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeekStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_weekStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_weekEnd(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_weekEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeekEnd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_weekEnd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_site(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_site(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Site, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_site(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorID(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorName(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorLevel(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_nickname(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_nickname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_depositor(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_depositor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Depositor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_depositor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_alias(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalBet(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalBet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalBet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalWinner(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalLosingMoney(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalLosingMoney(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalLosingMoney, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalLosingMoney(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_settlementAmount(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_settlementAmount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SettlementAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_settlementAmount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_applicationDate(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_applicationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_applicationDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_processingDate(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_processingDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessingDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_processingDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_situation(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_situation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Situation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_situation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_userCount(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_userCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_userCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingDataList_weeklyLosingData(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingDataList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingDataList_weeklyLosingData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeeklyLosingData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WeeklyLosingData)
	fc.Result = res
	return ec.marshalNWeeklyLosingData2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingDataList_weeklyLosingData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingDataList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "weekStart":
				return ec.fieldContext_WeeklyLosingData_weekStart(ctx, field)
			case "weekEnd":
				return ec.fieldContext_WeeklyLosingData_weekEnd(ctx, field)
			case "site":
				return ec.fieldContext_WeeklyLosingData_site(ctx, field)
			case "distributorID":
				return ec.fieldContext_WeeklyLosingData_distributorID(ctx, field)
			case "distributorName":
				return ec.fieldContext_WeeklyLosingData_distributorName(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_WeeklyLosingData_distributorLevel(ctx, field)
			case "nickname":
				return ec.fieldContext_WeeklyLosingData_nickname(ctx, field)
			case "depositor":
				return ec.fieldContext_WeeklyLosingData_depositor(ctx, field)
			case "alias":
				return ec.fieldContext_WeeklyLosingData_alias(ctx, field)
			case "totalBet":
				return ec.fieldContext_WeeklyLosingData_totalBet(ctx, field)
			case "totalWinner":
				return ec.fieldContext_WeeklyLosingData_totalWinner(ctx, field)
			case "totalLosingMoney":
				return ec.fieldContext_WeeklyLosingData_totalLosingMoney(ctx, field)
			case "settlementAmount":
				return ec.fieldContext_WeeklyLosingData_settlementAmount(ctx, field)
			case "applicationDate":
				return ec.fieldContext_WeeklyLosingData_applicationDate(ctx, field)
			case "processingDate":
				return ec.fieldContext_WeeklyLosingData_processingDate(ctx, field)
			case "situation":
				return ec.fieldContext_WeeklyLosingData_situation(ctx, field)
			case "userCount":
				return ec.fieldContext_WeeklyLosingData_userCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeeklyLosingData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingDataList_total(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingDataList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingDataList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingDataList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingDataList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputFilter(ctx context.Context, obj any) (model.Filter, error) {
	var it model.Filter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["op"]; !present {
		asMap["op"] = "eq"
	}

	fieldsInOrder := [...]string{"field", "value", "op", "or", "and"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "op":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("op"))
			data, err := ec.unmarshalOOp2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOp(ctx, v)
			if err != nil {
				return it, err
			}
			it.Op = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAdminPermission(ctx context.Context, obj any) (model.NewAdminPermission, error) {
	var it model.NewAdminPermission
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "membership", "financials", "qna", "game", "settlement", "sale", "status", "statistical", "ip", "dwdelete"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "membership":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("membership"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Membership = data
		case "financials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financials"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Financials = data
		case "qna":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qna"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Qna = data
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "settlement":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlement"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Settlement = data
		case "sale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sale"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sale = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "statistical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statistical"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statistical = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "dwdelete":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dwdelete"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dwdelete = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAnnouncementInput(ctx context.Context, obj any) (model.NewAnnouncementInput, error) {
	var it model.NewAnnouncementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewBankInput(ctx context.Context, obj any) (model.NewBankInput, error) {
	var it model.NewBankInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewDomainInput(ctx context.Context, obj any) (model.NewDomainInput, error) {
	var it model.NewDomainInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "status", "userId", "autoReg", "orderNum", "useTelegram", "telegram", "telegramLink", "useKakaoTalk", "kakaoTalk", "kakaoTalkLink", "useServiceCenter", "serviceCenter", "serviceCenterLink", "useLiveDomain", "liveDomain", "liveDomainLink", "memberLevel", "distributorLevel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "autoReg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoReg"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoReg = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "useTelegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTelegram"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTelegram = data
		case "telegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegram"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Telegram = data
		case "telegramLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegramLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TelegramLink = data
		case "useKakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useKakaoTalk"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseKakaoTalk = data
		case "kakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalk"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalk = data
		case "kakaoTalkLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalkLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalkLink = data
		case "useServiceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useServiceCenter"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceCenter = data
		case "serviceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenter"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenter = data
		case "serviceCenterLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenterLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenterLink = data
		case "useLiveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useLiveDomain"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseLiveDomain = data
		case "liveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomain"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomain = data
		case "liveDomainLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomainLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomainLink = data
		case "memberLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberLevel"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemberLevel = data
		case "distributorLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distributorLevel"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistributorLevel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewEventInput(ctx context.Context, obj any) (model.NewEventInput, error) {
	var it model.NewEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "author", "category", "views", "createdDate", "showFrom", "showTo", "description", "mainImage", "imageUpload"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "author":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("author"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Author = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		case "createdDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedDate = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewGameApiInput(ctx context.Context, obj any) (model.NewGameAPIInput, error) {
	var it model.NewGameAPIInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiCompanyName", "gameApiName", "gameCompanyName", "gameType", "other", "whetherToUse", "order", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiCompanyName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APICompanyName = data
		case "gameApiName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameApiName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameAPIName = data
		case "gameCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameCompanyName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameCompanyName = data
		case "gameType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameType = data
		case "other":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("other"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Other = data
		case "whetherToUse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whetherToUse"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WhetherToUse = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewInboxInput(ctx context.Context, obj any) (model.NewInboxInput, error) {
	var it model.NewInboxInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "title", "description", "status", "userId", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewLogInput(ctx context.Context, obj any) (model.NewLogInput, error) {
	var it model.NewLogInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "path", "method", "ip", "type", "phone", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewMenuInput(ctx context.Context, obj any) (model.NewMenuInput, error) {
	var it model.NewMenuInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"label", "key", "path", "icon", "parentId", "description", "status", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewNotificationInput(ctx context.Context, obj any) (model.NewNotificationInput, error) {
	var it model.NewNotificationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "mainImage", "imageUpload", "noticeType", "registerDate", "views"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		case "noticeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noticeType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoticeType = data
		case "registerDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registerDate"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegisterDate = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewProfile(ctx context.Context, obj any) (model.NewProfile, error) {
	var it model.NewProfile
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "name", "nickname", "bankName", "holderName", "accountNumber", "birthday", "phone", "mobile", "balance", "roll", "point", "comp", "level", "favorites", "referral", "avatarUrl", "bio", "socialLinks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "bankName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankName = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "accountNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountNumber"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountNumber = data
		case "birthday":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthday"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthday = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "mobile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Balance = data
		case "roll":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roll"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roll = data
		case "point":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("point"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Point = data
		case "comp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comp"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comp = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "favorites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorites"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorites = data
		case "referral":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referral"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Referral = data
		case "avatarUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "socialLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialLinks"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SocialLinks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewQnaInput(ctx context.Context, obj any) (model.NewQnaInput, error) {
	var it model.NewQnaInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"question", "questionTitle", "type", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "question":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("question"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Question = data
		case "questionTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questionTitle"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestionTitle = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSMSApiInput(ctx context.Context, obj any) (model.NewSMSApiInput, error) {
	var it model.NewSMSApiInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "url", "agent", "password", "token", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "agent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agent"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Agent = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSettingInput(ctx context.Context, obj any) (model.NewSettingInput, error) {
	var it model.NewSettingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"status", "title", "description", "primaryDomain", "userId", "orderNum", "totalExStatus", "totalExFrom", "totalExTo", "totalReStatus", "totalReFrom", "totalReTo", "userExStatus", "userExFrom", "userExTo", "userReStatus", "userReFrom", "userReTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "primaryDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("primaryDomain"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryDomain = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "totalExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExStatus = data
		case "totalExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExFrom = data
		case "totalExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExTo = data
		case "totalReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReStatus = data
		case "totalReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReFrom = data
		case "totalReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReTo = data
		case "userExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExStatus = data
		case "userExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExFrom = data
		case "userExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExTo = data
		case "userReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReStatus = data
		case "userReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReFrom = data
		case "userReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTodo(ctx context.Context, obj any) (model.NewTodo, error) {
	var it model.NewTodo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTransactionInput(ctx context.Context, obj any) (model.NewTransactionInput, error) {
	var it model.NewTransactionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "type", "amount", "balanceBefore", "balanceAfter", "pointBefore", "pointAfter", "status", "shortcut", "usdtDesc"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "balanceBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceBefore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceBefore = data
		case "balanceAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAfter"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceAfter = data
		case "pointBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointBefore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointBefore = data
		case "pointAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointAfter"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointAfter = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "shortcut":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortcut"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Shortcut = data
		case "usdtDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtDesc"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtDesc = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUser(ctx context.Context, obj any) (model.NewUser, error) {
	var it model.NewUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userid", "type", "role", "password", "usdtAddress", "currentIP", "IP", "rootId", "parentId", "childrenCount", "status", "blackMemo", "orderNum", "os", "device", "fingerPrint", "domainId", "bankId", "holderName", "nickname", "phone", "settlementId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNUserType2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "usdtAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtAddress"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtAddress = data
		case "currentIP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentIP"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrentIP = data
		case "IP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("IP"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "rootId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootID = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "childrenCount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childrenCount"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildrenCount = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNUserStatus2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "blackMemo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blackMemo"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlackMemo = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "os":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("os"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Os = data
		case "device":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("device"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Device = data
		case "fingerPrint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerPrint"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FingerPrint = data
		case "domainId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domainId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DomainID = data
		case "bankId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankID = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "settlementId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlementId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettlementID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrder(ctx context.Context, obj any) (model.Order, error) {
	var it model.Order
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOOrderDirection2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj any) (model.Pagination, error) {
	var it model.Pagination
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 10
	}
	if _, present := asMap["offset"]; !present {
		asMap["offset"] = 0
	}

	fieldsInOrder := [...]string{"limit", "offset"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAdminPermissionInput(ctx context.Context, obj any) (model.UpdateAdminPermissionInput, error) {
	var it model.UpdateAdminPermissionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"membership", "financials", "qna", "game", "settlement", "sale", "statistical", "status", "ip", "dwdelete"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "membership":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("membership"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Membership = data
		case "financials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financials"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Financials = data
		case "qna":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qna"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Qna = data
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "settlement":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlement"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Settlement = data
		case "sale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sale"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sale = data
		case "statistical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statistical"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statistical = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "dwdelete":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dwdelete"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dwdelete = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAnnouncementInput(ctx context.Context, obj any) (model.UpdateAnnouncementInput, error) {
	var it model.UpdateAnnouncementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo", "level"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBankInput(ctx context.Context, obj any) (model.UpdateBankInput, error) {
	var it model.UpdateBankInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDomainInput(ctx context.Context, obj any) (model.UpdateDomainInput, error) {
	var it model.UpdateDomainInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "status", "userId", "autoReg", "orderNum", "useTelegram", "telegram", "telegramLink", "useKakaoTalk", "kakaoTalk", "kakaoTalkLink", "useServiceCenter", "serviceCenter", "serviceCenterLink", "useLiveDomain", "liveDomain", "liveDomainLink", "memberLevel", "distributorLevel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "autoReg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoReg"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoReg = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "useTelegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTelegram"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTelegram = data
		case "telegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegram"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Telegram = data
		case "telegramLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegramLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TelegramLink = data
		case "useKakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useKakaoTalk"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseKakaoTalk = data
		case "kakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalk"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalk = data
		case "kakaoTalkLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalkLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalkLink = data
		case "useServiceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useServiceCenter"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceCenter = data
		case "serviceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenter"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenter = data
		case "serviceCenterLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenterLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenterLink = data
		case "useLiveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useLiveDomain"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseLiveDomain = data
		case "liveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomain"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomain = data
		case "liveDomainLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomainLink"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomainLink = data
		case "memberLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberLevel"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemberLevel = data
		case "distributorLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distributorLevel"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistributorLevel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj any) (model.UpdateEventInput, error) {
	var it model.UpdateEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "type", "description", "status", "orderNum", "domainId", "showFrom", "showTo", "level", "author", "category", "views", "createdDate", "mainImage", "imageUpload"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "domainId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domainId"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DomainID = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "author":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("author"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Author = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		case "createdDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedDate = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGameApiInput(ctx context.Context, obj any) (model.UpdateGameAPIInput, error) {
	var it model.UpdateGameAPIInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiCompanyName", "gameApiName", "gameCompanyName", "gameType", "other", "whetherToUse", "order", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiCompanyName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.APICompanyName = data
		case "gameApiName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameApiName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameAPIName = data
		case "gameCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameCompanyName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameCompanyName = data
		case "gameType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameType = data
		case "other":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("other"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Other = data
		case "whetherToUse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whetherToUse"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WhetherToUse = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateInboxInput(ctx context.Context, obj any) (model.UpdateInboxInput, error) {
	var it model.UpdateInboxInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "title", "description", "status", "userId", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMenuInput(ctx context.Context, obj any) (model.UpdateMenuInput, error) {
	var it model.UpdateMenuInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"label", "key", "icon", "path", "parentId", "description", "status", "orderNum"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateNotificationInput(ctx context.Context, obj any) (model.UpdateNotificationInput, error) {
	var it model.UpdateNotificationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo", "level", "mainImage", "imageUpload", "noticeType", "registerDate", "views"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		case "noticeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noticeType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoticeType = data
		case "registerDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registerDate"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegisterDate = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProfile(ctx context.Context, obj any) (model.UpdateProfile, error) {
	var it model.UpdateProfile
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userid", "name", "nickname", "bankName", "holderName", "accountNumber", "birthday", "phone", "mobile", "balance", "roll", "point", "comp", "level", "favorites", "referral", "avatarUrl", "bio", "socialLinks", "currentPassword", "confirmPassword", "newPassword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "bankName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankName = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "accountNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountNumber"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountNumber = data
		case "birthday":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthday"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthday = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "mobile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Balance = data
		case "roll":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roll"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roll = data
		case "point":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("point"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Point = data
		case "comp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comp"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comp = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "favorites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorites"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorites = data
		case "referral":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referral"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Referral = data
		case "avatarUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "socialLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialLinks"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SocialLinks = data
		case "currentPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrentPassword = data
		case "confirmPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirmPassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfirmPassword = data
		case "newPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewPassword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateQnaInput(ctx context.Context, obj any) (model.UpdateQnaInput, error) {
	var it model.UpdateQnaInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "question", "questionTitle", "answer", "answerTitle", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "question":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("question"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Question = data
		case "questionTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questionTitle"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestionTitle = data
		case "answer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("answer"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Answer = data
		case "answerTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("answerTitle"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AnswerTitle = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSMSApiInput(ctx context.Context, obj any) (model.UpdateSMSApiInput, error) {
	var it model.UpdateSMSApiInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "url", "agent", "password", "token", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "agent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agent"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Agent = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSettingInput(ctx context.Context, obj any) (model.UpdateSettingInput, error) {
	var it model.UpdateSettingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"status", "title", "description", "primaryDomain", "userId", "orderNum", "totalExStatus", "totalExFrom", "totalExTo", "totalReStatus", "totalReFrom", "totalReTo", "userExStatus", "userExFrom", "userExTo", "userReStatus", "userReFrom", "userReTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "primaryDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("primaryDomain"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryDomain = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "totalExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExStatus = data
		case "totalExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExFrom = data
		case "totalExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExTo = data
		case "totalReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReStatus = data
		case "totalReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReFrom = data
		case "totalReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReTo = data
		case "userExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExStatus = data
		case "userExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExFrom = data
		case "userExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExTo = data
		case "userReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReStatus"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReStatus = data
		case "userReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReFrom"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReFrom = data
		case "userReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReTo"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTransactionInput(ctx context.Context, obj any) (model.UpdateTransactionInput, error) {
	var it model.UpdateTransactionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "amount", "balanceBefore", "balanceAfter", "pointBefore", "pointAfter", "status", "shortcut", "usdtDesc"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "balanceBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceBefore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceBefore = data
		case "balanceAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAfter"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceAfter = data
		case "pointBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointBefore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointBefore = data
		case "pointAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointAfter"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointAfter = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "shortcut":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortcut"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Shortcut = data
		case "usdtDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtDesc"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtDesc = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUser(ctx context.Context, obj any) (model.UpdateUser, error) {
	var it model.UpdateUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userid", "rootId", "partentId", "type", "role", "usdtAddress", "status", "orderNum", "live", "slot", "hold", "entireLosing", "liveLosingBeDang", "slotLosingBeDang", "holdLosingBeDang", "losingMethod"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "rootId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootID = data
		case "partentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("partentId"))
			data, err := ec.unmarshalOID2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartentID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOUserType2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "usdtAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtAddress"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtAddress = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOUserStatus2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2ᚖuint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "live":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("live"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Live = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "hold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hold"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hold = data
		case "entireLosing":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entireLosing"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntireLosing = data
		case "liveLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveLosingBeDang"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveLosingBeDang = data
		case "slotLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slotLosingBeDang"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlotLosingBeDang = data
		case "holdLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holdLosingBeDang"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.HoldLosingBeDang = data
		case "losingMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("losingMethod"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LosingMethod = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adminPermissionImplementors = []string{"AdminPermission"}

func (ec *executionContext) _AdminPermission(ctx context.Context, sel ast.SelectionSet, obj *models.AdminPermission) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminPermissionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminPermission")
		case "id":
			out.Values[i] = ec._AdminPermission_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._AdminPermission_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AdminPermission_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "membership":
			out.Values[i] = ec._AdminPermission_membership(ctx, field, obj)
		case "financials":
			out.Values[i] = ec._AdminPermission_financials(ctx, field, obj)
		case "qna":
			out.Values[i] = ec._AdminPermission_qna(ctx, field, obj)
		case "game":
			out.Values[i] = ec._AdminPermission_game(ctx, field, obj)
		case "settlement":
			out.Values[i] = ec._AdminPermission_settlement(ctx, field, obj)
		case "sale":
			out.Values[i] = ec._AdminPermission_sale(ctx, field, obj)
		case "statistical":
			out.Values[i] = ec._AdminPermission_statistical(ctx, field, obj)
		case "ip":
			out.Values[i] = ec._AdminPermission_ip(ctx, field, obj)
		case "dwdelete":
			out.Values[i] = ec._AdminPermission_dwdelete(ctx, field, obj)
		case "status":
			out.Values[i] = ec._AdminPermission_status(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._AdminPermission_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._AdminPermission_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._AdminPermission_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminPermissionListImplementors = []string{"AdminPermissionList"}

func (ec *executionContext) _AdminPermissionList(ctx context.Context, sel ast.SelectionSet, obj *model.AdminPermissionList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminPermissionListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminPermissionList")
		case "adminPermissions":
			out.Values[i] = ec._AdminPermissionList_adminPermissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._AdminPermissionList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var announcementImplementors = []string{"Announcement"}

func (ec *executionContext) _Announcement(ctx context.Context, sel ast.SelectionSet, obj *models.Announcement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Announcement")
		case "id":
			out.Values[i] = ec._Announcement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Announcement_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Announcement_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Announcement_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._Announcement_orderNum(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Announcement_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Announcement_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "showFrom":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Announcement_showFrom(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "showTo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Announcement_showTo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Announcement_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Announcement_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Announcement_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var announcementListImplementors = []string{"AnnouncementList"}

func (ec *executionContext) _AnnouncementList(ctx context.Context, sel ast.SelectionSet, obj *model.AnnouncementList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnouncementList")
		case "announcements":
			out.Values[i] = ec._AnnouncementList_announcements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._AnnouncementList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bankImplementors = []string{"Bank"}

func (ec *executionContext) _Bank(ctx context.Context, sel ast.SelectionSet, obj *models.Bank) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bankImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bank")
		case "id":
			out.Values[i] = ec._Bank_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Bank_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Bank_orderNum(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Bank_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Bank_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Bank_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Bank_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bankListImplementors = []string{"BankList"}

func (ec *executionContext) _BankList(ctx context.Context, sel ast.SelectionSet, obj *model.BankList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bankListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BankList")
		case "banks":
			out.Values[i] = ec._BankList_banks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._BankList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var domainImplementors = []string{"Domain"}

func (ec *executionContext) _Domain(ctx context.Context, sel ast.SelectionSet, obj *models.Domain) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, domainImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Domain")
		case "id":
			out.Values[i] = ec._Domain_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Domain_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Domain_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Domain_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoReg":
			out.Values[i] = ec._Domain_autoReg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "useTelegram":
			out.Values[i] = ec._Domain_useTelegram(ctx, field, obj)
		case "telegram":
			out.Values[i] = ec._Domain_telegram(ctx, field, obj)
		case "telegramLink":
			out.Values[i] = ec._Domain_telegramLink(ctx, field, obj)
		case "useKakaoTalk":
			out.Values[i] = ec._Domain_useKakaoTalk(ctx, field, obj)
		case "kakaoTalk":
			out.Values[i] = ec._Domain_kakaoTalk(ctx, field, obj)
		case "kakaoTalkLink":
			out.Values[i] = ec._Domain_kakaoTalkLink(ctx, field, obj)
		case "useServiceCenter":
			out.Values[i] = ec._Domain_useServiceCenter(ctx, field, obj)
		case "serviceCenter":
			out.Values[i] = ec._Domain_serviceCenter(ctx, field, obj)
		case "serviceCenterLink":
			out.Values[i] = ec._Domain_serviceCenterLink(ctx, field, obj)
		case "useLiveDomain":
			out.Values[i] = ec._Domain_useLiveDomain(ctx, field, obj)
		case "liveDomain":
			out.Values[i] = ec._Domain_liveDomain(ctx, field, obj)
		case "liveDomainLink":
			out.Values[i] = ec._Domain_liveDomainLink(ctx, field, obj)
		case "memberLevel":
			out.Values[i] = ec._Domain_memberLevel(ctx, field, obj)
		case "distributorLevel":
			out.Values[i] = ec._Domain_distributorLevel(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Domain_orderNum(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Domain_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Domain_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Domain_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Domain_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Domain_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var domainListImplementors = []string{"DomainList"}

func (ec *executionContext) _DomainList(ctx context.Context, sel ast.SelectionSet, obj *model.DomainList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, domainListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DomainList")
		case "domains":
			out.Values[i] = ec._DomainList_domains(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._DomainList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *models.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Event_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Event_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Event_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Event_orderNum(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Event_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Event_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "domainId":
			out.Values[i] = ec._Event_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Event_domain(ctx, field, obj)
		case "showFrom":
			out.Values[i] = ec._Event_showFrom(ctx, field, obj)
		case "showTo":
			out.Values[i] = ec._Event_showTo(ctx, field, obj)
		case "category":
			out.Values[i] = ec._Event_category(ctx, field, obj)
		case "views":
			out.Values[i] = ec._Event_views(ctx, field, obj)
		case "mainImage":
			out.Values[i] = ec._Event_mainImage(ctx, field, obj)
		case "imageUpload":
			out.Values[i] = ec._Event_imageUpload(ctx, field, obj)
		case "level":
			out.Values[i] = ec._Event_level(ctx, field, obj)
		case "createdDate":
			out.Values[i] = ec._Event_createdDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Event_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventListImplementors = []string{"EventList"}

func (ec *executionContext) _EventList(ctx context.Context, sel ast.SelectionSet, obj *model.EventList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventList")
		case "events":
			out.Values[i] = ec._EventList_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._EventList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameAPIImplementors = []string{"GameAPI"}

func (ec *executionContext) _GameAPI(ctx context.Context, sel ast.SelectionSet, obj *model.GameAPI) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameAPIImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameAPI")
		case "id":
			out.Values[i] = ec._GameAPI_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apiCompanyName":
			out.Values[i] = ec._GameAPI_apiCompanyName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameApiName":
			out.Values[i] = ec._GameAPI_gameApiName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameCompanyName":
			out.Values[i] = ec._GameAPI_gameCompanyName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameType":
			out.Values[i] = ec._GameAPI_gameType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "other":
			out.Values[i] = ec._GameAPI_other(ctx, field, obj)
		case "whetherToUse":
			out.Values[i] = ec._GameAPI_whetherToUse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "order":
			out.Values[i] = ec._GameAPI_order(ctx, field, obj)
		case "type":
			out.Values[i] = ec._GameAPI_type(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._GameAPI_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._GameAPI_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._GameAPI_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameAPIListImplementors = []string{"GameAPIList"}

func (ec *executionContext) _GameAPIList(ctx context.Context, sel ast.SelectionSet, obj *model.GameAPIList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameAPIListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameAPIList")
		case "gameApis":
			out.Values[i] = ec._GameAPIList_gameApis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._GameAPIList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboxImplementors = []string{"Inbox"}

func (ec *executionContext) _Inbox(ctx context.Context, sel ast.SelectionSet, obj *models.Inbox) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboxImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Inbox")
		case "id":
			out.Values[i] = ec._Inbox_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Inbox_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Inbox_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Inbox_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Inbox_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Inbox_orderNum(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Inbox_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Inbox_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fromId":
			out.Values[i] = ec._Inbox_fromId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FromUser":
			out.Values[i] = ec._Inbox_FromUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "openedAt":
			out.Values[i] = ec._Inbox_openedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Inbox_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Inbox_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Inbox_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboxListImplementors = []string{"InboxList"}

func (ec *executionContext) _InboxList(ctx context.Context, sel ast.SelectionSet, obj *model.InboxList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboxListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InboxList")
		case "inboxes":
			out.Values[i] = ec._InboxList_inboxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._InboxList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logImplementors = []string{"Log"}

func (ec *executionContext) _Log(ctx context.Context, sel ast.SelectionSet, obj *models.Log) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Log")
		case "id":
			out.Values[i] = ec._Log_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._Log_data(ctx, field, obj)
		case "path":
			out.Values[i] = ec._Log_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "phone":
			out.Values[i] = ec._Log_phone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "method":
			out.Values[i] = ec._Log_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Log_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ip":
			out.Values[i] = ec._Log_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Log_userId(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Log_user(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Log_status(ctx, field, obj)
		case "os":
			out.Values[i] = ec._Log_os(ctx, field, obj)
		case "device":
			out.Values[i] = ec._Log_device(ctx, field, obj)
		case "host":
			out.Values[i] = ec._Log_host(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Log_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Log_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Log_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logListImplementors = []string{"LogList"}

func (ec *executionContext) _LogList(ctx context.Context, sel ast.SelectionSet, obj *model.LogList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogList")
		case "logs":
			out.Values[i] = ec._LogList_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._LogList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var menuImplementors = []string{"Menu"}

func (ec *executionContext) _Menu(ctx context.Context, sel ast.SelectionSet, obj *models.Menu) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, menuImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Menu")
		case "id":
			out.Values[i] = ec._Menu_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Menu_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "label":
			out.Values[i] = ec._Menu_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._Menu_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "icon":
			out.Values[i] = ec._Menu_icon(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Menu_description(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Menu_status(ctx, field, obj)
		case "parentId":
			out.Values[i] = ec._Menu_parentId(ctx, field, obj)
		case "children":
			out.Values[i] = ec._Menu_children(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Menu_orderNum(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Menu_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Menu_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Menu_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var menuListImplementors = []string{"MenuList"}

func (ec *executionContext) _MenuList(ctx context.Context, sel ast.SelectionSet, obj *model.MenuList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, menuListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MenuList")
		case "menus":
			out.Values[i] = ec._MenuList_menus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MenuList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "time":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_time(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadFile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadFile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createAdminPermission":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAdminPermission(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAdminPermission":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAdminPermission(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLog":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLog(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteLog":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteLog(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "replyQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_replyQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completeQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_completeQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTodo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTodo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "blockTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_blockTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitingTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_waitingTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateProfile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProfile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteProfile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProfile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "blockUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_blockUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationImplementors = []string{"Notification"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *models.Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "id":
			out.Values[i] = ec._Notification_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Notification_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Notification_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Notification_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._Notification_orderNum(ctx, field, obj)
		case "showFrom":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_showFrom(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mainImage":
			out.Values[i] = ec._Notification_mainImage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageUpload":
			out.Values[i] = ec._Notification_imageUpload(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "noticeType":
			out.Values[i] = ec._Notification_noticeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "registerDate":
			out.Values[i] = ec._Notification_registerDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level":
			out.Values[i] = ec._Notification_level(ctx, field, obj)
		case "domainId":
			out.Values[i] = ec._Notification_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Notification_domain(ctx, field, obj)
		case "views":
			out.Values[i] = ec._Notification_views(ctx, field, obj)
		case "showTo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_showTo(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Notification_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Notification_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Notification_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationListImplementors = []string{"NotificationList"}

func (ec *executionContext) _NotificationList(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationList")
		case "notifications":
			out.Values[i] = ec._NotificationList_notifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._NotificationList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var profileImplementors = []string{"Profile"}

func (ec *executionContext) _Profile(ctx context.Context, sel ast.SelectionSet, obj *models.Profile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, profileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Profile")
		case "id":
			out.Values[i] = ec._Profile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Profile_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Profile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._Profile_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bankName":
			out.Values[i] = ec._Profile_bankName(ctx, field, obj)
		case "holderName":
			out.Values[i] = ec._Profile_holderName(ctx, field, obj)
		case "accountNumber":
			out.Values[i] = ec._Profile_accountNumber(ctx, field, obj)
		case "birthday":
			out.Values[i] = ec._Profile_birthday(ctx, field, obj)
		case "phone":
			out.Values[i] = ec._Profile_phone(ctx, field, obj)
		case "mobile":
			out.Values[i] = ec._Profile_mobile(ctx, field, obj)
		case "phoneVerified":
			out.Values[i] = ec._Profile_phoneVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "balance":
			out.Values[i] = ec._Profile_balance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roll":
			out.Values[i] = ec._Profile_roll(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "point":
			out.Values[i] = ec._Profile_point(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comp":
			out.Values[i] = ec._Profile_comp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._Profile_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "coupon":
			out.Values[i] = ec._Profile_coupon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "favorites":
			out.Values[i] = ec._Profile_favorites(ctx, field, obj)
		case "referral":
			out.Values[i] = ec._Profile_referral(ctx, field, obj)
		case "avatarUrl":
			out.Values[i] = ec._Profile_avatarUrl(ctx, field, obj)
		case "bio":
			out.Values[i] = ec._Profile_bio(ctx, field, obj)
		case "socialLinks":
			out.Values[i] = ec._Profile_socialLinks(ctx, field, obj)
		case "lastDeposit":
			out.Values[i] = ec._Profile_lastDeposit(ctx, field, obj)
		case "lastWithdraw":
			out.Values[i] = ec._Profile_lastWithdraw(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Profile_orderNum(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Profile_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Profile_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Profile_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qnaImplementors = []string{"Qna"}

func (ec *executionContext) _Qna(ctx context.Context, sel ast.SelectionSet, obj *models.Qna) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qnaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Qna")
		case "id":
			out.Values[i] = ec._Qna_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Qna_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Qna_user(ctx, field, obj)
		case "domainId":
			out.Values[i] = ec._Qna_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Qna_domain(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Qna_type(ctx, field, obj)
		case "question":
			out.Values[i] = ec._Qna_question(ctx, field, obj)
		case "questionTitle":
			out.Values[i] = ec._Qna_questionTitle(ctx, field, obj)
		case "answer":
			out.Values[i] = ec._Qna_answer(ctx, field, obj)
		case "answerTitle":
			out.Values[i] = ec._Qna_answerTitle(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Qna_status(ctx, field, obj)
		case "repliedAt":
			out.Values[i] = ec._Qna_repliedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Qna_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Qna_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Qna_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qnaListImplementors = []string{"QnaList"}

func (ec *executionContext) _QnaList(ctx context.Context, sel ast.SelectionSet, obj *model.QnaList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qnaListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QnaList")
		case "qnas":
			out.Values[i] = ec._QnaList_qnas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._QnaList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "time":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_time(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminPermissions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "announcements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_announcements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getBanks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBanks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "domains":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_domains(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDomains":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDomains(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "topEvents":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_topEvents(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGameApis":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGameApis(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInboxes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInboxes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "logs":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getLogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUserMenus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUserMenus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMenus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMenus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notifications(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getNotifications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getNotifications(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getQnas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getQnas(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSetting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSetting(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMSApis":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMSApis(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "todos":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_todos(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTransactions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTransactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getWeeklyLosingData":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWeeklyLosingData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "profile":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_profile(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "filterUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_filterUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectedUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectedUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDistributors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDistributors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDistributorDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDistributorDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMSApiImplementors = []string{"SMSApi"}

func (ec *executionContext) _SMSApi(ctx context.Context, sel ast.SelectionSet, obj *models.SMSApi) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMSApiImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMSApi")
		case "id":
			out.Values[i] = ec._SMSApi_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._SMSApi_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._SMSApi_url(ctx, field, obj)
		case "agent":
			out.Values[i] = ec._SMSApi_agent(ctx, field, obj)
		case "password":
			out.Values[i] = ec._SMSApi_password(ctx, field, obj)
		case "token":
			out.Values[i] = ec._SMSApi_token(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._SMSApi_orderNum(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SMSApi_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SMSApi_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._SMSApi_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._SMSApi_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMSApiListImplementors = []string{"SMSApiList"}

func (ec *executionContext) _SMSApiList(ctx context.Context, sel ast.SelectionSet, obj *model.SMSApiList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMSApiListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMSApiList")
		case "smsApis":
			out.Values[i] = ec._SMSApiList_smsApis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._SMSApiList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var settingImplementors = []string{"Setting"}

func (ec *executionContext) _Setting(ctx context.Context, sel ast.SelectionSet, obj *model.Setting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, settingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Setting")
		case "id":
			out.Values[i] = ec._Setting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Setting_status(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Setting_title(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Setting_description(ctx, field, obj)
		case "primaryDomain":
			out.Values[i] = ec._Setting_primaryDomain(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Setting_userId(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Setting_user(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Setting_orderNum(ctx, field, obj)
		case "totalExStatus":
			out.Values[i] = ec._Setting_totalExStatus(ctx, field, obj)
		case "totalExFrom":
			out.Values[i] = ec._Setting_totalExFrom(ctx, field, obj)
		case "totalExTo":
			out.Values[i] = ec._Setting_totalExTo(ctx, field, obj)
		case "totalReStatus":
			out.Values[i] = ec._Setting_totalReStatus(ctx, field, obj)
		case "totalReFrom":
			out.Values[i] = ec._Setting_totalReFrom(ctx, field, obj)
		case "totalReTo":
			out.Values[i] = ec._Setting_totalReTo(ctx, field, obj)
		case "userExStatus":
			out.Values[i] = ec._Setting_userExStatus(ctx, field, obj)
		case "userExFrom":
			out.Values[i] = ec._Setting_userExFrom(ctx, field, obj)
		case "userExTo":
			out.Values[i] = ec._Setting_userExTo(ctx, field, obj)
		case "userReStatus":
			out.Values[i] = ec._Setting_userReStatus(ctx, field, obj)
		case "userReFrom":
			out.Values[i] = ec._Setting_userReFrom(ctx, field, obj)
		case "userReTo":
			out.Values[i] = ec._Setting_userReTo(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Setting_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Setting_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Setting_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "time":
		return ec._Subscription_time(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var todoImplementors = []string{"Todo"}

func (ec *executionContext) _Todo(ctx context.Context, sel ast.SelectionSet, obj *model.Todo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, todoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Todo")
		case "id":
			out.Values[i] = ec._Todo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._Todo_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "done":
			out.Values[i] = ec._Todo_done(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Todo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *models.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			out.Values[i] = ec._Transaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Transaction_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Transaction_user(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Transaction_type(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._Transaction_amount(ctx, field, obj)
		case "balanceBefore":
			out.Values[i] = ec._Transaction_balanceBefore(ctx, field, obj)
		case "balanceAfter":
			out.Values[i] = ec._Transaction_balanceAfter(ctx, field, obj)
		case "pointBefore":
			out.Values[i] = ec._Transaction_pointBefore(ctx, field, obj)
		case "pointAfter":
			out.Values[i] = ec._Transaction_pointAfter(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Transaction_status(ctx, field, obj)
		case "shortcut":
			out.Values[i] = ec._Transaction_shortcut(ctx, field, obj)
		case "usdtDesc":
			out.Values[i] = ec._Transaction_usdtDesc(ctx, field, obj)
		case "transactionAt":
			out.Values[i] = ec._Transaction_transactionAt(ctx, field, obj)
		case "approvedAt":
			out.Values[i] = ec._Transaction_approvedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Transaction_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Transaction_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Transaction_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionListImplementors = []string{"TransactionList"}

func (ec *executionContext) _TransactionList(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionList")
		case "transactions":
			out.Values[i] = ec._TransactionList_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._TransactionList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userid":
			out.Values[i] = ec._User_userid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "role":
			out.Values[i] = ec._User_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "usdtAddress":
			out.Values[i] = ec._User_usdtAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currentIP":
			out.Values[i] = ec._User_currentIP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "IP":
			out.Values[i] = ec._User_IP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rootId":
			out.Values[i] = ec._User_rootId(ctx, field, obj)
		case "root":
			out.Values[i] = ec._User_root(ctx, field, obj)
		case "parentId":
			out.Values[i] = ec._User_parentId(ctx, field, obj)
		case "parent":
			out.Values[i] = ec._User_parent(ctx, field, obj)
		case "children":
			out.Values[i] = ec._User_children(ctx, field, obj)
		case "childrenCount":
			out.Values[i] = ec._User_childrenCount(ctx, field, obj)
		case "profile":
			out.Values[i] = ec._User_profile(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "blackMemo":
			out.Values[i] = ec._User_blackMemo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._User_orderNum(ctx, field, obj)
		case "os":
			out.Values[i] = ec._User_os(ctx, field, obj)
		case "device":
			out.Values[i] = ec._User_device(ctx, field, obj)
		case "fingerPrint":
			out.Values[i] = ec._User_fingerPrint(ctx, field, obj)
		case "live":
			out.Values[i] = ec._User_live(ctx, field, obj)
		case "slot":
			out.Values[i] = ec._User_slot(ctx, field, obj)
		case "hold":
			out.Values[i] = ec._User_hold(ctx, field, obj)
		case "entireLosing":
			out.Values[i] = ec._User_entireLosing(ctx, field, obj)
		case "liveLosingBeDang":
			out.Values[i] = ec._User_liveLosingBeDang(ctx, field, obj)
		case "slotLosingBeDang":
			out.Values[i] = ec._User_slotLosingBeDang(ctx, field, obj)
		case "holdLosingBeDang":
			out.Values[i] = ec._User_holdLosingBeDang(ctx, field, obj)
		case "losingMethod":
			out.Values[i] = ec._User_losingMethod(ctx, field, obj)
		case "miniDanpolRolling":
			out.Values[i] = ec._User_miniDanpolRolling(ctx, field, obj)
		case "miniCombinationRolling":
			out.Values[i] = ec._User_miniCombinationRolling(ctx, field, obj)
		case "sportsDanpolRolling":
			out.Values[i] = ec._User_sportsDanpolRolling(ctx, field, obj)
		case "sportsDupolRolling":
			out.Values[i] = ec._User_sportsDupolRolling(ctx, field, obj)
		case "sports3PoleRolling":
			out.Values[i] = ec._User_sports3PoleRolling(ctx, field, obj)
		case "sports4PoleRolling":
			out.Values[i] = ec._User_sports4PoleRolling(ctx, field, obj)
		case "sports5PoleRolling":
			out.Values[i] = ec._User_sports5PoleRolling(ctx, field, obj)
		case "sportsDapolRolling":
			out.Values[i] = ec._User_sportsDapolRolling(ctx, field, obj)
		case "virtualGameRolling":
			out.Values[i] = ec._User_virtualGameRolling(ctx, field, obj)
		case "lotusRolling":
			out.Values[i] = ec._User_lotusRolling(ctx, field, obj)
		case "mgmRolling":
			out.Values[i] = ec._User_mgmRolling(ctx, field, obj)
		case "touchRolling":
			out.Values[i] = ec._User_touchRolling(ctx, field, obj)
		case "membershipDeposit":
			out.Values[i] = ec._User_membershipDeposit(ctx, field, obj)
		case "membershipWithdrawal":
			out.Values[i] = ec._User_membershipWithdrawal(ctx, field, obj)
		case "totalWithdrawal":
			out.Values[i] = ec._User_totalWithdrawal(ctx, field, obj)
		case "numberOfMembers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_numberOfMembers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rollingHoldings":
			out.Values[i] = ec._User_rollingHoldings(ctx, field, obj)
		case "liveBetting":
			out.Values[i] = ec._User_liveBetting(ctx, field, obj)
		case "liveWinning":
			out.Values[i] = ec._User_liveWinning(ctx, field, obj)
		case "slotBetting":
			out.Values[i] = ec._User_slotBetting(ctx, field, obj)
		case "slotJackpot":
			out.Values[i] = ec._User_slotJackpot(ctx, field, obj)
		case "miniDanpolBetting":
			out.Values[i] = ec._User_miniDanpolBetting(ctx, field, obj)
		case "miniDanpolWinner":
			out.Values[i] = ec._User_miniDanpolWinner(ctx, field, obj)
		case "miniCombinationBetting":
			out.Values[i] = ec._User_miniCombinationBetting(ctx, field, obj)
		case "miniCombinationWinnings":
			out.Values[i] = ec._User_miniCombinationWinnings(ctx, field, obj)
		case "sportsDanpolBetting":
			out.Values[i] = ec._User_sportsDanpolBetting(ctx, field, obj)
		case "sportsDanpolWinner":
			out.Values[i] = ec._User_sportsDanpolWinner(ctx, field, obj)
		case "sportsDupolBetting":
			out.Values[i] = ec._User_sportsDupolBetting(ctx, field, obj)
		case "sportsDupolWinner":
			out.Values[i] = ec._User_sportsDupolWinner(ctx, field, obj)
		case "sports3poleBetting":
			out.Values[i] = ec._User_sports3poleBetting(ctx, field, obj)
		case "sports3poleWinner":
			out.Values[i] = ec._User_sports3poleWinner(ctx, field, obj)
		case "sports4poleBetting":
			out.Values[i] = ec._User_sports4poleBetting(ctx, field, obj)
		case "sports4poleWinner":
			out.Values[i] = ec._User_sports4poleWinner(ctx, field, obj)
		case "sports5poleBetting":
			out.Values[i] = ec._User_sports5poleBetting(ctx, field, obj)
		case "sports5poleWinner":
			out.Values[i] = ec._User_sports5poleWinner(ctx, field, obj)
		case "sportsDapolBetting":
			out.Values[i] = ec._User_sportsDapolBetting(ctx, field, obj)
		case "sportsDapolWinner":
			out.Values[i] = ec._User_sportsDapolWinner(ctx, field, obj)
		case "virtualGameBetting":
			out.Values[i] = ec._User_virtualGameBetting(ctx, field, obj)
		case "virtualGameWinnings":
			out.Values[i] = ec._User_virtualGameWinnings(ctx, field, obj)
		case "lotusBetting":
			out.Values[i] = ec._User_lotusBetting(ctx, field, obj)
		case "lotusLottery":
			out.Values[i] = ec._User_lotusLottery(ctx, field, obj)
		case "mgmBetting":
			out.Values[i] = ec._User_mgmBetting(ctx, field, obj)
		case "mgmWinning":
			out.Values[i] = ec._User_mgmWinning(ctx, field, obj)
		case "touchBetting":
			out.Values[i] = ec._User_touchBetting(ctx, field, obj)
		case "touchWinning":
			out.Values[i] = ec._User_touchWinning(ctx, field, obj)
		case "holdemBetting":
			out.Values[i] = ec._User_holdemBetting(ctx, field, obj)
		case "holdemWinning":
			out.Values[i] = ec._User_holdemWinning(ctx, field, obj)
		case "rollingRate":
			out.Values[i] = ec._User_rollingRate(ctx, field, obj)
		case "rollingTransition":
			out.Values[i] = ec._User_rollingTransition(ctx, field, obj)
		case "losingRate":
			out.Values[i] = ec._User_losingRate(ctx, field, obj)
		case "losingSettlement":
			out.Values[i] = ec._User_losingSettlement(ctx, field, obj)
		case "partnershipRolling":
			out.Values[i] = ec._User_partnershipRolling(ctx, field, obj)
		case "partnershipMoneyInHand":
			out.Values[i] = ec._User_partnershipMoneyInHand(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._User_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userListImplementors = []string{"UserList"}

func (ec *executionContext) _UserList(ctx context.Context, sel ast.SelectionSet, obj *model.UserList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserList")
		case "users":
			out.Values[i] = ec._UserList_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._UserList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var weeklyLosingDataImplementors = []string{"WeeklyLosingData"}

func (ec *executionContext) _WeeklyLosingData(ctx context.Context, sel ast.SelectionSet, obj *model.WeeklyLosingData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weeklyLosingDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeeklyLosingData")
		case "weekStart":
			out.Values[i] = ec._WeeklyLosingData_weekStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weekEnd":
			out.Values[i] = ec._WeeklyLosingData_weekEnd(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "site":
			out.Values[i] = ec._WeeklyLosingData_site(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorID":
			out.Values[i] = ec._WeeklyLosingData_distributorID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorName":
			out.Values[i] = ec._WeeklyLosingData_distributorName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorLevel":
			out.Values[i] = ec._WeeklyLosingData_distributorLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._WeeklyLosingData_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "depositor":
			out.Values[i] = ec._WeeklyLosingData_depositor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._WeeklyLosingData_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBet":
			out.Values[i] = ec._WeeklyLosingData_totalBet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalWinner":
			out.Values[i] = ec._WeeklyLosingData_totalWinner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalLosingMoney":
			out.Values[i] = ec._WeeklyLosingData_totalLosingMoney(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "settlementAmount":
			out.Values[i] = ec._WeeklyLosingData_settlementAmount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applicationDate":
			out.Values[i] = ec._WeeklyLosingData_applicationDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processingDate":
			out.Values[i] = ec._WeeklyLosingData_processingDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "situation":
			out.Values[i] = ec._WeeklyLosingData_situation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userCount":
			out.Values[i] = ec._WeeklyLosingData_userCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var weeklyLosingDataListImplementors = []string{"WeeklyLosingDataList"}

func (ec *executionContext) _WeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, obj *model.WeeklyLosingDataList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weeklyLosingDataListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeeklyLosingDataList")
		case "weeklyLosingData":
			out.Values[i] = ec._WeeklyLosingDataList_weeklyLosingData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._WeeklyLosingDataList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdminPermission2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermission(ctx context.Context, sel ast.SelectionSet, v models.AdminPermission) graphql.Marshaler {
	return ec._AdminPermission(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminPermission2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermissionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.AdminPermission) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminPermission2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermission(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminPermission2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAdminPermission(ctx context.Context, sel ast.SelectionSet, v *models.AdminPermission) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminPermission(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminPermissionList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAdminPermissionList(ctx context.Context, sel ast.SelectionSet, v model.AdminPermissionList) graphql.Marshaler {
	return ec._AdminPermissionList(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminPermissionList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAdminPermissionList(ctx context.Context, sel ast.SelectionSet, v *model.AdminPermissionList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminPermissionList(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnouncement2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncement(ctx context.Context, sel ast.SelectionSet, v models.Announcement) graphql.Marshaler {
	return ec._Announcement(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncement2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncementᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Announcement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAnnouncement2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAnnouncement2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐAnnouncement(ctx context.Context, sel ast.SelectionSet, v *models.Announcement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnouncementList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAnnouncementList(ctx context.Context, sel ast.SelectionSet, v model.AnnouncementList) graphql.Marshaler {
	return ec._AnnouncementList(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncementList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐAnnouncementList(ctx context.Context, sel ast.SelectionSet, v *model.AnnouncementList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AnnouncementList(ctx, sel, v)
}

func (ec *executionContext) marshalNBank2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBank(ctx context.Context, sel ast.SelectionSet, v models.Bank) graphql.Marshaler {
	return ec._Bank(ctx, sel, &v)
}

func (ec *executionContext) marshalNBank2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBankᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Bank) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBank2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBank(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBank2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐBank(ctx context.Context, sel ast.SelectionSet, v *models.Bank) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bank(ctx, sel, v)
}

func (ec *executionContext) marshalNBankList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐBankList(ctx context.Context, sel ast.SelectionSet, v model.BankList) graphql.Marshaler {
	return ec._BankList(ctx, sel, &v)
}

func (ec *executionContext) marshalNBankList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐBankList(ctx context.Context, sel ast.SelectionSet, v *model.BankList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BankList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDomain2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx context.Context, sel ast.SelectionSet, v models.Domain) graphql.Marshaler {
	return ec._Domain(ctx, sel, &v)
}

func (ec *executionContext) marshalNDomain2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomainᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Domain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx context.Context, sel ast.SelectionSet, v *models.Domain) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Domain(ctx, sel, v)
}

func (ec *executionContext) marshalNDomainList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐDomainList(ctx context.Context, sel ast.SelectionSet, v model.DomainList) graphql.Marshaler {
	return ec._DomainList(ctx, sel, &v)
}

func (ec *executionContext) marshalNDomainList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐDomainList(ctx context.Context, sel ast.SelectionSet, v *model.DomainList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DomainList(ctx, sel, v)
}

func (ec *executionContext) marshalNEvent2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx context.Context, sel ast.SelectionSet, v models.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) marshalNEventList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐEventList(ctx context.Context, sel ast.SelectionSet, v model.EventList) graphql.Marshaler {
	return ec._EventList(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐEventList(ctx context.Context, sel ast.SelectionSet, v *model.EventList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFilter2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx context.Context, v any) (*model.Filter, error) {
	res, err := ec.unmarshalInputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGameAPI2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPI(ctx context.Context, sel ast.SelectionSet, v model.GameAPI) graphql.Marshaler {
	return ec._GameAPI(ctx, sel, &v)
}

func (ec *executionContext) marshalNGameAPI2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPIᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.GameAPI) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGameAPI2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPI(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGameAPI2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPI(ctx context.Context, sel ast.SelectionSet, v *model.GameAPI) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameAPI(ctx, sel, v)
}

func (ec *executionContext) marshalNGameAPIList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPIList(ctx context.Context, sel ast.SelectionSet, v model.GameAPIList) graphql.Marshaler {
	return ec._GameAPIList(ctx, sel, &v)
}

func (ec *executionContext) marshalNGameAPIList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐGameAPIList(ctx context.Context, sel ast.SelectionSet, v *model.GameAPIList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameAPIList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInbox2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInbox(ctx context.Context, sel ast.SelectionSet, v models.Inbox) graphql.Marshaler {
	return ec._Inbox(ctx, sel, &v)
}

func (ec *executionContext) marshalNInbox2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInboxᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Inbox) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInbox2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInbox(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInbox2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐInbox(ctx context.Context, sel ast.SelectionSet, v *models.Inbox) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Inbox(ctx, sel, v)
}

func (ec *executionContext) marshalNInboxList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐInboxList(ctx context.Context, sel ast.SelectionSet, v model.InboxList) graphql.Marshaler {
	return ec._InboxList(ctx, sel, &v)
}

func (ec *executionContext) marshalNInboxList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐInboxList(ctx context.Context, sel ast.SelectionSet, v *model.InboxList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InboxList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v any) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLog2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLog(ctx context.Context, sel ast.SelectionSet, v models.Log) graphql.Marshaler {
	return ec._Log(ctx, sel, &v)
}

func (ec *executionContext) marshalNLog2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Log) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLog2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLog2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLog(ctx context.Context, sel ast.SelectionSet, v *models.Log) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Log(ctx, sel, v)
}

func (ec *executionContext) marshalNLogList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐLogList(ctx context.Context, sel ast.SelectionSet, v model.LogList) graphql.Marshaler {
	return ec._LogList(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐLogList(ctx context.Context, sel ast.SelectionSet, v *model.LogList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogList(ctx, sel, v)
}

func (ec *executionContext) marshalNMenu2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx context.Context, sel ast.SelectionSet, v models.Menu) graphql.Marshaler {
	return ec._Menu(ctx, sel, &v)
}

func (ec *executionContext) marshalNMenu2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx context.Context, sel ast.SelectionSet, v []*models.Menu) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNMenu2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenuᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Menu) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx context.Context, sel ast.SelectionSet, v *models.Menu) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Menu(ctx, sel, v)
}

func (ec *executionContext) marshalNMenuList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐMenuList(ctx context.Context, sel ast.SelectionSet, v model.MenuList) graphql.Marshaler {
	return ec._MenuList(ctx, sel, &v)
}

func (ec *executionContext) marshalNMenuList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐMenuList(ctx context.Context, sel ast.SelectionSet, v *model.MenuList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MenuList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNewAdminPermission2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewAdminPermission(ctx context.Context, v any) (model.NewAdminPermission, error) {
	res, err := ec.unmarshalInputNewAdminPermission(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewAnnouncementInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewAnnouncementInput(ctx context.Context, v any) (model.NewAnnouncementInput, error) {
	res, err := ec.unmarshalInputNewAnnouncementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewBankInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewBankInput(ctx context.Context, v any) (model.NewBankInput, error) {
	res, err := ec.unmarshalInputNewBankInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewDomainInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewDomainInput(ctx context.Context, v any) (model.NewDomainInput, error) {
	res, err := ec.unmarshalInputNewDomainInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewEventInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewEventInput(ctx context.Context, v any) (model.NewEventInput, error) {
	res, err := ec.unmarshalInputNewEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewGameApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewGameAPIInput(ctx context.Context, v any) (model.NewGameAPIInput, error) {
	res, err := ec.unmarshalInputNewGameApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewInboxInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewInboxInput(ctx context.Context, v any) (model.NewInboxInput, error) {
	res, err := ec.unmarshalInputNewInboxInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewLogInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewLogInput(ctx context.Context, v any) (model.NewLogInput, error) {
	res, err := ec.unmarshalInputNewLogInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewMenuInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewMenuInput(ctx context.Context, v any) (model.NewMenuInput, error) {
	res, err := ec.unmarshalInputNewMenuInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewNotificationInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewNotificationInput(ctx context.Context, v any) (model.NewNotificationInput, error) {
	res, err := ec.unmarshalInputNewNotificationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewQnaInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewQnaInput(ctx context.Context, v any) (model.NewQnaInput, error) {
	res, err := ec.unmarshalInputNewQnaInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSMSApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewSMSApiInput(ctx context.Context, v any) (model.NewSMSApiInput, error) {
	res, err := ec.unmarshalInputNewSMSApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSettingInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewSettingInput(ctx context.Context, v any) (model.NewSettingInput, error) {
	res, err := ec.unmarshalInputNewSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewTodo2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewTodo(ctx context.Context, v any) (model.NewTodo, error) {
	res, err := ec.unmarshalInputNewTodo(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewTransactionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewTransactionInput(ctx context.Context, v any) (model.NewTransactionInput, error) {
	res, err := ec.unmarshalInputNewTransactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotification2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx context.Context, sel ast.SelectionSet, v models.Notification) graphql.Marshaler {
	return ec._Notification(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotification2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotificationᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Notification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNotification2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx context.Context, sel ast.SelectionSet, v *models.Notification) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalNNotificationList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNotificationList(ctx context.Context, sel ast.SelectionSet, v model.NotificationList) graphql.Marshaler {
	return ec._NotificationList(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotificationList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNotificationList(ctx context.Context, sel ast.SelectionSet, v *model.NotificationList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NotificationList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrder2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrder(ctx context.Context, v any) (*model.Order, error) {
	res, err := ec.unmarshalInputOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProfile2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx context.Context, sel ast.SelectionSet, v models.Profile) graphql.Marshaler {
	return ec._Profile(ctx, sel, &v)
}

func (ec *executionContext) marshalNProfile2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx context.Context, sel ast.SelectionSet, v *models.Profile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Profile(ctx, sel, v)
}

func (ec *executionContext) marshalNQna2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx context.Context, sel ast.SelectionSet, v models.Qna) graphql.Marshaler {
	return ec._Qna(ctx, sel, &v)
}

func (ec *executionContext) marshalNQna2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQnaᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Qna) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNQna2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNQna2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐQna(ctx context.Context, sel ast.SelectionSet, v *models.Qna) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Qna(ctx, sel, v)
}

func (ec *executionContext) marshalNQnaList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐQnaList(ctx context.Context, sel ast.SelectionSet, v model.QnaList) graphql.Marshaler {
	return ec._QnaList(ctx, sel, &v)
}

func (ec *executionContext) marshalNQnaList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐQnaList(ctx context.Context, sel ast.SelectionSet, v *model.QnaList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QnaList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx context.Context, v any) (model.Role, error) {
	var res model.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐRole(ctx context.Context, sel ast.SelectionSet, v model.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSMSApi2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApi(ctx context.Context, sel ast.SelectionSet, v models.SMSApi) graphql.Marshaler {
	return ec._SMSApi(ctx, sel, &v)
}

func (ec *executionContext) marshalNSMSApi2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApiᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.SMSApi) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSMSApi2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApi(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSMSApi2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐSMSApi(ctx context.Context, sel ast.SelectionSet, v *models.SMSApi) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMSApi(ctx, sel, v)
}

func (ec *executionContext) marshalNSMSApiList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSMSApiList(ctx context.Context, sel ast.SelectionSet, v model.SMSApiList) graphql.Marshaler {
	return ec._SMSApiList(ctx, sel, &v)
}

func (ec *executionContext) marshalNSMSApiList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSMSApiList(ctx context.Context, sel ast.SelectionSet, v *model.SMSApiList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMSApiList(ctx, sel, v)
}

func (ec *executionContext) marshalNSetting2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSetting(ctx context.Context, sel ast.SelectionSet, v model.Setting) graphql.Marshaler {
	return ec._Setting(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetting2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐSetting(ctx context.Context, sel ast.SelectionSet, v *model.Setting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Setting(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTodo2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodo(ctx context.Context, sel ast.SelectionSet, v model.Todo) graphql.Marshaler {
	return ec._Todo(ctx, sel, &v)
}

func (ec *executionContext) marshalNTodo2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodoᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Todo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTodo2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTodo2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTodo(ctx context.Context, sel ast.SelectionSet, v *model.Todo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Todo(ctx, sel, v)
}

func (ec *executionContext) marshalNTransaction2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransaction(ctx context.Context, sel ast.SelectionSet, v models.Transaction) graphql.Marshaler {
	return ec._Transaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransaction2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Transaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransaction2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐTransaction(ctx context.Context, sel ast.SelectionSet, v *models.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTransactionList(ctx context.Context, sel ast.SelectionSet, v model.TransactionList) graphql.Marshaler {
	return ec._TransactionList(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐTransactionList(ctx context.Context, sel ast.SelectionSet, v *model.TransactionList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateAdminPermissionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateAdminPermissionInput(ctx context.Context, v any) (model.UpdateAdminPermissionInput, error) {
	res, err := ec.unmarshalInputUpdateAdminPermissionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateAnnouncementInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateAnnouncementInput(ctx context.Context, v any) (model.UpdateAnnouncementInput, error) {
	res, err := ec.unmarshalInputUpdateAnnouncementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateBankInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateBankInput(ctx context.Context, v any) (model.UpdateBankInput, error) {
	res, err := ec.unmarshalInputUpdateBankInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateDomainInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateDomainInput(ctx context.Context, v any) (model.UpdateDomainInput, error) {
	res, err := ec.unmarshalInputUpdateDomainInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEventInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateEventInput(ctx context.Context, v any) (model.UpdateEventInput, error) {
	res, err := ec.unmarshalInputUpdateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGameApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateGameAPIInput(ctx context.Context, v any) (model.UpdateGameAPIInput, error) {
	res, err := ec.unmarshalInputUpdateGameApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateInboxInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateInboxInput(ctx context.Context, v any) (model.UpdateInboxInput, error) {
	res, err := ec.unmarshalInputUpdateInboxInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMenuInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateMenuInput(ctx context.Context, v any) (model.UpdateMenuInput, error) {
	res, err := ec.unmarshalInputUpdateMenuInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateNotificationInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateNotificationInput(ctx context.Context, v any) (model.UpdateNotificationInput, error) {
	res, err := ec.unmarshalInputUpdateNotificationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProfile2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateProfile(ctx context.Context, v any) (model.UpdateProfile, error) {
	res, err := ec.unmarshalInputUpdateProfile(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateQnaInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateQnaInput(ctx context.Context, v any) (model.UpdateQnaInput, error) {
	res, err := ec.unmarshalInputUpdateQnaInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSMSApiInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateSMSApiInput(ctx context.Context, v any) (model.UpdateSMSApiInput, error) {
	res, err := ec.unmarshalInputUpdateSMSApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSettingInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateSettingInput(ctx context.Context, v any) (model.UpdateSettingInput, error) {
	res, err := ec.unmarshalInputUpdateSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTransactionInput2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateTransactionInput(ctx context.Context, v any) (model.UpdateTransactionInput, error) {
	res, err := ec.unmarshalInputUpdateTransactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUpdateUser(ctx context.Context, v any) (model.UpdateUser, error) {
	res, err := ec.unmarshalInputUpdateUser(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v any) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx context.Context, sel ast.SelectionSet, v model.UserList) graphql.Marshaler {
	return ec._UserList(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserList(ctx context.Context, sel ast.SelectionSet, v *model.UserList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserStatus2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx context.Context, v any) (model.UserStatus, error) {
	var res model.UserStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserStatus2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx context.Context, sel ast.SelectionSet, v model.UserStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserType2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx context.Context, v any) (model.UserType, error) {
	var res model.UserType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserType2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx context.Context, sel ast.SelectionSet, v model.UserType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeeklyLosingData2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingDataᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WeeklyLosingData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeeklyLosingData2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWeeklyLosingData2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingData(ctx context.Context, sel ast.SelectionSet, v *model.WeeklyLosingData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeeklyLosingData(ctx, sel, v)
}

func (ec *executionContext) marshalNWeeklyLosingDataList2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, v model.WeeklyLosingDataList) graphql.Marshaler {
	return ec._WeeklyLosingDataList(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeeklyLosingDataList2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐWeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, v *model.WeeklyLosingDataList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeeklyLosingDataList(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx context.Context, v any) (*gorm.DeletedAt, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalDeletedAt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeletedAt2ᚖgormᚗioᚋgormᚐDeletedAt(ctx context.Context, sel ast.SelectionSet, v *gorm.DeletedAt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := scalar.MarshalDeletedAt(*v)
	return res
}

func (ec *executionContext) marshalODomain2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx context.Context, sel ast.SelectionSet, v models.Domain) graphql.Marshaler {
	return ec._Domain(ctx, sel, &v)
}

func (ec *executionContext) marshalODomain2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomainᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Domain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODomain2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐDomain(ctx context.Context, sel ast.SelectionSet, v *models.Domain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Domain(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx context.Context, v any) ([]*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Filter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilter2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilter2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilterᚄ(ctx context.Context, v any) ([]*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Filter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFilter2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilter2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐFilter(ctx context.Context, v any) (*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOID2ᚖuint(ctx context.Context, v any) (*uint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖuint(ctx context.Context, sel ast.SelectionSet, v *uint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint32(ctx context.Context, v any) (*int32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint32(ctx context.Context, sel ast.SelectionSet, v *int32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt32(*v)
	return res
}

func (ec *executionContext) marshalOLog2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Log) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLog2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMenu2ᚕgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenuᚄ(ctx context.Context, sel ast.SelectionSet, v []models.Menu) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMenu2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMenu2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐMenu(ctx context.Context, sel ast.SelectionSet, v *models.Menu) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Menu(ctx, sel, v)
}

func (ec *executionContext) unmarshalONewUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐNewUser(ctx context.Context, v any) (*model.NewUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNewUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotification2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotificationᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOp2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOp(ctx context.Context, v any) (*model.Op, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Op)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOp2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOp(ctx context.Context, sel ast.SelectionSet, v *model.Op) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOrder2ᚕᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderᚄ(ctx context.Context, v any) ([]*model.Order, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Order, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrder2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrderDirection2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderDirection(ctx context.Context, v any) (*model.OrderDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.OrderDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderDirection2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v *model.OrderDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPagination2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐPagination(ctx context.Context, v any) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPagination(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProfile2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐProfile(ctx context.Context, sel ast.SelectionSet, v models.Profile) graphql.Marshaler {
	return ec._Profile(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOUint2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	return res
}

func (ec *executionContext) unmarshalOUint2ᚖuint(ctx context.Context, v any) (*uint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2ᚖuint(ctx context.Context, sel ast.SelectionSet, v *uint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚕgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v []models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2githubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋinternalᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserStatus2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx context.Context, v any) (*model.UserStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.UserStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserStatus2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserStatus(ctx context.Context, sel ast.SelectionSet, v *model.UserStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserType2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx context.Context, v any) (*model.UserType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.UserType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserType2ᚖgithubᚗcomᚋhotbrainyᚋgoᚑbettingᚋbackendᚋgraphᚋmodelᚐUserType(ctx context.Context, sel ast.SelectionSet, v *model.UserType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
