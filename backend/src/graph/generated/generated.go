// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/hotbrainy/go-betting/backend/graph/model"
	"github.com/hotbrainy/go-betting/backend/graph/scalar"
	"github.com/hotbrainy/go-betting/backend/internal/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"gorm.io/gorm"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Announcement() AnnouncementResolver
	Log() LogResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	HasRole func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	AdminPermission struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Dwdelete    func(childComplexity int) int
		Financials  func(childComplexity int) int
		Game        func(childComplexity int) int
		ID          func(childComplexity int) int
		IP          func(childComplexity int) int
		Membership  func(childComplexity int) int
		Qna         func(childComplexity int) int
		Sale        func(childComplexity int) int
		Settlement  func(childComplexity int) int
		Statistical func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	AdminPermissionList struct {
		AdminPermissions func(childComplexity int) int
		Total            func(childComplexity int) int
	}

	Announcement struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ShowFrom    func(childComplexity int) int
		ShowTo      func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	AnnouncementList struct {
		Announcements func(childComplexity int) int
		Total         func(childComplexity int) int
	}

	Bank struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		OrderNum  func(childComplexity int) int
		Status    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	BankList struct {
		Banks func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Domain struct {
		AutoReg           func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Description       func(childComplexity int) int
		DistributorLevel  func(childComplexity int) int
		ID                func(childComplexity int) int
		KakaoTalk         func(childComplexity int) int
		KakaoTalkLink     func(childComplexity int) int
		LiveDomain        func(childComplexity int) int
		LiveDomainLink    func(childComplexity int) int
		MemberLevel       func(childComplexity int) int
		Name              func(childComplexity int) int
		OrderNum          func(childComplexity int) int
		ServiceCenter     func(childComplexity int) int
		ServiceCenterLink func(childComplexity int) int
		Status            func(childComplexity int) int
		Telegram          func(childComplexity int) int
		TelegramLink      func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		UseKakaoTalk      func(childComplexity int) int
		UseLiveDomain     func(childComplexity int) int
		UseServiceCenter  func(childComplexity int) int
		UseTelegram       func(childComplexity int) int
		User              func(childComplexity int) int
		UserID            func(childComplexity int) int
	}

	DomainList struct {
		Domains func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Event struct {
		Category    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedDate func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		Domain      func(childComplexity int) int
		DomainID    func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUpload func(childComplexity int) int
		Level       func(childComplexity int) int
		MainImage   func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ShowFrom    func(childComplexity int) int
		ShowTo      func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
		Views       func(childComplexity int) int
	}

	EventList struct {
		Events func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	GameAPI struct {
		APICompanyName  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		GameAPIName     func(childComplexity int) int
		GameCompanyName func(childComplexity int) int
		GameType        func(childComplexity int) int
		ID              func(childComplexity int) int
		Order           func(childComplexity int) int
		Other           func(childComplexity int) int
		Type            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		WhetherToUse    func(childComplexity int) int
	}

	GameAPIList struct {
		GameApis func(childComplexity int) int
		Total    func(childComplexity int) int
	}

	Inbox struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		FromID      func(childComplexity int) int
		FromUser    func(childComplexity int) int
		ID          func(childComplexity int) int
		OpenedAt    func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	InboxList struct {
		Inboxes func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Log struct {
		CreatedAt func(childComplexity int) int
		Data      func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Device    func(childComplexity int) int
		Host      func(childComplexity int) int
		ID        func(childComplexity int) int
		IP        func(childComplexity int) int
		Method    func(childComplexity int) int
		OS        func(childComplexity int) int
		Path      func(childComplexity int) int
		Phone     func(childComplexity int) int
		Status    func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	LogList struct {
		Logs  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Menu struct {
		Children    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Icon        func(childComplexity int) int
		Key         func(childComplexity int) int
		Label       func(childComplexity int) int
		OrderNum    func(childComplexity int) int
		ParentID    func(childComplexity int) int
		Path        func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	MenuList struct {
		Menus func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Mutation struct {
		ApproveTransaction    func(childComplexity int, id uint) int
		ApproveUser           func(childComplexity int, id uint) int
		BlockTransaction      func(childComplexity int, id uint) int
		BlockUser             func(childComplexity int, id uint) int
		CancelTransaction     func(childComplexity int, id uint) int
		CompleteQna           func(childComplexity int, id uint) int
		CreateAdminPermission func(childComplexity int, input model.NewAdminPermission) int
		CreateAnnouncement    func(childComplexity int, input model.NewAnnouncementInput) int
		CreateBank            func(childComplexity int, input model.NewBankInput) int
		CreateDomain          func(childComplexity int, input model.NewDomainInput) int
		CreateEvent           func(childComplexity int, input model.NewEventInput) int
		CreateGameAPI         func(childComplexity int, input model.NewGameAPIInput) int
		CreateInbox           func(childComplexity int, input model.NewInboxInput) int
		CreateLog             func(childComplexity int, input model.NewLogInput) int
		CreateMenu            func(childComplexity int, input model.NewMenuInput) int
		CreateNotification    func(childComplexity int, input model.NewNotificationInput) int
		CreateQna             func(childComplexity int, input model.NewQnaInput) int
		CreateSMSApi          func(childComplexity int, input model.NewSMSApiInput) int
		CreateSetting         func(childComplexity int, input model.NewSettingInput) int
		CreateTodo            func(childComplexity int, input model.NewTodo) int
		CreateTransaction     func(childComplexity int, input model.NewTransactionInput) int
		CreateUser            func(childComplexity int, input *model.NewUser) int
		DeleteAnnouncement    func(childComplexity int, id uint) int
		DeleteBank            func(childComplexity int, id uint) int
		DeleteDomain          func(childComplexity int, id uint) int
		DeleteEvent           func(childComplexity int, id uint) int
		DeleteGameAPI         func(childComplexity int, id uint) int
		DeleteInbox           func(childComplexity int, id uint) int
		DeleteLog             func(childComplexity int, id uint) int
		DeleteMenu            func(childComplexity int, id uint) int
		DeleteNotification    func(childComplexity int, id uint) int
		DeleteProfile         func(childComplexity int, id uint) int
		DeleteQna             func(childComplexity int, id uint) int
		DeleteSMSApi          func(childComplexity int, id uint) int
		DeleteSetting         func(childComplexity int, id uint) int
		DeleteTransaction     func(childComplexity int, id uint) int
		ReplyQna              func(childComplexity int, id uint, input model.UpdateQnaInput) int
		Time                  func(childComplexity int) int
		UpdateAdminPermission func(childComplexity int, id uint, input model.UpdateAdminPermissionInput) int
		UpdateAnnouncement    func(childComplexity int, id uint, input model.UpdateAnnouncementInput) int
		UpdateBank            func(childComplexity int, id uint, input model.UpdateBankInput) int
		UpdateDomain          func(childComplexity int, id uint, input model.UpdateDomainInput) int
		UpdateEvent           func(childComplexity int, id uint, input model.UpdateEventInput) int
		UpdateGameAPI         func(childComplexity int, id uint, input model.UpdateGameAPIInput) int
		UpdateInbox           func(childComplexity int, id uint, input model.UpdateInboxInput) int
		UpdateMenu            func(childComplexity int, id uint, input model.UpdateMenuInput) int
		UpdateNotification    func(childComplexity int, id uint, input model.UpdateNotificationInput) int
		UpdateProfile         func(childComplexity int, id uint, input model.UpdateProfile) int
		UpdateQna             func(childComplexity int, id uint, input model.UpdateQnaInput) int
		UpdateSMSApi          func(childComplexity int, id uint, input model.UpdateSMSApiInput) int
		UpdateSetting         func(childComplexity int, id uint, input model.UpdateSettingInput) int
		UpdateTransaction     func(childComplexity int, id uint, input model.UpdateTransactionInput) int
		UpdateUser            func(childComplexity int, id uint, input model.UpdateUser) int
		UploadFile            func(childComplexity int, file graphql.Upload) int
		WaitingTransaction    func(childComplexity int, id uint) int
	}

	Notification struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		Domain       func(childComplexity int) int
		DomainID     func(childComplexity int) int
		ID           func(childComplexity int) int
		ImageUpload  func(childComplexity int) int
		Level        func(childComplexity int) int
		MainImage    func(childComplexity int) int
		NoticeType   func(childComplexity int) int
		OrderNum     func(childComplexity int) int
		RegisterDate func(childComplexity int) int
		ShowFrom     func(childComplexity int) int
		ShowTo       func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Views        func(childComplexity int) int
	}

	NotificationList struct {
		Notifications func(childComplexity int) int
		Total         func(childComplexity int) int
	}

	Profile struct {
		AccountNumber func(childComplexity int) int
		AvatarURL     func(childComplexity int) int
		Balance       func(childComplexity int) int
		BankName      func(childComplexity int) int
		Bio           func(childComplexity int) int
		Birthday      func(childComplexity int) int
		Comp          func(childComplexity int) int
		Coupon        func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Favorites     func(childComplexity int) int
		HolderName    func(childComplexity int) int
		ID            func(childComplexity int) int
		LastDeposit   func(childComplexity int) int
		LastWithdraw  func(childComplexity int) int
		Level         func(childComplexity int) int
		Mobile        func(childComplexity int) int
		Name          func(childComplexity int) int
		Nickname      func(childComplexity int) int
		OrderNum      func(childComplexity int) int
		Phone         func(childComplexity int) int
		PhoneVerified func(childComplexity int) int
		Point         func(childComplexity int) int
		Referral      func(childComplexity int) int
		Roll          func(childComplexity int) int
		SocialLinks   func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	Qna struct {
		Answer        func(childComplexity int) int
		AnswerTitle   func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Domain        func(childComplexity int) int
		DomainID      func(childComplexity int) int
		ID            func(childComplexity int) int
		Question      func(childComplexity int) int
		QuestionTitle func(childComplexity int) int
		RepliedAt     func(childComplexity int) int
		Status        func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	QnaList struct {
		Qnas  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Query struct {
		AdminPermissions      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Announcements         func(childComplexity int) int
		ConnectedUsers        func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Domains               func(childComplexity int) int
		Events                func(childComplexity int) int
		FilterUsers           func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetAnnouncements      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetBanks              func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDistributorDetails func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDistributors       func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetDomains            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetEvents             func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetGameApis           func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetInboxes            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetLogs               func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetMenus              func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetNotifications      func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetQnas               func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetSMSApis            func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetSetting            func(childComplexity int) int
		GetTransactions       func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		GetUserMenus          func(childComplexity int) int
		GetWeeklyLosingData   func(childComplexity int, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) int
		Logs                  func(childComplexity int) int
		Me                    func(childComplexity int) int
		Notifications         func(childComplexity int) int
		Profile               func(childComplexity int) int
		Time                  func(childComplexity int) int
		Todos                 func(childComplexity int) int
		TopEvents             func(childComplexity int) int
		User                  func(childComplexity int, id uint) int
		Users                 func(childComplexity int) int
	}

	SMSApi struct {
		Agent     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		OrderNum  func(childComplexity int) int
		Password  func(childComplexity int) int
		Status    func(childComplexity int) int
		Token     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		Url       func(childComplexity int) int
	}

	SMSApiList struct {
		SmsApis func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Setting struct {
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		OrderNum      func(childComplexity int) int
		PrimaryDomain func(childComplexity int) int
		Status        func(childComplexity int) int
		Title         func(childComplexity int) int
		TotalExFrom   func(childComplexity int) int
		TotalExStatus func(childComplexity int) int
		TotalExTo     func(childComplexity int) int
		TotalReFrom   func(childComplexity int) int
		TotalReStatus func(childComplexity int) int
		TotalReTo     func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserExFrom    func(childComplexity int) int
		UserExStatus  func(childComplexity int) int
		UserExTo      func(childComplexity int) int
		UserID        func(childComplexity int) int
		UserReFrom    func(childComplexity int) int
		UserReStatus  func(childComplexity int) int
		UserReTo      func(childComplexity int) int
	}

	Subscription struct {
		Time func(childComplexity int) int
	}

	Todo struct {
		Done func(childComplexity int) int
		ID   func(childComplexity int) int
		Text func(childComplexity int) int
		User func(childComplexity int) int
	}

	Transaction struct {
		Amount        func(childComplexity int) int
		ApprovedAt    func(childComplexity int) int
		BalanceAfter  func(childComplexity int) int
		BalanceBefore func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		PointAfter    func(childComplexity int) int
		PointBefore   func(childComplexity int) int
		Shortcut      func(childComplexity int) int
		Status        func(childComplexity int) int
		TransactionAt func(childComplexity int) int
		Type          func(childComplexity int) int
		USDTDesc      func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		User          func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	TransactionList struct {
		Total        func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	User struct {
		BlackMemo               func(childComplexity int) int
		Children                func(childComplexity int) int
		ChildrenCount           func(childComplexity int) int
		CreatedAt               func(childComplexity int) int
		CurrentIP               func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		Device                  func(childComplexity int) int
		EntireLosing            func(childComplexity int) int
		FingerPrint             func(childComplexity int) int
		Hold                    func(childComplexity int) int
		HoldLosingBeDang        func(childComplexity int) int
		HoldemBetting           func(childComplexity int) int
		HoldemWinning           func(childComplexity int) int
		ID                      func(childComplexity int) int
		IP                      func(childComplexity int) int
		Live                    func(childComplexity int) int
		LiveBetting             func(childComplexity int) int
		LiveLosingBeDang        func(childComplexity int) int
		LiveWinning             func(childComplexity int) int
		LosingMethod            func(childComplexity int) int
		LosingRate              func(childComplexity int) int
		LosingSettlement        func(childComplexity int) int
		LotusBetting            func(childComplexity int) int
		LotusLottery            func(childComplexity int) int
		LotusRolling            func(childComplexity int) int
		MembershipDeposit       func(childComplexity int) int
		MembershipWithdrawal    func(childComplexity int) int
		MgmBetting              func(childComplexity int) int
		MgmRolling              func(childComplexity int) int
		MgmWinning              func(childComplexity int) int
		MiniCombinationBetting  func(childComplexity int) int
		MiniCombinationRolling  func(childComplexity int) int
		MiniCombinationWinnings func(childComplexity int) int
		MiniDanpolBetting       func(childComplexity int) int
		MiniDanpolRolling       func(childComplexity int) int
		MiniDanpolWinner        func(childComplexity int) int
		Name                    func(childComplexity int) int
		NumberOfMembers         func(childComplexity int) int
		OS                      func(childComplexity int) int
		OrderNum                func(childComplexity int) int
		Parent                  func(childComplexity int) int
		ParentID                func(childComplexity int) int
		PartnershipMoneyInHand  func(childComplexity int) int
		PartnershipRolling      func(childComplexity int) int
		Profile                 func(childComplexity int) int
		Role                    func(childComplexity int) int
		RollingHoldings         func(childComplexity int) int
		RollingRate             func(childComplexity int) int
		RollingTransition       func(childComplexity int) int
		Root                    func(childComplexity int) int
		RootID                  func(childComplexity int) int
		Slot                    func(childComplexity int) int
		SlotBetting             func(childComplexity int) int
		SlotJackpot             func(childComplexity int) int
		SlotLosingBeDang        func(childComplexity int) int
		Sports3PoleRolling      func(childComplexity int) int
		Sports3poleBetting      func(childComplexity int) int
		Sports3poleWinner       func(childComplexity int) int
		Sports4PoleRolling      func(childComplexity int) int
		Sports4poleBetting      func(childComplexity int) int
		Sports4poleWinner       func(childComplexity int) int
		Sports5PoleRolling      func(childComplexity int) int
		Sports5poleBetting      func(childComplexity int) int
		Sports5poleWinner       func(childComplexity int) int
		SportsDanpolBetting     func(childComplexity int) int
		SportsDanpolRolling     func(childComplexity int) int
		SportsDanpolWinner      func(childComplexity int) int
		SportsDapolBetting      func(childComplexity int) int
		SportsDapolRolling      func(childComplexity int) int
		SportsDapolWinner       func(childComplexity int) int
		SportsDupolBetting      func(childComplexity int) int
		SportsDupolRolling      func(childComplexity int) int
		SportsDupolWinner       func(childComplexity int) int
		Status                  func(childComplexity int) int
		TotalWithdrawal         func(childComplexity int) int
		TouchBetting            func(childComplexity int) int
		TouchRolling            func(childComplexity int) int
		TouchWinning            func(childComplexity int) int
		Type                    func(childComplexity int) int
		USDTAddress             func(childComplexity int) int
		UpdatedAt               func(childComplexity int) int
		Userid                  func(childComplexity int) int
		VirtualGameBetting      func(childComplexity int) int
		VirtualGameRolling      func(childComplexity int) int
		VirtualGameWinnings     func(childComplexity int) int
	}

	UserList struct {
		Total func(childComplexity int) int
		Users func(childComplexity int) int
	}

	WeeklyLosingData struct {
		Alias            func(childComplexity int) int
		ApplicationDate  func(childComplexity int) int
		Depositor        func(childComplexity int) int
		DistributorID    func(childComplexity int) int
		DistributorLevel func(childComplexity int) int
		DistributorName  func(childComplexity int) int
		Nickname         func(childComplexity int) int
		ProcessingDate   func(childComplexity int) int
		SettlementAmount func(childComplexity int) int
		Site             func(childComplexity int) int
		Situation        func(childComplexity int) int
		TotalBet         func(childComplexity int) int
		TotalLosingMoney func(childComplexity int) int
		TotalWinner      func(childComplexity int) int
		UserCount        func(childComplexity int) int
		WeekEnd          func(childComplexity int) int
		WeekStart        func(childComplexity int) int
	}

	WeeklyLosingDataList struct {
		Total            func(childComplexity int) int
		WeeklyLosingData func(childComplexity int) int
	}
}

type AnnouncementResolver interface {
	ShowFrom(ctx context.Context, obj *models.Announcement) (*time.Time, error)
	ShowTo(ctx context.Context, obj *models.Announcement) (*time.Time, error)
}
type LogResolver interface {
	DeletedAt(ctx context.Context, obj *models.Log) (*gorm.DeletedAt, error)
}
type MutationResolver interface {
	Time(ctx context.Context) (*time.Time, error)
	UploadFile(ctx context.Context, file graphql.Upload) (string, error)
	CreateAdminPermission(ctx context.Context, input model.NewAdminPermission) (*models.AdminPermission, error)
	UpdateAdminPermission(ctx context.Context, id uint, input model.UpdateAdminPermissionInput) (*models.AdminPermission, error)
	CreateAnnouncement(ctx context.Context, input model.NewAnnouncementInput) (*models.Announcement, error)
	UpdateAnnouncement(ctx context.Context, id uint, input model.UpdateAnnouncementInput) (*models.Announcement, error)
	DeleteAnnouncement(ctx context.Context, id uint) (bool, error)
	CreateBank(ctx context.Context, input model.NewBankInput) (*models.Bank, error)
	UpdateBank(ctx context.Context, id uint, input model.UpdateBankInput) (*models.Bank, error)
	DeleteBank(ctx context.Context, id uint) (bool, error)
	CreateDomain(ctx context.Context, input model.NewDomainInput) (*models.Domain, error)
	UpdateDomain(ctx context.Context, id uint, input model.UpdateDomainInput) (*models.Domain, error)
	DeleteDomain(ctx context.Context, id uint) (bool, error)
	CreateEvent(ctx context.Context, input model.NewEventInput) (*models.Event, error)
	UpdateEvent(ctx context.Context, id uint, input model.UpdateEventInput) (*models.Event, error)
	DeleteEvent(ctx context.Context, id uint) (bool, error)
	CreateGameAPI(ctx context.Context, input model.NewGameAPIInput) (*model.GameAPI, error)
	UpdateGameAPI(ctx context.Context, id uint, input model.UpdateGameAPIInput) (*model.GameAPI, error)
	DeleteGameAPI(ctx context.Context, id uint) (bool, error)
	CreateInbox(ctx context.Context, input model.NewInboxInput) (*models.Inbox, error)
	UpdateInbox(ctx context.Context, id uint, input model.UpdateInboxInput) (*models.Inbox, error)
	DeleteInbox(ctx context.Context, id uint) (bool, error)
	CreateLog(ctx context.Context, input model.NewLogInput) (*models.Log, error)
	DeleteLog(ctx context.Context, id uint) (bool, error)
	CreateMenu(ctx context.Context, input model.NewMenuInput) (*models.Menu, error)
	UpdateMenu(ctx context.Context, id uint, input model.UpdateMenuInput) (*models.Menu, error)
	DeleteMenu(ctx context.Context, id uint) (bool, error)
	CreateNotification(ctx context.Context, input model.NewNotificationInput) (*models.Notification, error)
	UpdateNotification(ctx context.Context, id uint, input model.UpdateNotificationInput) (*models.Notification, error)
	DeleteNotification(ctx context.Context, id uint) (bool, error)
	CreateQna(ctx context.Context, input model.NewQnaInput) (*models.Qna, error)
	UpdateQna(ctx context.Context, id uint, input model.UpdateQnaInput) (*models.Qna, error)
	ReplyQna(ctx context.Context, id uint, input model.UpdateQnaInput) (*models.Qna, error)
	DeleteQna(ctx context.Context, id uint) (bool, error)
	CompleteQna(ctx context.Context, id uint) (bool, error)
	CreateSetting(ctx context.Context, input model.NewSettingInput) (*model.Setting, error)
	UpdateSetting(ctx context.Context, id uint, input model.UpdateSettingInput) (*model.Setting, error)
	DeleteSetting(ctx context.Context, id uint) (bool, error)
	CreateSMSApi(ctx context.Context, input model.NewSMSApiInput) (*models.SMSApi, error)
	UpdateSMSApi(ctx context.Context, id uint, input model.UpdateSMSApiInput) (*models.SMSApi, error)
	DeleteSMSApi(ctx context.Context, id uint) (bool, error)
	CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error)
	CreateTransaction(ctx context.Context, input model.NewTransactionInput) (*models.Transaction, error)
	UpdateTransaction(ctx context.Context, id uint, input model.UpdateTransactionInput) (*models.Transaction, error)
	DeleteTransaction(ctx context.Context, id uint) (bool, error)
	ApproveTransaction(ctx context.Context, id uint) (bool, error)
	BlockTransaction(ctx context.Context, id uint) (bool, error)
	WaitingTransaction(ctx context.Context, id uint) (bool, error)
	CancelTransaction(ctx context.Context, id uint) (bool, error)
	UpdateProfile(ctx context.Context, id uint, input model.UpdateProfile) (*models.Profile, error)
	DeleteProfile(ctx context.Context, id uint) (bool, error)
	CreateUser(ctx context.Context, input *model.NewUser) (bool, error)
	ApproveUser(ctx context.Context, id uint) (bool, error)
	BlockUser(ctx context.Context, id uint) (bool, error)
	UpdateUser(ctx context.Context, id uint, input model.UpdateUser) (bool, error)
}
type NotificationResolver interface {
	ShowFrom(ctx context.Context, obj *models.Notification) (*time.Time, error)

	ShowTo(ctx context.Context, obj *models.Notification) (*time.Time, error)
}
type QueryResolver interface {
	Time(ctx context.Context) (*time.Time, error)
	AdminPermissions(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.AdminPermissionList, error)
	Announcements(ctx context.Context) ([]*models.Announcement, error)
	GetAnnouncements(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.AnnouncementList, error)
	GetBanks(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.BankList, error)
	Domains(ctx context.Context) ([]*models.Domain, error)
	GetDomains(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.DomainList, error)
	TopEvents(ctx context.Context) ([]*models.Event, error)
	Events(ctx context.Context) ([]*models.Event, error)
	GetEvents(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.EventList, error)
	GetGameApis(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.GameAPIList, error)
	GetInboxes(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.InboxList, error)
	Logs(ctx context.Context) ([]*models.Log, error)
	GetLogs(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.LogList, error)
	GetUserMenus(ctx context.Context) ([]*models.Menu, error)
	GetMenus(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.MenuList, error)
	Notifications(ctx context.Context) ([]*models.Notification, error)
	GetNotifications(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.NotificationList, error)
	GetQnas(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.QnaList, error)
	GetSetting(ctx context.Context) (*model.Setting, error)
	GetSMSApis(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.SMSApiList, error)
	Todos(ctx context.Context) ([]*model.Todo, error)
	GetTransactions(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.TransactionList, error)
	GetWeeklyLosingData(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.WeeklyLosingDataList, error)
	Profile(ctx context.Context) (*models.Profile, error)
	Me(ctx context.Context) (*models.User, error)
	Users(ctx context.Context) ([]*models.User, error)
	FilterUsers(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	ConnectedUsers(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	User(ctx context.Context, id uint) (*models.User, error)
	GetDistributors(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
	GetDistributorDetails(ctx context.Context, filters []*model.Filter, orders []*model.Order, pagination *model.Pagination) (*model.UserList, error)
}
type SubscriptionResolver interface {
	Time(ctx context.Context) (<-chan string, error)
}
type UserResolver interface {
	Type(ctx context.Context, obj *models.User) (model.UserType, error)

	Status(ctx context.Context, obj *models.User) (model.UserStatus, error)

	NumberOfMembers(ctx context.Context, obj *models.User) (*int32, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AdminPermission.createdAt":
		if e.complexity.AdminPermission.CreatedAt == nil {
			break
		}

		return e.complexity.AdminPermission.CreatedAt(childComplexity), true

	case "AdminPermission.deletedAt":
		if e.complexity.AdminPermission.DeletedAt == nil {
			break
		}

		return e.complexity.AdminPermission.DeletedAt(childComplexity), true

	case "AdminPermission.dwdelete":
		if e.complexity.AdminPermission.Dwdelete == nil {
			break
		}

		return e.complexity.AdminPermission.Dwdelete(childComplexity), true

	case "AdminPermission.financials":
		if e.complexity.AdminPermission.Financials == nil {
			break
		}

		return e.complexity.AdminPermission.Financials(childComplexity), true

	case "AdminPermission.game":
		if e.complexity.AdminPermission.Game == nil {
			break
		}

		return e.complexity.AdminPermission.Game(childComplexity), true

	case "AdminPermission.id":
		if e.complexity.AdminPermission.ID == nil {
			break
		}

		return e.complexity.AdminPermission.ID(childComplexity), true

	case "AdminPermission.ip":
		if e.complexity.AdminPermission.IP == nil {
			break
		}

		return e.complexity.AdminPermission.IP(childComplexity), true

	case "AdminPermission.membership":
		if e.complexity.AdminPermission.Membership == nil {
			break
		}

		return e.complexity.AdminPermission.Membership(childComplexity), true

	case "AdminPermission.qna":
		if e.complexity.AdminPermission.Qna == nil {
			break
		}

		return e.complexity.AdminPermission.Qna(childComplexity), true

	case "AdminPermission.sale":
		if e.complexity.AdminPermission.Sale == nil {
			break
		}

		return e.complexity.AdminPermission.Sale(childComplexity), true

	case "AdminPermission.settlement":
		if e.complexity.AdminPermission.Settlement == nil {
			break
		}

		return e.complexity.AdminPermission.Settlement(childComplexity), true

	case "AdminPermission.statistical":
		if e.complexity.AdminPermission.Statistical == nil {
			break
		}

		return e.complexity.AdminPermission.Statistical(childComplexity), true

	case "AdminPermission.status":
		if e.complexity.AdminPermission.Status == nil {
			break
		}

		return e.complexity.AdminPermission.Status(childComplexity), true

	case "AdminPermission.updatedAt":
		if e.complexity.AdminPermission.UpdatedAt == nil {
			break
		}

		return e.complexity.AdminPermission.UpdatedAt(childComplexity), true

	case "AdminPermission.user":
		if e.complexity.AdminPermission.User == nil {
			break
		}

		return e.complexity.AdminPermission.User(childComplexity), true

	case "AdminPermission.userId":
		if e.complexity.AdminPermission.UserID == nil {
			break
		}

		return e.complexity.AdminPermission.UserID(childComplexity), true

	case "AdminPermissionList.adminPermissions":
		if e.complexity.AdminPermissionList.AdminPermissions == nil {
			break
		}

		return e.complexity.AdminPermissionList.AdminPermissions(childComplexity), true

	case "AdminPermissionList.total":
		if e.complexity.AdminPermissionList.Total == nil {
			break
		}

		return e.complexity.AdminPermissionList.Total(childComplexity), true

	case "Announcement.createdAt":
		if e.complexity.Announcement.CreatedAt == nil {
			break
		}

		return e.complexity.Announcement.CreatedAt(childComplexity), true

	case "Announcement.deletedAt":
		if e.complexity.Announcement.DeletedAt == nil {
			break
		}

		return e.complexity.Announcement.DeletedAt(childComplexity), true

	case "Announcement.description":
		if e.complexity.Announcement.Description == nil {
			break
		}

		return e.complexity.Announcement.Description(childComplexity), true

	case "Announcement.id":
		if e.complexity.Announcement.ID == nil {
			break
		}

		return e.complexity.Announcement.ID(childComplexity), true

	case "Announcement.orderNum":
		if e.complexity.Announcement.OrderNum == nil {
			break
		}

		return e.complexity.Announcement.OrderNum(childComplexity), true

	case "Announcement.showFrom":
		if e.complexity.Announcement.ShowFrom == nil {
			break
		}

		return e.complexity.Announcement.ShowFrom(childComplexity), true

	case "Announcement.showTo":
		if e.complexity.Announcement.ShowTo == nil {
			break
		}

		return e.complexity.Announcement.ShowTo(childComplexity), true

	case "Announcement.status":
		if e.complexity.Announcement.Status == nil {
			break
		}

		return e.complexity.Announcement.Status(childComplexity), true

	case "Announcement.title":
		if e.complexity.Announcement.Title == nil {
			break
		}

		return e.complexity.Announcement.Title(childComplexity), true

	case "Announcement.updatedAt":
		if e.complexity.Announcement.UpdatedAt == nil {
			break
		}

		return e.complexity.Announcement.UpdatedAt(childComplexity), true

	case "Announcement.user":
		if e.complexity.Announcement.User == nil {
			break
		}

		return e.complexity.Announcement.User(childComplexity), true

	case "Announcement.userId":
		if e.complexity.Announcement.UserID == nil {
			break
		}

		return e.complexity.Announcement.UserID(childComplexity), true

	case "AnnouncementList.announcements":
		if e.complexity.AnnouncementList.Announcements == nil {
			break
		}

		return e.complexity.AnnouncementList.Announcements(childComplexity), true

	case "AnnouncementList.total":
		if e.complexity.AnnouncementList.Total == nil {
			break
		}

		return e.complexity.AnnouncementList.Total(childComplexity), true

	case "Bank.createdAt":
		if e.complexity.Bank.CreatedAt == nil {
			break
		}

		return e.complexity.Bank.CreatedAt(childComplexity), true

	case "Bank.deletedAt":
		if e.complexity.Bank.DeletedAt == nil {
			break
		}

		return e.complexity.Bank.DeletedAt(childComplexity), true

	case "Bank.id":
		if e.complexity.Bank.ID == nil {
			break
		}

		return e.complexity.Bank.ID(childComplexity), true

	case "Bank.name":
		if e.complexity.Bank.Name == nil {
			break
		}

		return e.complexity.Bank.Name(childComplexity), true

	case "Bank.orderNum":
		if e.complexity.Bank.OrderNum == nil {
			break
		}

		return e.complexity.Bank.OrderNum(childComplexity), true

	case "Bank.status":
		if e.complexity.Bank.Status == nil {
			break
		}

		return e.complexity.Bank.Status(childComplexity), true

	case "Bank.updatedAt":
		if e.complexity.Bank.UpdatedAt == nil {
			break
		}

		return e.complexity.Bank.UpdatedAt(childComplexity), true

	case "BankList.banks":
		if e.complexity.BankList.Banks == nil {
			break
		}

		return e.complexity.BankList.Banks(childComplexity), true

	case "BankList.total":
		if e.complexity.BankList.Total == nil {
			break
		}

		return e.complexity.BankList.Total(childComplexity), true

	case "Domain.autoReg":
		if e.complexity.Domain.AutoReg == nil {
			break
		}

		return e.complexity.Domain.AutoReg(childComplexity), true

	case "Domain.createdAt":
		if e.complexity.Domain.CreatedAt == nil {
			break
		}

		return e.complexity.Domain.CreatedAt(childComplexity), true

	case "Domain.deletedAt":
		if e.complexity.Domain.DeletedAt == nil {
			break
		}

		return e.complexity.Domain.DeletedAt(childComplexity), true

	case "Domain.description":
		if e.complexity.Domain.Description == nil {
			break
		}

		return e.complexity.Domain.Description(childComplexity), true

	case "Domain.distributorLevel":
		if e.complexity.Domain.DistributorLevel == nil {
			break
		}

		return e.complexity.Domain.DistributorLevel(childComplexity), true

	case "Domain.id":
		if e.complexity.Domain.ID == nil {
			break
		}

		return e.complexity.Domain.ID(childComplexity), true

	case "Domain.kakaoTalk":
		if e.complexity.Domain.KakaoTalk == nil {
			break
		}

		return e.complexity.Domain.KakaoTalk(childComplexity), true

	case "Domain.kakaoTalkLink":
		if e.complexity.Domain.KakaoTalkLink == nil {
			break
		}

		return e.complexity.Domain.KakaoTalkLink(childComplexity), true

	case "Domain.liveDomain":
		if e.complexity.Domain.LiveDomain == nil {
			break
		}

		return e.complexity.Domain.LiveDomain(childComplexity), true

	case "Domain.liveDomainLink":
		if e.complexity.Domain.LiveDomainLink == nil {
			break
		}

		return e.complexity.Domain.LiveDomainLink(childComplexity), true

	case "Domain.memberLevel":
		if e.complexity.Domain.MemberLevel == nil {
			break
		}

		return e.complexity.Domain.MemberLevel(childComplexity), true

	case "Domain.name":
		if e.complexity.Domain.Name == nil {
			break
		}

		return e.complexity.Domain.Name(childComplexity), true

	case "Domain.orderNum":
		if e.complexity.Domain.OrderNum == nil {
			break
		}

		return e.complexity.Domain.OrderNum(childComplexity), true

	case "Domain.serviceCenter":
		if e.complexity.Domain.ServiceCenter == nil {
			break
		}

		return e.complexity.Domain.ServiceCenter(childComplexity), true

	case "Domain.serviceCenterLink":
		if e.complexity.Domain.ServiceCenterLink == nil {
			break
		}

		return e.complexity.Domain.ServiceCenterLink(childComplexity), true

	case "Domain.status":
		if e.complexity.Domain.Status == nil {
			break
		}

		return e.complexity.Domain.Status(childComplexity), true

	case "Domain.telegram":
		if e.complexity.Domain.Telegram == nil {
			break
		}

		return e.complexity.Domain.Telegram(childComplexity), true

	case "Domain.telegramLink":
		if e.complexity.Domain.TelegramLink == nil {
			break
		}

		return e.complexity.Domain.TelegramLink(childComplexity), true

	case "Domain.updatedAt":
		if e.complexity.Domain.UpdatedAt == nil {
			break
		}

		return e.complexity.Domain.UpdatedAt(childComplexity), true

	case "Domain.useKakaoTalk":
		if e.complexity.Domain.UseKakaoTalk == nil {
			break
		}

		return e.complexity.Domain.UseKakaoTalk(childComplexity), true

	case "Domain.useLiveDomain":
		if e.complexity.Domain.UseLiveDomain == nil {
			break
		}

		return e.complexity.Domain.UseLiveDomain(childComplexity), true

	case "Domain.useServiceCenter":
		if e.complexity.Domain.UseServiceCenter == nil {
			break
		}

		return e.complexity.Domain.UseServiceCenter(childComplexity), true

	case "Domain.useTelegram":
		if e.complexity.Domain.UseTelegram == nil {
			break
		}

		return e.complexity.Domain.UseTelegram(childComplexity), true

	case "Domain.user":
		if e.complexity.Domain.User == nil {
			break
		}

		return e.complexity.Domain.User(childComplexity), true

	case "Domain.userId":
		if e.complexity.Domain.UserID == nil {
			break
		}

		return e.complexity.Domain.UserID(childComplexity), true

	case "DomainList.domains":
		if e.complexity.DomainList.Domains == nil {
			break
		}

		return e.complexity.DomainList.Domains(childComplexity), true

	case "DomainList.total":
		if e.complexity.DomainList.Total == nil {
			break
		}

		return e.complexity.DomainList.Total(childComplexity), true

	case "Event.category":
		if e.complexity.Event.Category == nil {
			break
		}

		return e.complexity.Event.Category(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.createdDate":
		if e.complexity.Event.CreatedDate == nil {
			break
		}

		return e.complexity.Event.CreatedDate(childComplexity), true

	case "Event.deletedAt":
		if e.complexity.Event.DeletedAt == nil {
			break
		}

		return e.complexity.Event.DeletedAt(childComplexity), true

	case "Event.description":
		if e.complexity.Event.Description == nil {
			break
		}

		return e.complexity.Event.Description(childComplexity), true

	case "Event.domain":
		if e.complexity.Event.Domain == nil {
			break
		}

		return e.complexity.Event.Domain(childComplexity), true

	case "Event.domainId":
		if e.complexity.Event.DomainID == nil {
			break
		}

		return e.complexity.Event.DomainID(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.imageUpload":
		if e.complexity.Event.ImageUpload == nil {
			break
		}

		return e.complexity.Event.ImageUpload(childComplexity), true

	case "Event.level":
		if e.complexity.Event.Level == nil {
			break
		}

		return e.complexity.Event.Level(childComplexity), true

	case "Event.mainImage":
		if e.complexity.Event.MainImage == nil {
			break
		}

		return e.complexity.Event.MainImage(childComplexity), true

	case "Event.orderNum":
		if e.complexity.Event.OrderNum == nil {
			break
		}

		return e.complexity.Event.OrderNum(childComplexity), true

	case "Event.showFrom":
		if e.complexity.Event.ShowFrom == nil {
			break
		}

		return e.complexity.Event.ShowFrom(childComplexity), true

	case "Event.showTo":
		if e.complexity.Event.ShowTo == nil {
			break
		}

		return e.complexity.Event.ShowTo(childComplexity), true

	case "Event.status":
		if e.complexity.Event.Status == nil {
			break
		}

		return e.complexity.Event.Status(childComplexity), true

	case "Event.title":
		if e.complexity.Event.Title == nil {
			break
		}

		return e.complexity.Event.Title(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "Event.user":
		if e.complexity.Event.User == nil {
			break
		}

		return e.complexity.Event.User(childComplexity), true

	case "Event.userId":
		if e.complexity.Event.UserID == nil {
			break
		}

		return e.complexity.Event.UserID(childComplexity), true

	case "Event.views":
		if e.complexity.Event.Views == nil {
			break
		}

		return e.complexity.Event.Views(childComplexity), true

	case "EventList.events":
		if e.complexity.EventList.Events == nil {
			break
		}

		return e.complexity.EventList.Events(childComplexity), true

	case "EventList.total":
		if e.complexity.EventList.Total == nil {
			break
		}

		return e.complexity.EventList.Total(childComplexity), true

	case "GameAPI.apiCompanyName":
		if e.complexity.GameAPI.APICompanyName == nil {
			break
		}

		return e.complexity.GameAPI.APICompanyName(childComplexity), true

	case "GameAPI.createdAt":
		if e.complexity.GameAPI.CreatedAt == nil {
			break
		}

		return e.complexity.GameAPI.CreatedAt(childComplexity), true

	case "GameAPI.deletedAt":
		if e.complexity.GameAPI.DeletedAt == nil {
			break
		}

		return e.complexity.GameAPI.DeletedAt(childComplexity), true

	case "GameAPI.gameApiName":
		if e.complexity.GameAPI.GameAPIName == nil {
			break
		}

		return e.complexity.GameAPI.GameAPIName(childComplexity), true

	case "GameAPI.gameCompanyName":
		if e.complexity.GameAPI.GameCompanyName == nil {
			break
		}

		return e.complexity.GameAPI.GameCompanyName(childComplexity), true

	case "GameAPI.gameType":
		if e.complexity.GameAPI.GameType == nil {
			break
		}

		return e.complexity.GameAPI.GameType(childComplexity), true

	case "GameAPI.id":
		if e.complexity.GameAPI.ID == nil {
			break
		}

		return e.complexity.GameAPI.ID(childComplexity), true

	case "GameAPI.order":
		if e.complexity.GameAPI.Order == nil {
			break
		}

		return e.complexity.GameAPI.Order(childComplexity), true

	case "GameAPI.other":
		if e.complexity.GameAPI.Other == nil {
			break
		}

		return e.complexity.GameAPI.Other(childComplexity), true

	case "GameAPI.type":
		if e.complexity.GameAPI.Type == nil {
			break
		}

		return e.complexity.GameAPI.Type(childComplexity), true

	case "GameAPI.updatedAt":
		if e.complexity.GameAPI.UpdatedAt == nil {
			break
		}

		return e.complexity.GameAPI.UpdatedAt(childComplexity), true

	case "GameAPI.whetherToUse":
		if e.complexity.GameAPI.WhetherToUse == nil {
			break
		}

		return e.complexity.GameAPI.WhetherToUse(childComplexity), true

	case "GameAPIList.gameApis":
		if e.complexity.GameAPIList.GameApis == nil {
			break
		}

		return e.complexity.GameAPIList.GameApis(childComplexity), true

	case "GameAPIList.total":
		if e.complexity.GameAPIList.Total == nil {
			break
		}

		return e.complexity.GameAPIList.Total(childComplexity), true

	case "Inbox.createdAt":
		if e.complexity.Inbox.CreatedAt == nil {
			break
		}

		return e.complexity.Inbox.CreatedAt(childComplexity), true

	case "Inbox.deletedAt":
		if e.complexity.Inbox.DeletedAt == nil {
			break
		}

		return e.complexity.Inbox.DeletedAt(childComplexity), true

	case "Inbox.description":
		if e.complexity.Inbox.Description == nil {
			break
		}

		return e.complexity.Inbox.Description(childComplexity), true

	case "Inbox.fromId":
		if e.complexity.Inbox.FromID == nil {
			break
		}

		return e.complexity.Inbox.FromID(childComplexity), true

	case "Inbox.FromUser":
		if e.complexity.Inbox.FromUser == nil {
			break
		}

		return e.complexity.Inbox.FromUser(childComplexity), true

	case "Inbox.id":
		if e.complexity.Inbox.ID == nil {
			break
		}

		return e.complexity.Inbox.ID(childComplexity), true

	case "Inbox.openedAt":
		if e.complexity.Inbox.OpenedAt == nil {
			break
		}

		return e.complexity.Inbox.OpenedAt(childComplexity), true

	case "Inbox.orderNum":
		if e.complexity.Inbox.OrderNum == nil {
			break
		}

		return e.complexity.Inbox.OrderNum(childComplexity), true

	case "Inbox.status":
		if e.complexity.Inbox.Status == nil {
			break
		}

		return e.complexity.Inbox.Status(childComplexity), true

	case "Inbox.title":
		if e.complexity.Inbox.Title == nil {
			break
		}

		return e.complexity.Inbox.Title(childComplexity), true

	case "Inbox.type":
		if e.complexity.Inbox.Type == nil {
			break
		}

		return e.complexity.Inbox.Type(childComplexity), true

	case "Inbox.updatedAt":
		if e.complexity.Inbox.UpdatedAt == nil {
			break
		}

		return e.complexity.Inbox.UpdatedAt(childComplexity), true

	case "Inbox.user":
		if e.complexity.Inbox.User == nil {
			break
		}

		return e.complexity.Inbox.User(childComplexity), true

	case "Inbox.userId":
		if e.complexity.Inbox.UserID == nil {
			break
		}

		return e.complexity.Inbox.UserID(childComplexity), true

	case "InboxList.inboxes":
		if e.complexity.InboxList.Inboxes == nil {
			break
		}

		return e.complexity.InboxList.Inboxes(childComplexity), true

	case "InboxList.total":
		if e.complexity.InboxList.Total == nil {
			break
		}

		return e.complexity.InboxList.Total(childComplexity), true

	case "Log.createdAt":
		if e.complexity.Log.CreatedAt == nil {
			break
		}

		return e.complexity.Log.CreatedAt(childComplexity), true

	case "Log.data":
		if e.complexity.Log.Data == nil {
			break
		}

		return e.complexity.Log.Data(childComplexity), true

	case "Log.deletedAt":
		if e.complexity.Log.DeletedAt == nil {
			break
		}

		return e.complexity.Log.DeletedAt(childComplexity), true

	case "Log.device":
		if e.complexity.Log.Device == nil {
			break
		}

		return e.complexity.Log.Device(childComplexity), true

	case "Log.host":
		if e.complexity.Log.Host == nil {
			break
		}

		return e.complexity.Log.Host(childComplexity), true

	case "Log.id":
		if e.complexity.Log.ID == nil {
			break
		}

		return e.complexity.Log.ID(childComplexity), true

	case "Log.ip":
		if e.complexity.Log.IP == nil {
			break
		}

		return e.complexity.Log.IP(childComplexity), true

	case "Log.method":
		if e.complexity.Log.Method == nil {
			break
		}

		return e.complexity.Log.Method(childComplexity), true

	case "Log.os":
		if e.complexity.Log.OS == nil {
			break
		}

		return e.complexity.Log.OS(childComplexity), true

	case "Log.path":
		if e.complexity.Log.Path == nil {
			break
		}

		return e.complexity.Log.Path(childComplexity), true

	case "Log.phone":
		if e.complexity.Log.Phone == nil {
			break
		}

		return e.complexity.Log.Phone(childComplexity), true

	case "Log.status":
		if e.complexity.Log.Status == nil {
			break
		}

		return e.complexity.Log.Status(childComplexity), true

	case "Log.type":
		if e.complexity.Log.Type == nil {
			break
		}

		return e.complexity.Log.Type(childComplexity), true

	case "Log.updatedAt":
		if e.complexity.Log.UpdatedAt == nil {
			break
		}

		return e.complexity.Log.UpdatedAt(childComplexity), true

	case "Log.user":
		if e.complexity.Log.User == nil {
			break
		}

		return e.complexity.Log.User(childComplexity), true

	case "Log.userId":
		if e.complexity.Log.UserID == nil {
			break
		}

		return e.complexity.Log.UserID(childComplexity), true

	case "LogList.logs":
		if e.complexity.LogList.Logs == nil {
			break
		}

		return e.complexity.LogList.Logs(childComplexity), true

	case "LogList.total":
		if e.complexity.LogList.Total == nil {
			break
		}

		return e.complexity.LogList.Total(childComplexity), true

	case "Menu.children":
		if e.complexity.Menu.Children == nil {
			break
		}

		return e.complexity.Menu.Children(childComplexity), true

	case "Menu.createdAt":
		if e.complexity.Menu.CreatedAt == nil {
			break
		}

		return e.complexity.Menu.CreatedAt(childComplexity), true

	case "Menu.deletedAt":
		if e.complexity.Menu.DeletedAt == nil {
			break
		}

		return e.complexity.Menu.DeletedAt(childComplexity), true

	case "Menu.description":
		if e.complexity.Menu.Description == nil {
			break
		}

		return e.complexity.Menu.Description(childComplexity), true

	case "Menu.id":
		if e.complexity.Menu.ID == nil {
			break
		}

		return e.complexity.Menu.ID(childComplexity), true

	case "Menu.icon":
		if e.complexity.Menu.Icon == nil {
			break
		}

		return e.complexity.Menu.Icon(childComplexity), true

	case "Menu.key":
		if e.complexity.Menu.Key == nil {
			break
		}

		return e.complexity.Menu.Key(childComplexity), true

	case "Menu.label":
		if e.complexity.Menu.Label == nil {
			break
		}

		return e.complexity.Menu.Label(childComplexity), true

	case "Menu.orderNum":
		if e.complexity.Menu.OrderNum == nil {
			break
		}

		return e.complexity.Menu.OrderNum(childComplexity), true

	case "Menu.parentId":
		if e.complexity.Menu.ParentID == nil {
			break
		}

		return e.complexity.Menu.ParentID(childComplexity), true

	case "Menu.path":
		if e.complexity.Menu.Path == nil {
			break
		}

		return e.complexity.Menu.Path(childComplexity), true

	case "Menu.status":
		if e.complexity.Menu.Status == nil {
			break
		}

		return e.complexity.Menu.Status(childComplexity), true

	case "Menu.updatedAt":
		if e.complexity.Menu.UpdatedAt == nil {
			break
		}

		return e.complexity.Menu.UpdatedAt(childComplexity), true

	case "MenuList.menus":
		if e.complexity.MenuList.Menus == nil {
			break
		}

		return e.complexity.MenuList.Menus(childComplexity), true

	case "MenuList.total":
		if e.complexity.MenuList.Total == nil {
			break
		}

		return e.complexity.MenuList.Total(childComplexity), true

	case "Mutation.approveTransaction":
		if e.complexity.Mutation.ApproveTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_approveTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.approveUser":
		if e.complexity.Mutation.ApproveUser == nil {
			break
		}

		args, err := ec.field_Mutation_approveUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveUser(childComplexity, args["id"].(uint)), true

	case "Mutation.blockTransaction":
		if e.complexity.Mutation.BlockTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_blockTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BlockTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.blockUser":
		if e.complexity.Mutation.BlockUser == nil {
			break
		}

		args, err := ec.field_Mutation_blockUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BlockUser(childComplexity, args["id"].(uint)), true

	case "Mutation.cancelTransaction":
		if e.complexity.Mutation.CancelTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_cancelTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.completeQna":
		if e.complexity.Mutation.CompleteQna == nil {
			break
		}

		args, err := ec.field_Mutation_completeQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CompleteQna(childComplexity, args["id"].(uint)), true

	case "Mutation.createAdminPermission":
		if e.complexity.Mutation.CreateAdminPermission == nil {
			break
		}

		args, err := ec.field_Mutation_createAdminPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAdminPermission(childComplexity, args["input"].(model.NewAdminPermission)), true

	case "Mutation.createAnnouncement":
		if e.complexity.Mutation.CreateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_createAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAnnouncement(childComplexity, args["input"].(model.NewAnnouncementInput)), true

	case "Mutation.createBank":
		if e.complexity.Mutation.CreateBank == nil {
			break
		}

		args, err := ec.field_Mutation_createBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBank(childComplexity, args["input"].(model.NewBankInput)), true

	case "Mutation.createDomain":
		if e.complexity.Mutation.CreateDomain == nil {
			break
		}

		args, err := ec.field_Mutation_createDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDomain(childComplexity, args["input"].(model.NewDomainInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(model.NewEventInput)), true

	case "Mutation.createGameApi":
		if e.complexity.Mutation.CreateGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_createGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGameAPI(childComplexity, args["input"].(model.NewGameAPIInput)), true

	case "Mutation.createInbox":
		if e.complexity.Mutation.CreateInbox == nil {
			break
		}

		args, err := ec.field_Mutation_createInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateInbox(childComplexity, args["input"].(model.NewInboxInput)), true

	case "Mutation.createLog":
		if e.complexity.Mutation.CreateLog == nil {
			break
		}

		args, err := ec.field_Mutation_createLog_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLog(childComplexity, args["input"].(model.NewLogInput)), true

	case "Mutation.createMenu":
		if e.complexity.Mutation.CreateMenu == nil {
			break
		}

		args, err := ec.field_Mutation_createMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMenu(childComplexity, args["input"].(model.NewMenuInput)), true

	case "Mutation.createNotification":
		if e.complexity.Mutation.CreateNotification == nil {
			break
		}

		args, err := ec.field_Mutation_createNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNotification(childComplexity, args["input"].(model.NewNotificationInput)), true

	case "Mutation.createQna":
		if e.complexity.Mutation.CreateQna == nil {
			break
		}

		args, err := ec.field_Mutation_createQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQna(childComplexity, args["input"].(model.NewQnaInput)), true

	case "Mutation.createSMSApi":
		if e.complexity.Mutation.CreateSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_createSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSMSApi(childComplexity, args["input"].(model.NewSMSApiInput)), true

	case "Mutation.createSetting":
		if e.complexity.Mutation.CreateSetting == nil {
			break
		}

		args, err := ec.field_Mutation_createSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSetting(childComplexity, args["input"].(model.NewSettingInput)), true

	case "Mutation.createTodo":
		if e.complexity.Mutation.CreateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_createTodo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTodo(childComplexity, args["input"].(model.NewTodo)), true

	case "Mutation.createTransaction":
		if e.complexity.Mutation.CreateTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_createTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransaction(childComplexity, args["input"].(model.NewTransactionInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(*model.NewUser)), true

	case "Mutation.deleteAnnouncement":
		if e.complexity.Mutation.DeleteAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAnnouncement(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteBank":
		if e.complexity.Mutation.DeleteBank == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBank(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteDomain":
		if e.complexity.Mutation.DeleteDomain == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDomain(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteGameApi":
		if e.complexity.Mutation.DeleteGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGameAPI(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteInbox":
		if e.complexity.Mutation.DeleteInbox == nil {
			break
		}

		args, err := ec.field_Mutation_deleteInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteInbox(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteLog":
		if e.complexity.Mutation.DeleteLog == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLog_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLog(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteMenu":
		if e.complexity.Mutation.DeleteMenu == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMenu(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteNotification":
		if e.complexity.Mutation.DeleteNotification == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNotification(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteProfile":
		if e.complexity.Mutation.DeleteProfile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProfile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProfile(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteQna":
		if e.complexity.Mutation.DeleteQna == nil {
			break
		}

		args, err := ec.field_Mutation_deleteQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteQna(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteSMSApi":
		if e.complexity.Mutation.DeleteSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSMSApi(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteSetting":
		if e.complexity.Mutation.DeleteSetting == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSetting(childComplexity, args["id"].(uint)), true

	case "Mutation.deleteTransaction":
		if e.complexity.Mutation.DeleteTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTransaction(childComplexity, args["id"].(uint)), true

	case "Mutation.replyQna":
		if e.complexity.Mutation.ReplyQna == nil {
			break
		}

		args, err := ec.field_Mutation_replyQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReplyQna(childComplexity, args["id"].(uint), args["input"].(model.UpdateQnaInput)), true

	case "Mutation.time":
		if e.complexity.Mutation.Time == nil {
			break
		}

		return e.complexity.Mutation.Time(childComplexity), true

	case "Mutation.updateAdminPermission":
		if e.complexity.Mutation.UpdateAdminPermission == nil {
			break
		}

		args, err := ec.field_Mutation_updateAdminPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAdminPermission(childComplexity, args["id"].(uint), args["input"].(model.UpdateAdminPermissionInput)), true

	case "Mutation.updateAnnouncement":
		if e.complexity.Mutation.UpdateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_updateAnnouncement_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAnnouncement(childComplexity, args["id"].(uint), args["input"].(model.UpdateAnnouncementInput)), true

	case "Mutation.updateBank":
		if e.complexity.Mutation.UpdateBank == nil {
			break
		}

		args, err := ec.field_Mutation_updateBank_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBank(childComplexity, args["id"].(uint), args["input"].(model.UpdateBankInput)), true

	case "Mutation.updateDomain":
		if e.complexity.Mutation.UpdateDomain == nil {
			break
		}

		args, err := ec.field_Mutation_updateDomain_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDomain(childComplexity, args["id"].(uint), args["input"].(model.UpdateDomainInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["id"].(uint), args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateGameApi":
		if e.complexity.Mutation.UpdateGameAPI == nil {
			break
		}

		args, err := ec.field_Mutation_updateGameApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGameAPI(childComplexity, args["id"].(uint), args["input"].(model.UpdateGameAPIInput)), true

	case "Mutation.updateInbox":
		if e.complexity.Mutation.UpdateInbox == nil {
			break
		}

		args, err := ec.field_Mutation_updateInbox_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInbox(childComplexity, args["id"].(uint), args["input"].(model.UpdateInboxInput)), true

	case "Mutation.updateMenu":
		if e.complexity.Mutation.UpdateMenu == nil {
			break
		}

		args, err := ec.field_Mutation_updateMenu_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMenu(childComplexity, args["id"].(uint), args["input"].(model.UpdateMenuInput)), true

	case "Mutation.updateNotification":
		if e.complexity.Mutation.UpdateNotification == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotification(childComplexity, args["id"].(uint), args["input"].(model.UpdateNotificationInput)), true

	case "Mutation.updateProfile":
		if e.complexity.Mutation.UpdateProfile == nil {
			break
		}

		args, err := ec.field_Mutation_updateProfile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProfile(childComplexity, args["id"].(uint), args["input"].(model.UpdateProfile)), true

	case "Mutation.updateQna":
		if e.complexity.Mutation.UpdateQna == nil {
			break
		}

		args, err := ec.field_Mutation_updateQna_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateQna(childComplexity, args["id"].(uint), args["input"].(model.UpdateQnaInput)), true

	case "Mutation.updateSMSApi":
		if e.complexity.Mutation.UpdateSMSApi == nil {
			break
		}

		args, err := ec.field_Mutation_updateSMSApi_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSMSApi(childComplexity, args["id"].(uint), args["input"].(model.UpdateSMSApiInput)), true

	case "Mutation.updateSetting":
		if e.complexity.Mutation.UpdateSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateSetting_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSetting(childComplexity, args["id"].(uint), args["input"].(model.UpdateSettingInput)), true

	case "Mutation.updateTransaction":
		if e.complexity.Mutation.UpdateTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTransaction(childComplexity, args["id"].(uint), args["input"].(model.UpdateTransactionInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(uint), args["input"].(model.UpdateUser)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload)), true

	case "Mutation.waitingTransaction":
		if e.complexity.Mutation.WaitingTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_waitingTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.WaitingTransaction(childComplexity, args["id"].(uint)), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.deletedAt":
		if e.complexity.Notification.DeletedAt == nil {
			break
		}

		return e.complexity.Notification.DeletedAt(childComplexity), true

	case "Notification.description":
		if e.complexity.Notification.Description == nil {
			break
		}

		return e.complexity.Notification.Description(childComplexity), true

	case "Notification.domain":
		if e.complexity.Notification.Domain == nil {
			break
		}

		return e.complexity.Notification.Domain(childComplexity), true

	case "Notification.domainId":
		if e.complexity.Notification.DomainID == nil {
			break
		}

		return e.complexity.Notification.DomainID(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.imageUpload":
		if e.complexity.Notification.ImageUpload == nil {
			break
		}

		return e.complexity.Notification.ImageUpload(childComplexity), true

	case "Notification.level":
		if e.complexity.Notification.Level == nil {
			break
		}

		return e.complexity.Notification.Level(childComplexity), true

	case "Notification.mainImage":
		if e.complexity.Notification.MainImage == nil {
			break
		}

		return e.complexity.Notification.MainImage(childComplexity), true

	case "Notification.noticeType":
		if e.complexity.Notification.NoticeType == nil {
			break
		}

		return e.complexity.Notification.NoticeType(childComplexity), true

	case "Notification.orderNum":
		if e.complexity.Notification.OrderNum == nil {
			break
		}

		return e.complexity.Notification.OrderNum(childComplexity), true

	case "Notification.registerDate":
		if e.complexity.Notification.RegisterDate == nil {
			break
		}

		return e.complexity.Notification.RegisterDate(childComplexity), true

	case "Notification.showFrom":
		if e.complexity.Notification.ShowFrom == nil {
			break
		}

		return e.complexity.Notification.ShowFrom(childComplexity), true

	case "Notification.showTo":
		if e.complexity.Notification.ShowTo == nil {
			break
		}

		return e.complexity.Notification.ShowTo(childComplexity), true

	case "Notification.status":
		if e.complexity.Notification.Status == nil {
			break
		}

		return e.complexity.Notification.Status(childComplexity), true

	case "Notification.title":
		if e.complexity.Notification.Title == nil {
			break
		}

		return e.complexity.Notification.Title(childComplexity), true

	case "Notification.updatedAt":
		if e.complexity.Notification.UpdatedAt == nil {
			break
		}

		return e.complexity.Notification.UpdatedAt(childComplexity), true

	case "Notification.views":
		if e.complexity.Notification.Views == nil {
			break
		}

		return e.complexity.Notification.Views(childComplexity), true

	case "NotificationList.notifications":
		if e.complexity.NotificationList.Notifications == nil {
			break
		}

		return e.complexity.NotificationList.Notifications(childComplexity), true

	case "NotificationList.total":
		if e.complexity.NotificationList.Total == nil {
			break
		}

		return e.complexity.NotificationList.Total(childComplexity), true

	case "Profile.accountNumber":
		if e.complexity.Profile.AccountNumber == nil {
			break
		}

		return e.complexity.Profile.AccountNumber(childComplexity), true

	case "Profile.avatarUrl":
		if e.complexity.Profile.AvatarURL == nil {
			break
		}

		return e.complexity.Profile.AvatarURL(childComplexity), true

	case "Profile.balance":
		if e.complexity.Profile.Balance == nil {
			break
		}

		return e.complexity.Profile.Balance(childComplexity), true

	case "Profile.bankName":
		if e.complexity.Profile.BankName == nil {
			break
		}

		return e.complexity.Profile.BankName(childComplexity), true

	case "Profile.bio":
		if e.complexity.Profile.Bio == nil {
			break
		}

		return e.complexity.Profile.Bio(childComplexity), true

	case "Profile.birthday":
		if e.complexity.Profile.Birthday == nil {
			break
		}

		return e.complexity.Profile.Birthday(childComplexity), true

	case "Profile.comp":
		if e.complexity.Profile.Comp == nil {
			break
		}

		return e.complexity.Profile.Comp(childComplexity), true

	case "Profile.coupon":
		if e.complexity.Profile.Coupon == nil {
			break
		}

		return e.complexity.Profile.Coupon(childComplexity), true

	case "Profile.createdAt":
		if e.complexity.Profile.CreatedAt == nil {
			break
		}

		return e.complexity.Profile.CreatedAt(childComplexity), true

	case "Profile.deletedAt":
		if e.complexity.Profile.DeletedAt == nil {
			break
		}

		return e.complexity.Profile.DeletedAt(childComplexity), true

	case "Profile.favorites":
		if e.complexity.Profile.Favorites == nil {
			break
		}

		return e.complexity.Profile.Favorites(childComplexity), true

	case "Profile.holderName":
		if e.complexity.Profile.HolderName == nil {
			break
		}

		return e.complexity.Profile.HolderName(childComplexity), true

	case "Profile.id":
		if e.complexity.Profile.ID == nil {
			break
		}

		return e.complexity.Profile.ID(childComplexity), true

	case "Profile.lastDeposit":
		if e.complexity.Profile.LastDeposit == nil {
			break
		}

		return e.complexity.Profile.LastDeposit(childComplexity), true

	case "Profile.lastWithdraw":
		if e.complexity.Profile.LastWithdraw == nil {
			break
		}

		return e.complexity.Profile.LastWithdraw(childComplexity), true

	case "Profile.level":
		if e.complexity.Profile.Level == nil {
			break
		}

		return e.complexity.Profile.Level(childComplexity), true

	case "Profile.mobile":
		if e.complexity.Profile.Mobile == nil {
			break
		}

		return e.complexity.Profile.Mobile(childComplexity), true

	case "Profile.name":
		if e.complexity.Profile.Name == nil {
			break
		}

		return e.complexity.Profile.Name(childComplexity), true

	case "Profile.nickname":
		if e.complexity.Profile.Nickname == nil {
			break
		}

		return e.complexity.Profile.Nickname(childComplexity), true

	case "Profile.orderNum":
		if e.complexity.Profile.OrderNum == nil {
			break
		}

		return e.complexity.Profile.OrderNum(childComplexity), true

	case "Profile.phone":
		if e.complexity.Profile.Phone == nil {
			break
		}

		return e.complexity.Profile.Phone(childComplexity), true

	case "Profile.phoneVerified":
		if e.complexity.Profile.PhoneVerified == nil {
			break
		}

		return e.complexity.Profile.PhoneVerified(childComplexity), true

	case "Profile.point":
		if e.complexity.Profile.Point == nil {
			break
		}

		return e.complexity.Profile.Point(childComplexity), true

	case "Profile.referral":
		if e.complexity.Profile.Referral == nil {
			break
		}

		return e.complexity.Profile.Referral(childComplexity), true

	case "Profile.roll":
		if e.complexity.Profile.Roll == nil {
			break
		}

		return e.complexity.Profile.Roll(childComplexity), true

	case "Profile.socialLinks":
		if e.complexity.Profile.SocialLinks == nil {
			break
		}

		return e.complexity.Profile.SocialLinks(childComplexity), true

	case "Profile.updatedAt":
		if e.complexity.Profile.UpdatedAt == nil {
			break
		}

		return e.complexity.Profile.UpdatedAt(childComplexity), true

	case "Profile.userId":
		if e.complexity.Profile.UserID == nil {
			break
		}

		return e.complexity.Profile.UserID(childComplexity), true

	case "Qna.answer":
		if e.complexity.Qna.Answer == nil {
			break
		}

		return e.complexity.Qna.Answer(childComplexity), true

	case "Qna.answerTitle":
		if e.complexity.Qna.AnswerTitle == nil {
			break
		}

		return e.complexity.Qna.AnswerTitle(childComplexity), true

	case "Qna.createdAt":
		if e.complexity.Qna.CreatedAt == nil {
			break
		}

		return e.complexity.Qna.CreatedAt(childComplexity), true

	case "Qna.deletedAt":
		if e.complexity.Qna.DeletedAt == nil {
			break
		}

		return e.complexity.Qna.DeletedAt(childComplexity), true

	case "Qna.domain":
		if e.complexity.Qna.Domain == nil {
			break
		}

		return e.complexity.Qna.Domain(childComplexity), true

	case "Qna.domainId":
		if e.complexity.Qna.DomainID == nil {
			break
		}

		return e.complexity.Qna.DomainID(childComplexity), true

	case "Qna.id":
		if e.complexity.Qna.ID == nil {
			break
		}

		return e.complexity.Qna.ID(childComplexity), true

	case "Qna.question":
		if e.complexity.Qna.Question == nil {
			break
		}

		return e.complexity.Qna.Question(childComplexity), true

	case "Qna.questionTitle":
		if e.complexity.Qna.QuestionTitle == nil {
			break
		}

		return e.complexity.Qna.QuestionTitle(childComplexity), true

	case "Qna.repliedAt":
		if e.complexity.Qna.RepliedAt == nil {
			break
		}

		return e.complexity.Qna.RepliedAt(childComplexity), true

	case "Qna.status":
		if e.complexity.Qna.Status == nil {
			break
		}

		return e.complexity.Qna.Status(childComplexity), true

	case "Qna.type":
		if e.complexity.Qna.Type == nil {
			break
		}

		return e.complexity.Qna.Type(childComplexity), true

	case "Qna.updatedAt":
		if e.complexity.Qna.UpdatedAt == nil {
			break
		}

		return e.complexity.Qna.UpdatedAt(childComplexity), true

	case "Qna.user":
		if e.complexity.Qna.User == nil {
			break
		}

		return e.complexity.Qna.User(childComplexity), true

	case "Qna.userId":
		if e.complexity.Qna.UserID == nil {
			break
		}

		return e.complexity.Qna.UserID(childComplexity), true

	case "QnaList.qnas":
		if e.complexity.QnaList.Qnas == nil {
			break
		}

		return e.complexity.QnaList.Qnas(childComplexity), true

	case "QnaList.total":
		if e.complexity.QnaList.Total == nil {
			break
		}

		return e.complexity.QnaList.Total(childComplexity), true

	case "Query.adminPermissions":
		if e.complexity.Query.AdminPermissions == nil {
			break
		}

		args, err := ec.field_Query_adminPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminPermissions(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.announcements":
		if e.complexity.Query.Announcements == nil {
			break
		}

		return e.complexity.Query.Announcements(childComplexity), true

	case "Query.connectedUsers":
		if e.complexity.Query.ConnectedUsers == nil {
			break
		}

		args, err := ec.field_Query_connectedUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectedUsers(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.domains":
		if e.complexity.Query.Domains == nil {
			break
		}

		return e.complexity.Query.Domains(childComplexity), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		return e.complexity.Query.Events(childComplexity), true

	case "Query.filterUsers":
		if e.complexity.Query.FilterUsers == nil {
			break
		}

		args, err := ec.field_Query_filterUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FilterUsers(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getAnnouncements":
		if e.complexity.Query.GetAnnouncements == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncements_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncements(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getBanks":
		if e.complexity.Query.GetBanks == nil {
			break
		}

		args, err := ec.field_Query_getBanks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBanks(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDistributorDetails":
		if e.complexity.Query.GetDistributorDetails == nil {
			break
		}

		args, err := ec.field_Query_getDistributorDetails_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDistributorDetails(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDistributors":
		if e.complexity.Query.GetDistributors == nil {
			break
		}

		args, err := ec.field_Query_getDistributors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDistributors(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getDomains":
		if e.complexity.Query.GetDomains == nil {
			break
		}

		args, err := ec.field_Query_getDomains_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDomains(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getEvents":
		if e.complexity.Query.GetEvents == nil {
			break
		}

		args, err := ec.field_Query_getEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvents(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getGameApis":
		if e.complexity.Query.GetGameApis == nil {
			break
		}

		args, err := ec.field_Query_getGameApis_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGameApis(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getInboxes":
		if e.complexity.Query.GetInboxes == nil {
			break
		}

		args, err := ec.field_Query_getInboxes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetInboxes(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getLogs":
		if e.complexity.Query.GetLogs == nil {
			break
		}

		args, err := ec.field_Query_getLogs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLogs(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getMenus":
		if e.complexity.Query.GetMenus == nil {
			break
		}

		args, err := ec.field_Query_getMenus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMenus(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getNotifications":
		if e.complexity.Query.GetNotifications == nil {
			break
		}

		args, err := ec.field_Query_getNotifications_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNotifications(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getQnas":
		if e.complexity.Query.GetQnas == nil {
			break
		}

		args, err := ec.field_Query_getQnas_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetQnas(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getSMSApis":
		if e.complexity.Query.GetSMSApis == nil {
			break
		}

		args, err := ec.field_Query_getSMSApis_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMSApis(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getSetting":
		if e.complexity.Query.GetSetting == nil {
			break
		}

		return e.complexity.Query.GetSetting(childComplexity), true

	case "Query.getTransactions":
		if e.complexity.Query.GetTransactions == nil {
			break
		}

		args, err := ec.field_Query_getTransactions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTransactions(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.getUserMenus":
		if e.complexity.Query.GetUserMenus == nil {
			break
		}

		return e.complexity.Query.GetUserMenus(childComplexity), true

	case "Query.getWeeklyLosingData":
		if e.complexity.Query.GetWeeklyLosingData == nil {
			break
		}

		args, err := ec.field_Query_getWeeklyLosingData_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWeeklyLosingData(childComplexity, args["filters"].([]*model.Filter), args["orders"].([]*model.Order), args["pagination"].(*model.Pagination)), true

	case "Query.logs":
		if e.complexity.Query.Logs == nil {
			break
		}

		return e.complexity.Query.Logs(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		return e.complexity.Query.Notifications(childComplexity), true

	case "Query.profile":
		if e.complexity.Query.Profile == nil {
			break
		}

		return e.complexity.Query.Profile(childComplexity), true

	case "Query.time":
		if e.complexity.Query.Time == nil {
			break
		}

		return e.complexity.Query.Time(childComplexity), true

	case "Query.todos":
		if e.complexity.Query.Todos == nil {
			break
		}

		return e.complexity.Query.Todos(childComplexity), true

	case "Query.topEvents":
		if e.complexity.Query.TopEvents == nil {
			break
		}

		return e.complexity.Query.TopEvents(childComplexity), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(uint)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "SMSApi.agent":
		if e.complexity.SMSApi.Agent == nil {
			break
		}

		return e.complexity.SMSApi.Agent(childComplexity), true

	case "SMSApi.createdAt":
		if e.complexity.SMSApi.CreatedAt == nil {
			break
		}

		return e.complexity.SMSApi.CreatedAt(childComplexity), true

	case "SMSApi.deletedAt":
		if e.complexity.SMSApi.DeletedAt == nil {
			break
		}

		return e.complexity.SMSApi.DeletedAt(childComplexity), true

	case "SMSApi.id":
		if e.complexity.SMSApi.ID == nil {
			break
		}

		return e.complexity.SMSApi.ID(childComplexity), true

	case "SMSApi.name":
		if e.complexity.SMSApi.Name == nil {
			break
		}

		return e.complexity.SMSApi.Name(childComplexity), true

	case "SMSApi.orderNum":
		if e.complexity.SMSApi.OrderNum == nil {
			break
		}

		return e.complexity.SMSApi.OrderNum(childComplexity), true

	case "SMSApi.password":
		if e.complexity.SMSApi.Password == nil {
			break
		}

		return e.complexity.SMSApi.Password(childComplexity), true

	case "SMSApi.status":
		if e.complexity.SMSApi.Status == nil {
			break
		}

		return e.complexity.SMSApi.Status(childComplexity), true

	case "SMSApi.token":
		if e.complexity.SMSApi.Token == nil {
			break
		}

		return e.complexity.SMSApi.Token(childComplexity), true

	case "SMSApi.updatedAt":
		if e.complexity.SMSApi.UpdatedAt == nil {
			break
		}

		return e.complexity.SMSApi.UpdatedAt(childComplexity), true

	case "SMSApi.url":
		if e.complexity.SMSApi.Url == nil {
			break
		}

		return e.complexity.SMSApi.Url(childComplexity), true

	case "SMSApiList.smsApis":
		if e.complexity.SMSApiList.SmsApis == nil {
			break
		}

		return e.complexity.SMSApiList.SmsApis(childComplexity), true

	case "SMSApiList.total":
		if e.complexity.SMSApiList.Total == nil {
			break
		}

		return e.complexity.SMSApiList.Total(childComplexity), true

	case "Setting.createdAt":
		if e.complexity.Setting.CreatedAt == nil {
			break
		}

		return e.complexity.Setting.CreatedAt(childComplexity), true

	case "Setting.deletedAt":
		if e.complexity.Setting.DeletedAt == nil {
			break
		}

		return e.complexity.Setting.DeletedAt(childComplexity), true

	case "Setting.description":
		if e.complexity.Setting.Description == nil {
			break
		}

		return e.complexity.Setting.Description(childComplexity), true

	case "Setting.id":
		if e.complexity.Setting.ID == nil {
			break
		}

		return e.complexity.Setting.ID(childComplexity), true

	case "Setting.orderNum":
		if e.complexity.Setting.OrderNum == nil {
			break
		}

		return e.complexity.Setting.OrderNum(childComplexity), true

	case "Setting.primaryDomain":
		if e.complexity.Setting.PrimaryDomain == nil {
			break
		}

		return e.complexity.Setting.PrimaryDomain(childComplexity), true

	case "Setting.status":
		if e.complexity.Setting.Status == nil {
			break
		}

		return e.complexity.Setting.Status(childComplexity), true

	case "Setting.title":
		if e.complexity.Setting.Title == nil {
			break
		}

		return e.complexity.Setting.Title(childComplexity), true

	case "Setting.totalExFrom":
		if e.complexity.Setting.TotalExFrom == nil {
			break
		}

		return e.complexity.Setting.TotalExFrom(childComplexity), true

	case "Setting.totalExStatus":
		if e.complexity.Setting.TotalExStatus == nil {
			break
		}

		return e.complexity.Setting.TotalExStatus(childComplexity), true

	case "Setting.totalExTo":
		if e.complexity.Setting.TotalExTo == nil {
			break
		}

		return e.complexity.Setting.TotalExTo(childComplexity), true

	case "Setting.totalReFrom":
		if e.complexity.Setting.TotalReFrom == nil {
			break
		}

		return e.complexity.Setting.TotalReFrom(childComplexity), true

	case "Setting.totalReStatus":
		if e.complexity.Setting.TotalReStatus == nil {
			break
		}

		return e.complexity.Setting.TotalReStatus(childComplexity), true

	case "Setting.totalReTo":
		if e.complexity.Setting.TotalReTo == nil {
			break
		}

		return e.complexity.Setting.TotalReTo(childComplexity), true

	case "Setting.updatedAt":
		if e.complexity.Setting.UpdatedAt == nil {
			break
		}

		return e.complexity.Setting.UpdatedAt(childComplexity), true

	case "Setting.user":
		if e.complexity.Setting.User == nil {
			break
		}

		return e.complexity.Setting.User(childComplexity), true

	case "Setting.userExFrom":
		if e.complexity.Setting.UserExFrom == nil {
			break
		}

		return e.complexity.Setting.UserExFrom(childComplexity), true

	case "Setting.userExStatus":
		if e.complexity.Setting.UserExStatus == nil {
			break
		}

		return e.complexity.Setting.UserExStatus(childComplexity), true

	case "Setting.userExTo":
		if e.complexity.Setting.UserExTo == nil {
			break
		}

		return e.complexity.Setting.UserExTo(childComplexity), true

	case "Setting.userId":
		if e.complexity.Setting.UserID == nil {
			break
		}

		return e.complexity.Setting.UserID(childComplexity), true

	case "Setting.userReFrom":
		if e.complexity.Setting.UserReFrom == nil {
			break
		}

		return e.complexity.Setting.UserReFrom(childComplexity), true

	case "Setting.userReStatus":
		if e.complexity.Setting.UserReStatus == nil {
			break
		}

		return e.complexity.Setting.UserReStatus(childComplexity), true

	case "Setting.userReTo":
		if e.complexity.Setting.UserReTo == nil {
			break
		}

		return e.complexity.Setting.UserReTo(childComplexity), true

	case "Subscription.time":
		if e.complexity.Subscription.Time == nil {
			break
		}

		return e.complexity.Subscription.Time(childComplexity), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.text":
		if e.complexity.Todo.Text == nil {
			break
		}

		return e.complexity.Todo.Text(childComplexity), true

	case "Todo.user":
		if e.complexity.Todo.User == nil {
			break
		}

		return e.complexity.Todo.User(childComplexity), true

	case "Transaction.amount":
		if e.complexity.Transaction.Amount == nil {
			break
		}

		return e.complexity.Transaction.Amount(childComplexity), true

	case "Transaction.approvedAt":
		if e.complexity.Transaction.ApprovedAt == nil {
			break
		}

		return e.complexity.Transaction.ApprovedAt(childComplexity), true

	case "Transaction.balanceAfter":
		if e.complexity.Transaction.BalanceAfter == nil {
			break
		}

		return e.complexity.Transaction.BalanceAfter(childComplexity), true

	case "Transaction.balanceBefore":
		if e.complexity.Transaction.BalanceBefore == nil {
			break
		}

		return e.complexity.Transaction.BalanceBefore(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.deletedAt":
		if e.complexity.Transaction.DeletedAt == nil {
			break
		}

		return e.complexity.Transaction.DeletedAt(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.pointAfter":
		if e.complexity.Transaction.PointAfter == nil {
			break
		}

		return e.complexity.Transaction.PointAfter(childComplexity), true

	case "Transaction.pointBefore":
		if e.complexity.Transaction.PointBefore == nil {
			break
		}

		return e.complexity.Transaction.PointBefore(childComplexity), true

	case "Transaction.shortcut":
		if e.complexity.Transaction.Shortcut == nil {
			break
		}

		return e.complexity.Transaction.Shortcut(childComplexity), true

	case "Transaction.status":
		if e.complexity.Transaction.Status == nil {
			break
		}

		return e.complexity.Transaction.Status(childComplexity), true

	case "Transaction.transactionAt":
		if e.complexity.Transaction.TransactionAt == nil {
			break
		}

		return e.complexity.Transaction.TransactionAt(childComplexity), true

	case "Transaction.type":
		if e.complexity.Transaction.Type == nil {
			break
		}

		return e.complexity.Transaction.Type(childComplexity), true

	case "Transaction.usdtDesc":
		if e.complexity.Transaction.USDTDesc == nil {
			break
		}

		return e.complexity.Transaction.USDTDesc(childComplexity), true

	case "Transaction.updatedAt":
		if e.complexity.Transaction.UpdatedAt == nil {
			break
		}

		return e.complexity.Transaction.UpdatedAt(childComplexity), true

	case "Transaction.user":
		if e.complexity.Transaction.User == nil {
			break
		}

		return e.complexity.Transaction.User(childComplexity), true

	case "Transaction.userId":
		if e.complexity.Transaction.UserID == nil {
			break
		}

		return e.complexity.Transaction.UserID(childComplexity), true

	case "TransactionList.total":
		if e.complexity.TransactionList.Total == nil {
			break
		}

		return e.complexity.TransactionList.Total(childComplexity), true

	case "TransactionList.transactions":
		if e.complexity.TransactionList.Transactions == nil {
			break
		}

		return e.complexity.TransactionList.Transactions(childComplexity), true

	case "User.blackMemo":
		if e.complexity.User.BlackMemo == nil {
			break
		}

		return e.complexity.User.BlackMemo(childComplexity), true

	case "User.children":
		if e.complexity.User.Children == nil {
			break
		}

		return e.complexity.User.Children(childComplexity), true

	case "User.childrenCount":
		if e.complexity.User.ChildrenCount == nil {
			break
		}

		return e.complexity.User.ChildrenCount(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.currentIP":
		if e.complexity.User.CurrentIP == nil {
			break
		}

		return e.complexity.User.CurrentIP(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.device":
		if e.complexity.User.Device == nil {
			break
		}

		return e.complexity.User.Device(childComplexity), true

	case "User.entireLosing":
		if e.complexity.User.EntireLosing == nil {
			break
		}

		return e.complexity.User.EntireLosing(childComplexity), true

	case "User.fingerPrint":
		if e.complexity.User.FingerPrint == nil {
			break
		}

		return e.complexity.User.FingerPrint(childComplexity), true

	case "User.hold":
		if e.complexity.User.Hold == nil {
			break
		}

		return e.complexity.User.Hold(childComplexity), true

	case "User.holdLosingBeDang":
		if e.complexity.User.HoldLosingBeDang == nil {
			break
		}

		return e.complexity.User.HoldLosingBeDang(childComplexity), true

	case "User.holdemBetting":
		if e.complexity.User.HoldemBetting == nil {
			break
		}

		return e.complexity.User.HoldemBetting(childComplexity), true

	case "User.holdemWinning":
		if e.complexity.User.HoldemWinning == nil {
			break
		}

		return e.complexity.User.HoldemWinning(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.IP":
		if e.complexity.User.IP == nil {
			break
		}

		return e.complexity.User.IP(childComplexity), true

	case "User.live":
		if e.complexity.User.Live == nil {
			break
		}

		return e.complexity.User.Live(childComplexity), true

	case "User.liveBetting":
		if e.complexity.User.LiveBetting == nil {
			break
		}

		return e.complexity.User.LiveBetting(childComplexity), true

	case "User.liveLosingBeDang":
		if e.complexity.User.LiveLosingBeDang == nil {
			break
		}

		return e.complexity.User.LiveLosingBeDang(childComplexity), true

	case "User.liveWinning":
		if e.complexity.User.LiveWinning == nil {
			break
		}

		return e.complexity.User.LiveWinning(childComplexity), true

	case "User.losingMethod":
		if e.complexity.User.LosingMethod == nil {
			break
		}

		return e.complexity.User.LosingMethod(childComplexity), true

	case "User.losingRate":
		if e.complexity.User.LosingRate == nil {
			break
		}

		return e.complexity.User.LosingRate(childComplexity), true

	case "User.losingSettlement":
		if e.complexity.User.LosingSettlement == nil {
			break
		}

		return e.complexity.User.LosingSettlement(childComplexity), true

	case "User.lotusBetting":
		if e.complexity.User.LotusBetting == nil {
			break
		}

		return e.complexity.User.LotusBetting(childComplexity), true

	case "User.lotusLottery":
		if e.complexity.User.LotusLottery == nil {
			break
		}

		return e.complexity.User.LotusLottery(childComplexity), true

	case "User.lotusRolling":
		if e.complexity.User.LotusRolling == nil {
			break
		}

		return e.complexity.User.LotusRolling(childComplexity), true

	case "User.membershipDeposit":
		if e.complexity.User.MembershipDeposit == nil {
			break
		}

		return e.complexity.User.MembershipDeposit(childComplexity), true

	case "User.membershipWithdrawal":
		if e.complexity.User.MembershipWithdrawal == nil {
			break
		}

		return e.complexity.User.MembershipWithdrawal(childComplexity), true

	case "User.mgmBetting":
		if e.complexity.User.MgmBetting == nil {
			break
		}

		return e.complexity.User.MgmBetting(childComplexity), true

	case "User.mgmRolling":
		if e.complexity.User.MgmRolling == nil {
			break
		}

		return e.complexity.User.MgmRolling(childComplexity), true

	case "User.mgmWinning":
		if e.complexity.User.MgmWinning == nil {
			break
		}

		return e.complexity.User.MgmWinning(childComplexity), true

	case "User.miniCombinationBetting":
		if e.complexity.User.MiniCombinationBetting == nil {
			break
		}

		return e.complexity.User.MiniCombinationBetting(childComplexity), true

	case "User.miniCombinationRolling":
		if e.complexity.User.MiniCombinationRolling == nil {
			break
		}

		return e.complexity.User.MiniCombinationRolling(childComplexity), true

	case "User.miniCombinationWinnings":
		if e.complexity.User.MiniCombinationWinnings == nil {
			break
		}

		return e.complexity.User.MiniCombinationWinnings(childComplexity), true

	case "User.miniDanpolBetting":
		if e.complexity.User.MiniDanpolBetting == nil {
			break
		}

		return e.complexity.User.MiniDanpolBetting(childComplexity), true

	case "User.miniDanpolRolling":
		if e.complexity.User.MiniDanpolRolling == nil {
			break
		}

		return e.complexity.User.MiniDanpolRolling(childComplexity), true

	case "User.miniDanpolWinner":
		if e.complexity.User.MiniDanpolWinner == nil {
			break
		}

		return e.complexity.User.MiniDanpolWinner(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.numberOfMembers":
		if e.complexity.User.NumberOfMembers == nil {
			break
		}

		return e.complexity.User.NumberOfMembers(childComplexity), true

	case "User.os":
		if e.complexity.User.OS == nil {
			break
		}

		return e.complexity.User.OS(childComplexity), true

	case "User.orderNum":
		if e.complexity.User.OrderNum == nil {
			break
		}

		return e.complexity.User.OrderNum(childComplexity), true

	case "User.parent":
		if e.complexity.User.Parent == nil {
			break
		}

		return e.complexity.User.Parent(childComplexity), true

	case "User.parentId":
		if e.complexity.User.ParentID == nil {
			break
		}

		return e.complexity.User.ParentID(childComplexity), true

	case "User.partnershipMoneyInHand":
		if e.complexity.User.PartnershipMoneyInHand == nil {
			break
		}

		return e.complexity.User.PartnershipMoneyInHand(childComplexity), true

	case "User.partnershipRolling":
		if e.complexity.User.PartnershipRolling == nil {
			break
		}

		return e.complexity.User.PartnershipRolling(childComplexity), true

	case "User.profile":
		if e.complexity.User.Profile == nil {
			break
		}

		return e.complexity.User.Profile(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.rollingHoldings":
		if e.complexity.User.RollingHoldings == nil {
			break
		}

		return e.complexity.User.RollingHoldings(childComplexity), true

	case "User.rollingRate":
		if e.complexity.User.RollingRate == nil {
			break
		}

		return e.complexity.User.RollingRate(childComplexity), true

	case "User.rollingTransition":
		if e.complexity.User.RollingTransition == nil {
			break
		}

		return e.complexity.User.RollingTransition(childComplexity), true

	case "User.root":
		if e.complexity.User.Root == nil {
			break
		}

		return e.complexity.User.Root(childComplexity), true

	case "User.rootId":
		if e.complexity.User.RootID == nil {
			break
		}

		return e.complexity.User.RootID(childComplexity), true

	case "User.slot":
		if e.complexity.User.Slot == nil {
			break
		}

		return e.complexity.User.Slot(childComplexity), true

	case "User.slotBetting":
		if e.complexity.User.SlotBetting == nil {
			break
		}

		return e.complexity.User.SlotBetting(childComplexity), true

	case "User.slotJackpot":
		if e.complexity.User.SlotJackpot == nil {
			break
		}

		return e.complexity.User.SlotJackpot(childComplexity), true

	case "User.slotLosingBeDang":
		if e.complexity.User.SlotLosingBeDang == nil {
			break
		}

		return e.complexity.User.SlotLosingBeDang(childComplexity), true

	case "User.sports3PoleRolling":
		if e.complexity.User.Sports3PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports3PoleRolling(childComplexity), true

	case "User.sports3poleBetting":
		if e.complexity.User.Sports3poleBetting == nil {
			break
		}

		return e.complexity.User.Sports3poleBetting(childComplexity), true

	case "User.sports3poleWinner":
		if e.complexity.User.Sports3poleWinner == nil {
			break
		}

		return e.complexity.User.Sports3poleWinner(childComplexity), true

	case "User.sports4PoleRolling":
		if e.complexity.User.Sports4PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports4PoleRolling(childComplexity), true

	case "User.sports4poleBetting":
		if e.complexity.User.Sports4poleBetting == nil {
			break
		}

		return e.complexity.User.Sports4poleBetting(childComplexity), true

	case "User.sports4poleWinner":
		if e.complexity.User.Sports4poleWinner == nil {
			break
		}

		return e.complexity.User.Sports4poleWinner(childComplexity), true

	case "User.sports5PoleRolling":
		if e.complexity.User.Sports5PoleRolling == nil {
			break
		}

		return e.complexity.User.Sports5PoleRolling(childComplexity), true

	case "User.sports5poleBetting":
		if e.complexity.User.Sports5poleBetting == nil {
			break
		}

		return e.complexity.User.Sports5poleBetting(childComplexity), true

	case "User.sports5poleWinner":
		if e.complexity.User.Sports5poleWinner == nil {
			break
		}

		return e.complexity.User.Sports5poleWinner(childComplexity), true

	case "User.sportsDanpolBetting":
		if e.complexity.User.SportsDanpolBetting == nil {
			break
		}

		return e.complexity.User.SportsDanpolBetting(childComplexity), true

	case "User.sportsDanpolRolling":
		if e.complexity.User.SportsDanpolRolling == nil {
			break
		}

		return e.complexity.User.SportsDanpolRolling(childComplexity), true

	case "User.sportsDanpolWinner":
		if e.complexity.User.SportsDanpolWinner == nil {
			break
		}

		return e.complexity.User.SportsDanpolWinner(childComplexity), true

	case "User.sportsDapolBetting":
		if e.complexity.User.SportsDapolBetting == nil {
			break
		}

		return e.complexity.User.SportsDapolBetting(childComplexity), true

	case "User.sportsDapolRolling":
		if e.complexity.User.SportsDapolRolling == nil {
			break
		}

		return e.complexity.User.SportsDapolRolling(childComplexity), true

	case "User.sportsDapolWinner":
		if e.complexity.User.SportsDapolWinner == nil {
			break
		}

		return e.complexity.User.SportsDapolWinner(childComplexity), true

	case "User.sportsDupolBetting":
		if e.complexity.User.SportsDupolBetting == nil {
			break
		}

		return e.complexity.User.SportsDupolBetting(childComplexity), true

	case "User.sportsDupolRolling":
		if e.complexity.User.SportsDupolRolling == nil {
			break
		}

		return e.complexity.User.SportsDupolRolling(childComplexity), true

	case "User.sportsDupolWinner":
		if e.complexity.User.SportsDupolWinner == nil {
			break
		}

		return e.complexity.User.SportsDupolWinner(childComplexity), true

	case "User.status":
		if e.complexity.User.Status == nil {
			break
		}

		return e.complexity.User.Status(childComplexity), true

	case "User.totalWithdrawal":
		if e.complexity.User.TotalWithdrawal == nil {
			break
		}

		return e.complexity.User.TotalWithdrawal(childComplexity), true

	case "User.touchBetting":
		if e.complexity.User.TouchBetting == nil {
			break
		}

		return e.complexity.User.TouchBetting(childComplexity), true

	case "User.touchRolling":
		if e.complexity.User.TouchRolling == nil {
			break
		}

		return e.complexity.User.TouchRolling(childComplexity), true

	case "User.touchWinning":
		if e.complexity.User.TouchWinning == nil {
			break
		}

		return e.complexity.User.TouchWinning(childComplexity), true

	case "User.type":
		if e.complexity.User.Type == nil {
			break
		}

		return e.complexity.User.Type(childComplexity), true

	case "User.usdtAddress":
		if e.complexity.User.USDTAddress == nil {
			break
		}

		return e.complexity.User.USDTAddress(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.userid":
		if e.complexity.User.Userid == nil {
			break
		}

		return e.complexity.User.Userid(childComplexity), true

	case "User.virtualGameBetting":
		if e.complexity.User.VirtualGameBetting == nil {
			break
		}

		return e.complexity.User.VirtualGameBetting(childComplexity), true

	case "User.virtualGameRolling":
		if e.complexity.User.VirtualGameRolling == nil {
			break
		}

		return e.complexity.User.VirtualGameRolling(childComplexity), true

	case "User.virtualGameWinnings":
		if e.complexity.User.VirtualGameWinnings == nil {
			break
		}

		return e.complexity.User.VirtualGameWinnings(childComplexity), true

	case "UserList.total":
		if e.complexity.UserList.Total == nil {
			break
		}

		return e.complexity.UserList.Total(childComplexity), true

	case "UserList.users":
		if e.complexity.UserList.Users == nil {
			break
		}

		return e.complexity.UserList.Users(childComplexity), true

	case "WeeklyLosingData.alias":
		if e.complexity.WeeklyLosingData.Alias == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Alias(childComplexity), true

	case "WeeklyLosingData.applicationDate":
		if e.complexity.WeeklyLosingData.ApplicationDate == nil {
			break
		}

		return e.complexity.WeeklyLosingData.ApplicationDate(childComplexity), true

	case "WeeklyLosingData.depositor":
		if e.complexity.WeeklyLosingData.Depositor == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Depositor(childComplexity), true

	case "WeeklyLosingData.distributorID":
		if e.complexity.WeeklyLosingData.DistributorID == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorID(childComplexity), true

	case "WeeklyLosingData.distributorLevel":
		if e.complexity.WeeklyLosingData.DistributorLevel == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorLevel(childComplexity), true

	case "WeeklyLosingData.distributorName":
		if e.complexity.WeeklyLosingData.DistributorName == nil {
			break
		}

		return e.complexity.WeeklyLosingData.DistributorName(childComplexity), true

	case "WeeklyLosingData.nickname":
		if e.complexity.WeeklyLosingData.Nickname == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Nickname(childComplexity), true

	case "WeeklyLosingData.processingDate":
		if e.complexity.WeeklyLosingData.ProcessingDate == nil {
			break
		}

		return e.complexity.WeeklyLosingData.ProcessingDate(childComplexity), true

	case "WeeklyLosingData.settlementAmount":
		if e.complexity.WeeklyLosingData.SettlementAmount == nil {
			break
		}

		return e.complexity.WeeklyLosingData.SettlementAmount(childComplexity), true

	case "WeeklyLosingData.site":
		if e.complexity.WeeklyLosingData.Site == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Site(childComplexity), true

	case "WeeklyLosingData.situation":
		if e.complexity.WeeklyLosingData.Situation == nil {
			break
		}

		return e.complexity.WeeklyLosingData.Situation(childComplexity), true

	case "WeeklyLosingData.totalBet":
		if e.complexity.WeeklyLosingData.TotalBet == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalBet(childComplexity), true

	case "WeeklyLosingData.totalLosingMoney":
		if e.complexity.WeeklyLosingData.TotalLosingMoney == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalLosingMoney(childComplexity), true

	case "WeeklyLosingData.totalWinner":
		if e.complexity.WeeklyLosingData.TotalWinner == nil {
			break
		}

		return e.complexity.WeeklyLosingData.TotalWinner(childComplexity), true

	case "WeeklyLosingData.userCount":
		if e.complexity.WeeklyLosingData.UserCount == nil {
			break
		}

		return e.complexity.WeeklyLosingData.UserCount(childComplexity), true

	case "WeeklyLosingData.weekEnd":
		if e.complexity.WeeklyLosingData.WeekEnd == nil {
			break
		}

		return e.complexity.WeeklyLosingData.WeekEnd(childComplexity), true

	case "WeeklyLosingData.weekStart":
		if e.complexity.WeeklyLosingData.WeekStart == nil {
			break
		}

		return e.complexity.WeeklyLosingData.WeekStart(childComplexity), true

	case "WeeklyLosingDataList.total":
		if e.complexity.WeeklyLosingDataList.Total == nil {
			break
		}

		return e.complexity.WeeklyLosingDataList.Total(childComplexity), true

	case "WeeklyLosingDataList.weeklyLosingData":
		if e.complexity.WeeklyLosingDataList.WeeklyLosingData == nil {
			break
		}

		return e.complexity.WeeklyLosingDataList.WeeklyLosingData(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputFilter,
		ec.unmarshalInputNewAdminPermission,
		ec.unmarshalInputNewAnnouncementInput,
		ec.unmarshalInputNewBankInput,
		ec.unmarshalInputNewDomainInput,
		ec.unmarshalInputNewEventInput,
		ec.unmarshalInputNewGameApiInput,
		ec.unmarshalInputNewInboxInput,
		ec.unmarshalInputNewLogInput,
		ec.unmarshalInputNewMenuInput,
		ec.unmarshalInputNewNotificationInput,
		ec.unmarshalInputNewProfile,
		ec.unmarshalInputNewQnaInput,
		ec.unmarshalInputNewSMSApiInput,
		ec.unmarshalInputNewSettingInput,
		ec.unmarshalInputNewTodo,
		ec.unmarshalInputNewTransactionInput,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputOrder,
		ec.unmarshalInputPagination,
		ec.unmarshalInputUpdateAdminPermissionInput,
		ec.unmarshalInputUpdateAnnouncementInput,
		ec.unmarshalInputUpdateBankInput,
		ec.unmarshalInputUpdateDomainInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateGameApiInput,
		ec.unmarshalInputUpdateInboxInput,
		ec.unmarshalInputUpdateMenuInput,
		ec.unmarshalInputUpdateNotificationInput,
		ec.unmarshalInputUpdateProfile,
		ec.unmarshalInputUpdateQnaInput,
		ec.unmarshalInputUpdateSMSApiInput,
		ec.unmarshalInputUpdateSettingInput,
		ec.unmarshalInputUpdateTransactionInput,
		ec.unmarshalInputUpdateUser,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/admin_permission.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type AdminPermission {
  id: ID!
  userId: ID!
  user: User!
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  statistical: Boolean
  ip: Boolean
  dwdelete: Boolean
  status: Boolean
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewAdminPermission {
  userId: ID!
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  status: Boolean
  statistical: Boolean
  ip: Boolean
  dwdelete: Boolean
}
input UpdateAdminPermissionInput {
  membership: Boolean
  financials: Boolean
  qna: Boolean
  game: Boolean
  settlement: Boolean
  sale: Boolean
  statistical: Boolean
  status: Boolean
  ip: Boolean
  dwdelete: Boolean
}

type AdminPermissionList {
  adminPermissions: [AdminPermission!]!
  total: Int!
}

extend type Query {
  adminPermissions(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): AdminPermissionList!
}

extend type Mutation {
  createAdminPermission(input: NewAdminPermission!): AdminPermission! @hasRole(role: A)
  updateAdminPermission(id:ID!, input: UpdateAdminPermissionInput!): AdminPermission! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/announcement.graphql", Input: `type Announcement {
  id: ID!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  user: User!
  userId: Uint!
  showFrom: Time
  showTo: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateAnnouncementInput {
  title: String
  description: String
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
  level: Uint
}

input NewAnnouncementInput {
  title: String!
  description: String!
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
}

type AnnouncementList {
  announcements: [Announcement!]!
  total: Int!
}

extend type Query {
  announcements: [Announcement!]!
  getAnnouncements(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): AnnouncementList! @hasRole(role: A)
}

extend type Mutation {
  createAnnouncement(input: NewAnnouncementInput!): Announcement!
    @hasRole(role: A)
  updateAnnouncement(id: ID!, input: UpdateAnnouncementInput!): Announcement!
    @hasRole(role: A)
  deleteAnnouncement(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/bank.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Bank {
  id: ID!
  name: String!
  orderNum: Uint
  status: Boolean!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewBankInput {
  name: String!
  orderNum: Uint
  status: Boolean
}

input UpdateBankInput {
  name: String
  orderNum: Uint
  status: Boolean
}

type BankList {
  banks: [Bank!]!
  total: Int!
}

extend type Query {
  getBanks(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): BankList! @hasRole(role: A)
}

extend type Mutation {
  createBank(input: NewBankInput!): Bank! @hasRole(role: A)
  updateBank(id: ID!, input: UpdateBankInput!): Bank! @hasRole(role: A)
  deleteBank(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/domain.graphql", Input: `type Domain {
  id: ID!
  name: String!
  description: String!
  status: Boolean!
  autoReg: Boolean!

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint

  orderNum: Uint
  userId: ID!
  user: User!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateDomainInput {
  name: String
  description: String
  status: Boolean
  userId: ID
  autoReg: Boolean
  orderNum: Uint

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint
}

input NewDomainInput {
  name: String!
  description: String!
  status: Boolean
  userId: ID!
  autoReg: Boolean
  orderNum: Uint

  useTelegram: Boolean
  telegram: String
  telegramLink: String
  useKakaoTalk: Boolean
  kakaoTalk: String
  kakaoTalkLink: String
  useServiceCenter: Boolean
  serviceCenter: String
  serviceCenterLink: String
  useLiveDomain: Boolean
  liveDomain: String
  liveDomainLink: String
  memberLevel: Uint
  distributorLevel: Uint
}

type DomainList {
  domains: [Domain!]!
  total: Int!
}

extend type Query {
  domains: [Domain!]
  getDomains(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): DomainList! @hasRole(role: A)
}

extend type Mutation {
  createDomain(input: NewDomainInput!): Domain! @hasRole(role: A)
  updateDomain(id: ID!, input: UpdateDomainInput!): Domain! @hasRole(role: A)
  deleteDomain(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/event.graphql", Input: `type Event {
  id: ID!
  title: String!
  type: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  user: User!
  userId: Uint!
  domainId: Uint
  domain: Domain
  showFrom: Time
  showTo: Time
  category: Uint
  views: Uint
  mainImage: String
  imageUpload: String
  level: Uint
  createdDate: Time!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateEventInput {
  title: String
  type: String
  description: String
  status: Boolean
  orderNum: Uint
  domainId: Uint
  showFrom: Time
  showTo: Time
  level: Uint
  author: String
  category: Uint
  views: Uint
  createdDate: Time
  mainImage: String
  imageUpload: String
}

input NewEventInput {
  title: String!
  author: String!
  category: Uint
  views: Uint
  createdDate: Time
  showFrom: Time
  showTo: Time
  description: String!
  mainImage: String
  imageUpload: String
}

type EventList {
  events: [Event!]!
  total: Int!
}

extend type Query {
  topEvents: [Event!]
  events: [Event!]
  getEvents(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): EventList! @hasRole(role: A)
}

extend type Mutation {
  createEvent(input: NewEventInput!): Event! @hasRole(role: A)
  updateEvent(id: ID!, input: UpdateEventInput!): Event! @hasRole(role: A)
  deleteEvent(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/game_api.graphql", Input: `# Represents a third-party game API configuration in the system.
type GameAPI {
  id: ID!
  apiCompanyName: String!
  gameApiName: String!
  gameCompanyName: String!
  gameType: String!
  other: String
  whetherToUse: Boolean!
  order: Int
  type: String
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewGameApiInput {
  apiCompanyName: String!
  gameApiName: String!
  gameCompanyName: String!
  gameType: String!
  other: String
  whetherToUse: Boolean
  order: Int
  type: String
}

input UpdateGameApiInput {
  apiCompanyName: String
  gameApiName: String
  gameCompanyName: String
  gameType: String
  other: String
  whetherToUse: Boolean
  order: Int
  type: String
}

type GameAPIList {
  gameApis: [GameAPI!]!
  total: Int!
}

extend type Query {
  getGameApis(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): GameAPIList! @hasRole(role: A)
}

extend type Mutation {
  createGameApi(input: NewGameApiInput!): GameAPI! @hasRole(role: A)
  updateGameApi(id: ID!, input: UpdateGameApiInput!): GameAPI! @hasRole(role: A)
  deleteGameApi(id: ID!): Boolean! @hasRole(role: A)
} `, BuiltIn: false},
	{Name: "../schema/inbox.graphql", Input: `type Inbox {
  id: ID!
  type: String!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  userId: Uint!
  user: User!
  fromId: Uint!
  FromUser: User!
  openedAt: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateInboxInput {
  type: String
  title: String
  description: String
  status: Boolean
  userId: Uint
  orderNum: Uint
  openedAt: Time
}

input NewInboxInput {
  type: String
  title: String!
  description: String!
  status: Boolean
  userId: Uint!
  orderNum: Uint
  openedAt: Time
}

type InboxList {
  inboxes: [Inbox!]!
  total: Int!
}

extend type Query {
  getInboxes(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): InboxList! @hasRole(role: A)
}

extend type Mutation {
  createInbox(input: NewInboxInput!): Inbox!
    @hasRole(role: A)
  updateInbox(id: ID!, input: UpdateInboxInput!): Inbox!
    @hasRole(role: A)
  deleteInbox(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/log.graphql", Input: `type Log {
  id: ID!
  data: String
  path: String!
  phone: String!
  method: String!
  type: String!
  ip: String!
  userId: ID
  user: User
  status: String
  os: String
  device: String
  host: String
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewLogInput {
  data: String!
  path: String!
  method: String!
  ip: String!
  type: String!
  phone: String
  status: String
}

type LogList {
  logs: [Log!]!
  total: Int!
}

extend type Query {
  logs: [Log!]
  getLogs(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): LogList! @hasRole(role: A)
}

extend type Mutation {
  createLog(input: NewLogInput!): Log! @hasRole(role: A)
  deleteLog(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/main.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Upload
scalar Time
scalar Uint
scalar DeletedAt
scalar MyCustomBooleanScalar

directive @auth on FIELD_DEFINITION

directive @hasRole(role: Role!) on FIELD_DEFINITION

enum OrderDirection {
  ASC
  DESC
}

enum Role {
  A
  P
  U
}

enum Op {
  eq         # =
  neq        # != or <>
  gt         # >
  gte        # >=
  lt         # <
  lte        # <=
  in         # IN (...)
  not_in     # NOT IN (...)
  like       # LIKE
  not_like   # NOT LIKE
  ilike      # ILIKE (PostgreSQL)
  not_ilike  # NOT ILIKE
  between    # BETWEEN
  not_between # NOT BETWEEN
  is_null    # IS NULL
  is_not_null # IS NOT NULL
}

input Pagination {
  limit: Int = 10
  offset: Int = 0
}

input Order {
  field: String!
  direction: OrderDirection = ASC
}


input Filter {
  field: String
  value: String     # You can keep it String and parse to correct type in Go
  op: Op = eq  
  
  or: [Filter]
  and: [Filter]
}

type Query {
  time: Time
}

type Mutation {
  time: Time!
  uploadFile(file: Upload!): String!
}

type Subscription {
  time: String!
}
`, BuiltIn: false},
	{Name: "../schema/menu.graphql", Input: `type Menu {
  id: ID!
  path: String!
  label: String!
  key: String!
  icon: String
  description: String
  status: Boolean
  parentId: Uint
  children: [Menu!]
  orderNum: Uint
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateMenuInput {
  label: String
  key: String
  icon: String
  path: String
  parentId: Uint
  description: String
  status: Boolean
  orderNum: Uint
}

input NewMenuInput {
  label: String!
  key: String!
  path: String!
  icon: String
  parentId: Uint
  description: String
  status: Boolean
  orderNum: Uint
  openedAt: Time
}

type MenuList {
  menus: [Menu!]!
  total: Int!
}

extend type Query {
  getUserMenus: [Menu]!
  getMenus(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): MenuList! @hasRole(role: A)
}

extend type Mutation {
  createMenu(input: NewMenuInput!): Menu!
    @hasRole(role: A)
  updateMenu(id: ID!, input: UpdateMenuInput!): Menu!
    @hasRole(role: A)
  deleteMenu(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/notification.graphql", Input: `type Notification {
  id: ID!
  title: String!
  description: String!
  status: Boolean!
  orderNum: Uint
  showFrom: Time!
  mainImage: String!
  imageUpload: String!
  noticeType: String!
  registerDate: Time!
  level: Uint
  domainId: Uint
  domain: Domain
  views: Uint
  showTo: Time!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input UpdateNotificationInput {
  title: String
  description: String
  status: Boolean
  orderNum: Uint
  showFrom: Time
  showTo: Time
  level: Uint
  mainImage: String
  imageUpload: String
  noticeType: String
  registerDate: Time
  views: Uint
}

input NewNotificationInput {
  title: String!
  description: String!
  mainImage: String!
  imageUpload: String!
  noticeType: String!
  registerDate: Time!
  views: Uint
}

type NotificationList {
  notifications: [Notification!]!
  total: Int!
}

extend type Query {
  notifications: [Notification!]
  getNotifications(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): NotificationList! @hasRole(role: A)
}

extend type Mutation {
  createNotification(input: NewNotificationInput!): Notification!
    @hasRole(role: A)
  updateNotification(id: ID!, input: UpdateNotificationInput!): Notification!
    @hasRole(role: A)
  deleteNotification(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/qna.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Qna {
  id: ID!

  userId: Uint!
  user: User

  domainId: Uint
  domain: Domain
  
  type: String
  question: String
  questionTitle: String
  answer: String
  answerTitle: String

  status: String

  repliedAt: Time
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewQnaInput {
  question: String!
  questionTitle: String!
  type: String
  status: String
}

input UpdateQnaInput {
  type: String
  question: String
  questionTitle: String
  answer: String
  answerTitle: String
  status: String
}

type QnaList {
  qnas: [Qna!]!
  total: Int!
}

extend type Query {
  getQnas(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): QnaList! @hasRole(role: A)
}

extend type Mutation {
  createQna(input: NewQnaInput!): Qna! @auth
  updateQna(id: ID!, input: UpdateQnaInput!): Qna! @auth
  replyQna(id: ID!, input: UpdateQnaInput!): Qna! @hasRole(role: A)
  deleteQna(id: ID!): Boolean! @hasRole(role: A)
  completeQna(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/setting.graphql", Input: `type Setting {
  id: ID!

  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID
  user: User

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time

  createdAt: Time
  updatedAt: Time
  deletedAt: DeletedAt
}

input UpdateSettingInput {
  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID 

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time
}

input NewSettingInput {
  status: Boolean

  title: String
  description: String
  primaryDomain: Uint

  userId: ID 

  orderNum: Uint

  totalExStatus: Boolean
  totalExFrom: Time
  totalExTo: Time

  totalReStatus: Boolean
  totalReFrom: Time
  totalReTo: Time

  userExStatus: Boolean
  userExFrom: Time
  userExTo: Time

  userReStatus: Boolean
  userReFrom: Time
  userReTo: Time
}
 

extend type Query {  
  getSetting: Setting! @hasRole(role: A)
}

extend type Mutation {
  createSetting(input: NewSettingInput!): Setting! @hasRole(role: A)
  updateSetting(id: ID!, input: UpdateSettingInput!): Setting! @hasRole(role: A)
  deleteSetting(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/sms_api.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type SMSApi {
  id: ID!
  name: String!
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewSMSApiInput {
  name: String!
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean
}

input UpdateSMSApiInput {
  name: String
  url: String
  agent: String
  password: String
  token: String
  orderNum: Uint
  status: Boolean
}

type SMSApiList {
  smsApis: [SMSApi!]!
  total: Int!
}

extend type Query {
  getSMSApis(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): SMSApiList! @hasRole(role: A)
}

extend type Mutation {
  createSMSApi(input: NewSMSApiInput!): SMSApi! @hasRole(role: A)
  updateSMSApi(id: ID!, input: UpdateSMSApiInput!): SMSApi! @hasRole(role: A)
  deleteSMSApi(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/todo.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

input NewTodo {
  text: String!
  userId: String!
}

extend type Query {
  todos: [Todo!]!
}

extend type Mutation {
  createTodo(input: NewTodo!): Todo!
}
`, BuiltIn: false},
	{Name: "../schema/transaction.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Transaction {
  id: ID!

  userId: ID!
  user: User

  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String

  transactionAt: Time
  approvedAt: Time

  createdAt: Time
  updatedAt: Time
  deletedAt: DeletedAt
}

input NewTransactionInput {
  userId: ID!
  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String
}

input UpdateTransactionInput {
  type: String
  amount: Float

  balanceBefore: Float
  balanceAfter: Float

  pointBefore: Float
  pointAfter: Float

  status: String
  shortcut: String
  usdtDesc: String
}

type TransactionList {
  transactions: [Transaction!]!
  total: Int!
}

type WeeklyLosingData {
  weekStart: String!
  weekEnd: String!
  site: String!
  distributorID: String!
  distributorName: String!
  distributorLevel: Int!
  nickname: String!
  depositor: String!
  alias: String!
  totalBet: Float!
  totalWinner: Float!
  totalLosingMoney: Float!
  settlementAmount: Float!
  applicationDate: String!
  processingDate: String!
  situation: String!
  userCount: Int!
}

type WeeklyLosingDataList {
  weeklyLosingData: [WeeklyLosingData!]!
  total: Int!
}

extend type Query {
  getTransactions(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): TransactionList! @hasRole(role: A)
  
  getWeeklyLosingData(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): WeeklyLosingDataList! @hasRole(role: A)
}

extend type Mutation {
  createTransaction(input: NewTransactionInput!): Transaction! @hasRole(role: A)
  updateTransaction(id: ID!, input: UpdateTransactionInput!): Transaction! @hasRole(role: A)
  deleteTransaction(id: ID!): Boolean! @hasRole(role: A)
  approveTransaction(id: ID!): Boolean! @hasRole(role: A)
  blockTransaction(id: ID!): Boolean! @hasRole(role: A)
  waitingTransaction(id: ID!): Boolean! @hasRole(role: A)
  cancelTransaction(id: ID!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `enum UserStatus {
  A # approved
  B # blocked
  D # deleted
  I # inactivated
  S # suspended
  P # pending
}

enum UserType {
  G # general
  T # test
  I # interest
  W # working
}

type User {
  id: ID!
  name: String!
  userid: String!
  type: UserType!
  role: String!
  usdtAddress: String!
  currentIP: String!
  IP: String!
  rootId: ID
  root: User
  parentId: ID
  parent: User
  children: [User]
  childrenCount: Uint
  profile: Profile
  status: UserStatus!
  blackMemo: Boolean!
  orderNum: Uint
  os: String
  device: String
  fingerPrint: String

  live: Float
  slot: Float
  hold: Float  

  entireLosing : Float
  liveLosingBeDang: Float
  slotLosingBeDang: Float
  holdLosingBeDang: Float

  losingMethod: String

  # Additional rolling fields for different game types
  miniDanpolRolling: Float
  miniCombinationRolling: Float
  sportsDanpolRolling: Float
  sportsDupolRolling: Float
  sports3PoleRolling: Float
  sports4PoleRolling: Float
  sports5PoleRolling: Float
  sportsDapolRolling: Float
  virtualGameRolling: Float
  lotusRolling: Float
  mgmRolling: Float
  touchRolling: Float

  # Financial statistics
  membershipDeposit: Float
  membershipWithdrawal: Float
  totalWithdrawal: Float
  numberOfMembers: Int
  rollingHoldings: Float

  # Betting/Winning statistics
  liveBetting: Float
  liveWinning: Float
  slotBetting: Float
  slotJackpot: Float
  miniDanpolBetting: Float
  miniDanpolWinner: Float
  miniCombinationBetting: Float
  miniCombinationWinnings: Float
  sportsDanpolBetting: Float
  sportsDanpolWinner: Float
  sportsDupolBetting: Float
  sportsDupolWinner: Float
  sports3poleBetting: Float
  sports3poleWinner: Float
  sports4poleBetting: Float
  sports4poleWinner: Float
  sports5poleBetting: Float
  sports5poleWinner: Float
  sportsDapolBetting: Float
  sportsDapolWinner: Float
  virtualGameBetting: Float
  virtualGameWinnings: Float
  lotusBetting: Float
  lotusLottery: Float
  mgmBetting: Float
  mgmWinning: Float
  touchBetting: Float
  touchWinning: Float
  holdemBetting: Float
  holdemWinning: Float

  # Rolling statistics
  rollingRate: Float
  rollingTransition: Float

  # Losing statistics
  losingRate: Float
  losingSettlement: Float

  # Partnership statistics
  partnershipRolling: Float
  partnershipMoneyInHand: Float

  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

type Profile {
  id: ID!
  userId: ID!
  name: String!
  nickname: String!
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  phoneVerified: Boolean!
  balance: Float!
  roll: Float!
  point: Int!
  comp: Int!
  level: Int!
  coupon: Int!
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
  lastDeposit: Time
  lastWithdraw: Time
  orderNum: Uint
  createdAt: Time!
  updatedAt: Time!
  deletedAt: DeletedAt
}

input NewProfile {
  userId: ID!
  name: String!
  nickname: String!
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  balance: Float
  roll: Float
  point: Int
  comp: Int
  level: Int
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
}

input UpdateProfile {
  userid: String
  name: String
  nickname: String
  bankName: String
  holderName: String
  accountNumber: String
  birthday: Time
  phone: String
  mobile: String
  balance: Float
  roll: Float
  point: Int
  comp: Int
  level: Int
  favorites: String
  referral: String
  avatarUrl: String
  bio: String
  socialLinks: String
  currentPassword: String
  confirmPassword: String
  newPassword: String
}

input UpdateUser {
  name: String
  userid: String
  rootId: ID
  partentId: ID
  type: UserType
  role: String
  usdtAddress: String
  status: UserStatus
  orderNum: Uint
  
  live: Float
  slot: Float
  hold: Float
  entireLosing: Float
  liveLosingBeDang: Float
  slotLosingBeDang: Float
  holdLosingBeDang: Float
  losingMethod: String
}

input NewUser {
  name: String
  userid: String!
  type: UserType!
  role: String!
  password: String!
  usdtAddress: String
  currentIP: String
  IP: String
  rootId: ID
  parentId: ID
  childrenCount: Uint
  status: UserStatus!
  blackMemo: Boolean
  orderNum: Uint
  os: String
  device: String
  fingerPrint: String

  domainId: ID
  bankId: ID
  holderName: String
  nickname: String
  phone: String
  settlementId: ID
}

type UserList {
  users: [User!]!
  total: Int!
}

extend type Query {
  profile: Profile! @auth
  me: User! @auth

  users: [User!]! @hasRole(role: A)

  filterUsers(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  connectedUsers(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  user(id: ID!): User @hasRole(role: A)

  getDistributors(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)

  getDistributorDetails(
    filters: [Filter!]
    orders: [Order!]
    pagination: Pagination
  ): UserList! @hasRole(role: A)
}

extend type Mutation {
  updateProfile(id: ID!, input: UpdateProfile!): Profile! @auth
  deleteProfile(id: ID!): Boolean! @auth
  createUser(input: NewUser): Boolean! @hasRole(role: A)
  approveUser(id: ID!): Boolean! @hasRole(role: A)
  blockUser(id: ID!): Boolean! @hasRole(role: A)
  updateUser(id: ID!, input: UpdateUser!): Boolean! @hasRole(role: A)
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_hasRole_argsRole(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["role"] = arg0
	return args, nil
}
func (ec *executionContext) dir_hasRole_argsRole(
	ctx context.Context,
	rawArgs map[string]any,
) (model.Role, error) {
	if _, ok := rawArgs["role"]; !ok {
		var zeroVal model.Role
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
	if tmp, ok := rawArgs["role"]; ok {
		return ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, tmp)
	}

	var zeroVal model.Role
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_approveTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_approveTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_approveTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_approveUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_approveUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_approveUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_blockTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_blockTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_blockTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_blockUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_blockUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_blockUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_cancelTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_cancelTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_cancelTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_completeQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_completeQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_completeQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createAdminPermission_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createAdminPermission_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createAdminPermission_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewAdminPermission, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewAdminPermission2githubcomhotbrainygobettingbackendgraphmodelNewAdminPermission(ctx, tmp)
	}

	var zeroVal model.NewAdminPermission
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createAnnouncement_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createAnnouncement_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewAnnouncementInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewAnnouncementInput2githubcomhotbrainygobettingbackendgraphmodelNewAnnouncementInput(ctx, tmp)
	}

	var zeroVal model.NewAnnouncementInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createBank_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createBank_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewBankInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewBankInput2githubcomhotbrainygobettingbackendgraphmodelNewBankInput(ctx, tmp)
	}

	var zeroVal model.NewBankInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createDomain_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createDomain_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewDomainInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewDomainInput2githubcomhotbrainygobettingbackendgraphmodelNewDomainInput(ctx, tmp)
	}

	var zeroVal model.NewDomainInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewEventInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewEventInput2githubcomhotbrainygobettingbackendgraphmodelNewEventInput(ctx, tmp)
	}

	var zeroVal model.NewEventInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createGameApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createGameApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewGameAPIInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewGameApiInput2githubcomhotbrainygobettingbackendgraphmodelNewGameAPIInput(ctx, tmp)
	}

	var zeroVal model.NewGameAPIInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createInbox_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createInbox_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewInboxInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewInboxInput2githubcomhotbrainygobettingbackendgraphmodelNewInboxInput(ctx, tmp)
	}

	var zeroVal model.NewInboxInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createLog_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createLog_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewLogInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewLogInput2githubcomhotbrainygobettingbackendgraphmodelNewLogInput(ctx, tmp)
	}

	var zeroVal model.NewLogInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMenu_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMenu_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewMenuInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewMenuInput2githubcomhotbrainygobettingbackendgraphmodelNewMenuInput(ctx, tmp)
	}

	var zeroVal model.NewMenuInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createNotification_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createNotification_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewNotificationInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewNotificationInput2githubcomhotbrainygobettingbackendgraphmodelNewNotificationInput(ctx, tmp)
	}

	var zeroVal model.NewNotificationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewQnaInput2githubcomhotbrainygobettingbackendgraphmodelNewQnaInput(ctx, tmp)
	}

	var zeroVal model.NewQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createSMSApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createSMSApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewSMSApiInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewSMSApiInput2githubcomhotbrainygobettingbackendgraphmodelNewSMSApiInput(ctx, tmp)
	}

	var zeroVal model.NewSMSApiInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createSetting_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createSetting_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewSettingInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewSettingInput2githubcomhotbrainygobettingbackendgraphmodelNewSettingInput(ctx, tmp)
	}

	var zeroVal model.NewSettingInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTodo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTodo_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTodo_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewTodo, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewTodo2githubcomhotbrainygobettingbackendgraphmodelNewTodo(ctx, tmp)
	}

	var zeroVal model.NewTodo
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTransaction_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTransaction_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NewTransactionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewTransactionInput2githubcomhotbrainygobettingbackendgraphmodelNewTransactionInput(ctx, tmp)
	}

	var zeroVal model.NewTransactionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.NewUser, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalONewUser2githubcomhotbrainygobettingbackendgraphmodelNewUser(ctx, tmp)
	}

	var zeroVal *model.NewUser
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteAnnouncement_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteAnnouncement_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteBank_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteBank_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteDomain_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteDomain_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteEvent_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteEvent_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteGameApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteGameApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteInbox_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteInbox_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteLog_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteLog_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteLog_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMenu_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMenu_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteNotification_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteNotification_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteProfile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteProfile_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteProfile_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSMSApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSMSApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSetting_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSetting_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_replyQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_replyQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_replyQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_replyQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_replyQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateQnaInput2githubcomhotbrainygobettingbackendgraphmodelUpdateQnaInput(ctx, tmp)
	}

	var zeroVal model.UpdateQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAdminPermission_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateAdminPermission_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateAdminPermission_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateAdminPermission_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAdminPermission_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateAdminPermissionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateAdminPermissionInput2githubcomhotbrainygobettingbackendgraphmodelUpdateAdminPermissionInput(ctx, tmp)
	}

	var zeroVal model.UpdateAdminPermissionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateAnnouncement_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateAnnouncement_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateAnnouncement_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateAnnouncementInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateAnnouncementInput2githubcomhotbrainygobettingbackendgraphmodelUpdateAnnouncementInput(ctx, tmp)
	}

	var zeroVal model.UpdateAnnouncementInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBank_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateBank_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateBank_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateBank_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBank_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateBankInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateBankInput2githubcomhotbrainygobettingbackendgraphmodelUpdateBankInput(ctx, tmp)
	}

	var zeroVal model.UpdateBankInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateDomain_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateDomain_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateDomain_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateDomain_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateDomain_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateDomainInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateDomainInput2githubcomhotbrainygobettingbackendgraphmodelUpdateDomainInput(ctx, tmp)
	}

	var zeroVal model.UpdateDomainInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateEvent_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateEvent_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateEvent_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateEvent_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateEventInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateEventInput2githubcomhotbrainygobettingbackendgraphmodelUpdateEventInput(ctx, tmp)
	}

	var zeroVal model.UpdateEventInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateGameApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateGameApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateGameApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateGameApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateGameApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateGameAPIInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateGameApiInput2githubcomhotbrainygobettingbackendgraphmodelUpdateGameAPIInput(ctx, tmp)
	}

	var zeroVal model.UpdateGameAPIInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateInbox_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateInbox_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateInbox_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateInbox_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateInbox_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateInboxInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateInboxInput2githubcomhotbrainygobettingbackendgraphmodelUpdateInboxInput(ctx, tmp)
	}

	var zeroVal model.UpdateInboxInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMenu_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMenu_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateMenu_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMenu_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMenu_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateMenuInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateMenuInput2githubcomhotbrainygobettingbackendgraphmodelUpdateMenuInput(ctx, tmp)
	}

	var zeroVal model.UpdateMenuInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateNotification_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateNotification_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateNotification_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateNotification_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateNotification_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateNotificationInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateNotificationInput2githubcomhotbrainygobettingbackendgraphmodelUpdateNotificationInput(ctx, tmp)
	}

	var zeroVal model.UpdateNotificationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateProfile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateProfile_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateProfile_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateProfile_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateProfile_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateProfile, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateProfile2githubcomhotbrainygobettingbackendgraphmodelUpdateProfile(ctx, tmp)
	}

	var zeroVal model.UpdateProfile
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateQna_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateQna_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateQna_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateQna_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateQna_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateQnaInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateQnaInput2githubcomhotbrainygobettingbackendgraphmodelUpdateQnaInput(ctx, tmp)
	}

	var zeroVal model.UpdateQnaInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSMSApi_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSMSApi_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateSMSApi_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSMSApi_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSMSApi_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateSMSApiInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateSMSApiInput2githubcomhotbrainygobettingbackendgraphmodelUpdateSMSApiInput(ctx, tmp)
	}

	var zeroVal model.UpdateSMSApiInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSetting_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSetting_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateSetting_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSetting_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSetting_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateSettingInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateSettingInput2githubcomhotbrainygobettingbackendgraphmodelUpdateSettingInput(ctx, tmp)
	}

	var zeroVal model.UpdateSettingInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateTransaction_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTransaction_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTransactionInput, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTransactionInput2githubcomhotbrainygobettingbackendgraphmodelUpdateTransactionInput(ctx, tmp)
	}

	var zeroVal model.UpdateTransactionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateUser_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUser_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateUser, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateUser2githubcomhotbrainygobettingbackendgraphmodelUpdateUser(ctx, tmp)
	}

	var zeroVal model.UpdateUser
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_uploadFile_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_uploadFile_argsFile(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["file"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_uploadFile_argsFile(
	ctx context.Context,
	rawArgs map[string]any,
) (graphql.Upload, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
	if tmp, ok := rawArgs["file"]; ok {
		return ec.unmarshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx, tmp)
	}

	var zeroVal graphql.Upload
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_waitingTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_waitingTransaction_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_waitingTransaction_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminPermissions_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_adminPermissions_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_adminPermissions_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_adminPermissions_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminPermissions_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_connectedUsers_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_connectedUsers_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_connectedUsers_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_connectedUsers_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedUsers_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_filterUsers_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_filterUsers_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_filterUsers_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_filterUsers_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_filterUsers_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getAnnouncements_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getAnnouncements_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getAnnouncements_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getAnnouncements_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getAnnouncements_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getBanks_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getBanks_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getBanks_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getBanks_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBanks_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDistributorDetails_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDistributorDetails_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDistributorDetails_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDistributorDetails_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributorDetails_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDistributors_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDistributors_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDistributors_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDistributors_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDistributors_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getDomains_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getDomains_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getDomains_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getDomains_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getDomains_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getEvents_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getEvents_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getEvents_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getEvents_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getEvents_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getGameApis_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getGameApis_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getGameApis_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getGameApis_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getGameApis_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getInboxes_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getInboxes_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getInboxes_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getInboxes_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getInboxes_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getLogs_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getLogs_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getLogs_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getLogs_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getLogs_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMenus_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getMenus_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getMenus_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMenus_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMenus_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getNotifications_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getNotifications_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getNotifications_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getNotifications_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getNotifications_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getQnas_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getQnas_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getQnas_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getQnas_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getQnas_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getSMSApis_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getSMSApis_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getSMSApis_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getSMSApis_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getSMSApis_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getTransactions_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getTransactions_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getTransactions_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getTransactions_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getWeeklyLosingData_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg0
	arg1, err := ec.field_Query_getWeeklyLosingData_argsOrders(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orders"] = arg1
	arg2, err := ec.field_Query_getWeeklyLosingData_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getWeeklyLosingData_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Filter, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, tmp)
	}

	var zeroVal []*model.Filter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_argsOrders(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.Order, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orders"))
	if tmp, ok := rawArgs["orders"]; ok {
		return ec.unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, tmp)
	}

	var zeroVal []*model.Order
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getWeeklyLosingData_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.Pagination, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx, tmp)
	}

	var zeroVal *model.Pagination
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_user_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (uint, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2uint(ctx, tmp)
	}

	var zeroVal uint
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdminPermission_id(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_userId(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_user(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_membership(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_membership(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Membership, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_membership(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_financials(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_financials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Financials, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_financials(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_qna(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_qna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qna, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_qna(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_game(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_game(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_game(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_settlement(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_settlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_settlement(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_sale(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_sale(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sale, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_sale(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_statistical(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_statistical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_statistical(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_ip(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_ip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_dwdelete(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_dwdelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dwdelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_dwdelete(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_status(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermission_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.AdminPermission) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermission_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermission_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermissionList_adminPermissions(ctx context.Context, field graphql.CollectedField, obj *model.AdminPermissionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermissionList_adminPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminPermissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermissionList_adminPermissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermissionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminPermissionList_total(ctx context.Context, field graphql.CollectedField, obj *model.AdminPermissionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminPermissionList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminPermissionList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminPermissionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_id(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_title(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_description(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_status(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_user(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_userId(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Announcement().ShowFrom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Announcement().ShowTo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AnnouncementList_announcements(ctx context.Context, field graphql.CollectedField, obj *model.AnnouncementList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AnnouncementList_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Announcements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AnnouncementList_announcements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AnnouncementList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AnnouncementList_total(ctx context.Context, field graphql.CollectedField, obj *model.AnnouncementList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AnnouncementList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AnnouncementList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AnnouncementList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_id(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_name(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_status(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Bank_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Bank) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Bank_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Bank_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Bank",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankList_banks(ctx context.Context, field graphql.CollectedField, obj *model.BankList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankList_banks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Bank)
	fc.Result = res
	return ec.marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankList_banks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankList_total(ctx context.Context, field graphql.CollectedField, obj *model.BankList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_id(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_name(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_description(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_status(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_autoReg(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_autoReg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoReg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_autoReg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useTelegram(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useTelegram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseTelegram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useTelegram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_telegram(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_telegram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telegram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_telegram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_telegramLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_telegramLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TelegramLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_telegramLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useKakaoTalk(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useKakaoTalk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseKakaoTalk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useKakaoTalk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_kakaoTalk(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_kakaoTalk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KakaoTalk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_kakaoTalk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_kakaoTalkLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KakaoTalkLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_kakaoTalkLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useServiceCenter(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useServiceCenter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseServiceCenter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useServiceCenter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_serviceCenter(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_serviceCenter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceCenter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_serviceCenter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_serviceCenterLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_serviceCenterLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceCenterLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_serviceCenterLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_useLiveDomain(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_useLiveDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseLiveDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_useLiveDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_liveDomain(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_liveDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_liveDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_liveDomainLink(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_liveDomainLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveDomainLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_liveDomainLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_memberLevel(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_memberLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemberLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_memberLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_distributorLevel(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_distributorLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_distributorLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_userId(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_user(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Domain_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Domain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Domain_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Domain_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Domain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DomainList_domains(ctx context.Context, field graphql.CollectedField, obj *model.DomainList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DomainList_domains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domains, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DomainList_domains(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DomainList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DomainList_total(ctx context.Context, field graphql.CollectedField, obj *model.DomainList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DomainList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DomainList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DomainList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_title(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_description(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_status(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_user(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_userId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_domain(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_category(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_views(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_mainImage(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_mainImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_mainImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_imageUpload(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_imageUpload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUpload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_imageUpload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_level(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventList_events(ctx context.Context, field graphql.CollectedField, obj *model.EventList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventList_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventList_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventList_total(ctx context.Context, field graphql.CollectedField, obj *model.EventList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_id(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_apiCompanyName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APICompanyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_apiCompanyName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameApiName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameApiName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameAPIName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameApiName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameCompanyName(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameCompanyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameCompanyName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_gameType(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_gameType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_gameType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_other(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_other(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Other, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_other(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_whetherToUse(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_whetherToUse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WhetherToUse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_whetherToUse(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_order(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int32)
	fc.Result = res
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_type(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPI_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.GameAPI) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPI_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPI_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPI",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPIList_gameApis(ctx context.Context, field graphql.CollectedField, obj *model.GameAPIList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPIList_gameApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GameApis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPIList_gameApis(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPIList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameAPIList_total(ctx context.Context, field graphql.CollectedField, obj *model.GameAPIList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameAPIList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameAPIList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameAPIList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_id(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_type(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_title(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_description(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_status(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_userId(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_user(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_fromId(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_fromId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_fromId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_FromUser(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_FromUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_FromUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_openedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_openedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_openedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Inbox_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Inbox) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Inbox_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Inbox_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Inbox",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboxList_inboxes(ctx context.Context, field graphql.CollectedField, obj *model.InboxList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboxList_inboxes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inboxes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboxList_inboxes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboxList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InboxList_total(ctx context.Context, field graphql.CollectedField, obj *model.InboxList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InboxList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InboxList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InboxList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_id(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_data(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_path(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_phone(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_method(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_type(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_ip(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_ip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_ip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_userId(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_user(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_status(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_os(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_device(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_device(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Device, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_device(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_host(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Log_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Log) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Log_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Log().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Log_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Log",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogList_logs(ctx context.Context, field graphql.CollectedField, obj *model.LogList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogList_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Log)
	fc.Result = res
	return ec.marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogList_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogList_total(ctx context.Context, field graphql.CollectedField, obj *model.LogList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_id(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_path(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_label(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_key(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_icon(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Icon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_description(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_status(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_parentId(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_parentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_parentId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_children(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Menu)
	fc.Result = res
	return ec.marshalOMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_children(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Menu_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Menu) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Menu_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Menu_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Menu",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MenuList_menus(ctx context.Context, field graphql.CollectedField, obj *model.MenuList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MenuList_menus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Menus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MenuList_menus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MenuList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MenuList_total(ctx context.Context, field graphql.CollectedField, obj *model.MenuList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MenuList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MenuList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MenuList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_time(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UploadFile(rctx, fc.Args["file"].(graphql.Upload))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadFile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAdminPermission(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAdminPermission(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAdminPermission(rctx, fc.Args["input"].(model.NewAdminPermission))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.AdminPermission
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.AdminPermission
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.AdminPermission); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.AdminPermission`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAdminPermission(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAdminPermission_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAdminPermission(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAdminPermission(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAdminPermission(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateAdminPermissionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.AdminPermission
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.AdminPermission
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.AdminPermission); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.AdminPermission`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.AdminPermission)
	fc.Result = res
	return ec.marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAdminPermission(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminPermission_id(ctx, field)
			case "userId":
				return ec.fieldContext_AdminPermission_userId(ctx, field)
			case "user":
				return ec.fieldContext_AdminPermission_user(ctx, field)
			case "membership":
				return ec.fieldContext_AdminPermission_membership(ctx, field)
			case "financials":
				return ec.fieldContext_AdminPermission_financials(ctx, field)
			case "qna":
				return ec.fieldContext_AdminPermission_qna(ctx, field)
			case "game":
				return ec.fieldContext_AdminPermission_game(ctx, field)
			case "settlement":
				return ec.fieldContext_AdminPermission_settlement(ctx, field)
			case "sale":
				return ec.fieldContext_AdminPermission_sale(ctx, field)
			case "statistical":
				return ec.fieldContext_AdminPermission_statistical(ctx, field)
			case "ip":
				return ec.fieldContext_AdminPermission_ip(ctx, field)
			case "dwdelete":
				return ec.fieldContext_AdminPermission_dwdelete(ctx, field)
			case "status":
				return ec.fieldContext_AdminPermission_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_AdminPermission_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AdminPermission_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_AdminPermission_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermission", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAdminPermission_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAnnouncement(rctx, fc.Args["input"].(model.NewAnnouncementInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Announcement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Announcement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAnnouncement(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateAnnouncementInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Announcement
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Announcement
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAnnouncement(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBank(rctx, fc.Args["input"].(model.NewBankInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Bank
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Bank
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Bank); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Bank`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Bank)
	fc.Result = res
	return ec.marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateBank(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateBankInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Bank
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Bank
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Bank); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Bank`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Bank)
	fc.Result = res
	return ec.marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Bank_id(ctx, field)
			case "name":
				return ec.fieldContext_Bank_name(ctx, field)
			case "orderNum":
				return ec.fieldContext_Bank_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_Bank_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_Bank_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Bank_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Bank_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Bank", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBank(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBank(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBank_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDomain(rctx, fc.Args["input"].(model.NewDomainInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Domain
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Domain
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Domain); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Domain`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDomain(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateDomainInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Domain
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Domain
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Domain); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Domain`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDomain(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDomain(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDomain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(model.NewEventInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Event
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Event
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateEventInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Event
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Event
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	fc.Result = res
	return ec.marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateGameAPI(rctx, fc.Args["input"].(model.NewGameAPIInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPI
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPI
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPI); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPI`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGameAPI(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateGameAPIInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPI
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPI
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPI); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPI`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPI)
	fc.Result = res
	return ec.marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameAPI_id(ctx, field)
			case "apiCompanyName":
				return ec.fieldContext_GameAPI_apiCompanyName(ctx, field)
			case "gameApiName":
				return ec.fieldContext_GameAPI_gameApiName(ctx, field)
			case "gameCompanyName":
				return ec.fieldContext_GameAPI_gameCompanyName(ctx, field)
			case "gameType":
				return ec.fieldContext_GameAPI_gameType(ctx, field)
			case "other":
				return ec.fieldContext_GameAPI_other(ctx, field)
			case "whetherToUse":
				return ec.fieldContext_GameAPI_whetherToUse(ctx, field)
			case "order":
				return ec.fieldContext_GameAPI_order(ctx, field)
			case "type":
				return ec.fieldContext_GameAPI_type(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameAPI_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GameAPI_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GameAPI_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPI", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGameApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGameApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGameAPI(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGameApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGameApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateInbox(rctx, fc.Args["input"].(model.NewInboxInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Inbox
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Inbox
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Inbox); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Inbox`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateInbox(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateInboxInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Inbox
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Inbox
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Inbox); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Inbox`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Inbox)
	fc.Result = res
	return ec.marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Inbox_id(ctx, field)
			case "type":
				return ec.fieldContext_Inbox_type(ctx, field)
			case "title":
				return ec.fieldContext_Inbox_title(ctx, field)
			case "description":
				return ec.fieldContext_Inbox_description(ctx, field)
			case "status":
				return ec.fieldContext_Inbox_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Inbox_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Inbox_userId(ctx, field)
			case "user":
				return ec.fieldContext_Inbox_user(ctx, field)
			case "fromId":
				return ec.fieldContext_Inbox_fromId(ctx, field)
			case "FromUser":
				return ec.fieldContext_Inbox_FromUser(ctx, field)
			case "openedAt":
				return ec.fieldContext_Inbox_openedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Inbox_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Inbox_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Inbox_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Inbox", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteInbox(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteInbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteInbox(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteInbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteInbox_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateLog(rctx, fc.Args["input"].(model.NewLogInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Log
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Log
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Log); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Log`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Log)
	fc.Result = res
	return ec.marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteLog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteLog(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMenu(rctx, fc.Args["input"].(model.NewMenuInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Menu
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Menu
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Menu); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Menu`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMenu(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateMenuInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Menu
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Menu
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Menu); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Menu`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMenu(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMenu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMenu(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMenu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMenu_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateNotification(rctx, fc.Args["input"].(model.NewNotificationInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Notification
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Notification
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Notification); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Notification`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateNotification(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateNotificationInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Notification
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Notification
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Notification); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Notification`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteNotification(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteNotification(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteNotification_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateQna(rctx, fc.Args["input"].(model.NewQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateQna(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_replyQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_replyQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReplyQna(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateQnaInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Qna
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Qna
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Qna); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Qna`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Qna)
	fc.Result = res
	return ec.marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_replyQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_replyQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteQna(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_completeQna(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_completeQna(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CompleteQna(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_completeQna(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_completeQna_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSetting(rctx, fc.Args["input"].(model.NewSettingInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2githubcomhotbrainygobettingbackendgraphmodelSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSetting(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateSettingInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2githubcomhotbrainygobettingbackendgraphmodelSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSetting(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSMSApi(rctx, fc.Args["input"].(model.NewSMSApiInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.SMSApi
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.SMSApi
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.SMSApi); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.SMSApi`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSMSApi(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateSMSApiInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.SMSApi
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.SMSApi
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.SMSApi); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.SMSApi`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSMSApi(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSMSApi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSMSApi(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSMSApi(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSMSApi_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTodo(rctx, fc.Args["input"].(model.NewTodo))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Todo)
	fc.Result = res
	return ec.marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTodo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTransaction(rctx, fc.Args["input"].(model.NewTransactionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Transaction
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Transaction
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Transaction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Transaction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTransaction(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateTransactionInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.Transaction
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.Transaction
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Transaction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Transaction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_blockTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_blockTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BlockTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_blockTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_blockTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_waitingTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_waitingTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().WaitingTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_waitingTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_waitingTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelTransaction(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateProfile(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateProfile))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Profile
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Profile); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Profile`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Profile)
	fc.Result = res
	return ec.marshalNProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProfile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProfile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteProfile(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProfile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProfile_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(*model.NewUser))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveUser(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_blockUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_blockUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BlockUser(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_blockUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_blockUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(uint), fc.Args["input"].(model.UpdateUser))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Notification_id(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_title(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_description(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_status(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_showFrom(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_showFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().ShowFrom(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_showFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_mainImage(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_mainImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_mainImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_imageUpload(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_imageUpload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUpload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_imageUpload(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_noticeType(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_noticeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoticeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_noticeType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_registerDate(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_registerDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegisterDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_registerDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_level(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_domain(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Domain)
	fc.Result = res
	return ec.marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_views(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_showTo(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_showTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().ShowTo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_showTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationList_notifications(ctx context.Context, field graphql.CollectedField, obj *model.NotificationList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationList_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Notification)
	fc.Result = res
	return ec.marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationList_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationList_total(ctx context.Context, field graphql.CollectedField, obj *model.NotificationList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_id(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_userId(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_name(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_nickname(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_nickname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_bankName(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_bankName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_bankName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_holderName(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_holderName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HolderName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_holderName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_accountNumber(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_accountNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_accountNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_birthday(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_birthday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Birthday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_birthday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_phone(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_mobile(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_mobile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mobile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_mobile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_phoneVerified(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_phoneVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhoneVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_phoneVerified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_balance(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_balance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_roll(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_roll(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roll, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_roll(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_point(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_point(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Point, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_point(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_comp(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_comp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_comp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_level(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_coupon(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_coupon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coupon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_coupon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_favorites(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_favorites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Favorites, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_favorites(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_referral(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_referral(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Referral, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_referral(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_avatarUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_bio(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_bio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_socialLinks(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_socialLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_socialLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_lastDeposit(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_lastDeposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDeposit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_lastDeposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_lastWithdraw(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_lastWithdraw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastWithdraw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_lastWithdraw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_id(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_userId(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_user(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_domainId(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_domainId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DomainID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_domainId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_domain(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Domain)
	fc.Result = res
	return ec.marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_type(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_question(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_question(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Question, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_question(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_questionTitle(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_questionTitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuestionTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_questionTitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_answer(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_answer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Answer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_answer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_answerTitle(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_answerTitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnswerTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_answerTitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_status(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_repliedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_repliedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepliedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_repliedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Qna_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Qna) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Qna_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Qna_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Qna",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QnaList_qnas(ctx context.Context, field graphql.CollectedField, obj *model.QnaList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QnaList_qnas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Qnas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Qna)
	fc.Result = res
	return ec.marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QnaList_qnas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QnaList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Qna_id(ctx, field)
			case "userId":
				return ec.fieldContext_Qna_userId(ctx, field)
			case "user":
				return ec.fieldContext_Qna_user(ctx, field)
			case "domainId":
				return ec.fieldContext_Qna_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Qna_domain(ctx, field)
			case "type":
				return ec.fieldContext_Qna_type(ctx, field)
			case "question":
				return ec.fieldContext_Qna_question(ctx, field)
			case "questionTitle":
				return ec.fieldContext_Qna_questionTitle(ctx, field)
			case "answer":
				return ec.fieldContext_Qna_answer(ctx, field)
			case "answerTitle":
				return ec.fieldContext_Qna_answerTitle(ctx, field)
			case "status":
				return ec.fieldContext_Qna_status(ctx, field)
			case "repliedAt":
				return ec.fieldContext_Qna_repliedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Qna_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Qna_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Qna_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Qna", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QnaList_total(ctx context.Context, field graphql.CollectedField, obj *model.QnaList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QnaList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QnaList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QnaList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_time(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminPermissions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminPermissions(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminPermissionList)
	fc.Result = res
	return ec.marshalNAdminPermissionList2githubcomhotbrainygobettingbackendgraphmodelAdminPermissionList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminPermissions":
				return ec.fieldContext_AdminPermissionList_adminPermissions(ctx, field)
			case "total":
				return ec.fieldContext_AdminPermissionList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminPermissionList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_announcements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Announcements(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_announcements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "description":
				return ec.fieldContext_Announcement_description(ctx, field)
			case "status":
				return ec.fieldContext_Announcement_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Announcement_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Announcement_user(ctx, field)
			case "userId":
				return ec.fieldContext_Announcement_userId(ctx, field)
			case "showFrom":
				return ec.fieldContext_Announcement_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Announcement_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Announcement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Announcement_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Announcement_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAnnouncements(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.AnnouncementList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.AnnouncementList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.AnnouncementList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.AnnouncementList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AnnouncementList)
	fc.Result = res
	return ec.marshalNAnnouncementList2githubcomhotbrainygobettingbackendgraphmodelAnnouncementList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "announcements":
				return ec.fieldContext_AnnouncementList_announcements(ctx, field)
			case "total":
				return ec.fieldContext_AnnouncementList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AnnouncementList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncements_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBanks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBanks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBanks(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.BankList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.BankList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BankList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.BankList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BankList)
	fc.Result = res
	return ec.marshalNBankList2githubcomhotbrainygobettingbackendgraphmodelBankList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBanks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banks":
				return ec.fieldContext_BankList_banks(ctx, field)
			case "total":
				return ec.fieldContext_BankList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BankList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBanks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_domains(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_domains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Domains(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Domain)
	fc.Result = res
	return ec.marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_domains(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Domain_id(ctx, field)
			case "name":
				return ec.fieldContext_Domain_name(ctx, field)
			case "description":
				return ec.fieldContext_Domain_description(ctx, field)
			case "status":
				return ec.fieldContext_Domain_status(ctx, field)
			case "autoReg":
				return ec.fieldContext_Domain_autoReg(ctx, field)
			case "useTelegram":
				return ec.fieldContext_Domain_useTelegram(ctx, field)
			case "telegram":
				return ec.fieldContext_Domain_telegram(ctx, field)
			case "telegramLink":
				return ec.fieldContext_Domain_telegramLink(ctx, field)
			case "useKakaoTalk":
				return ec.fieldContext_Domain_useKakaoTalk(ctx, field)
			case "kakaoTalk":
				return ec.fieldContext_Domain_kakaoTalk(ctx, field)
			case "kakaoTalkLink":
				return ec.fieldContext_Domain_kakaoTalkLink(ctx, field)
			case "useServiceCenter":
				return ec.fieldContext_Domain_useServiceCenter(ctx, field)
			case "serviceCenter":
				return ec.fieldContext_Domain_serviceCenter(ctx, field)
			case "serviceCenterLink":
				return ec.fieldContext_Domain_serviceCenterLink(ctx, field)
			case "useLiveDomain":
				return ec.fieldContext_Domain_useLiveDomain(ctx, field)
			case "liveDomain":
				return ec.fieldContext_Domain_liveDomain(ctx, field)
			case "liveDomainLink":
				return ec.fieldContext_Domain_liveDomainLink(ctx, field)
			case "memberLevel":
				return ec.fieldContext_Domain_memberLevel(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_Domain_distributorLevel(ctx, field)
			case "orderNum":
				return ec.fieldContext_Domain_orderNum(ctx, field)
			case "userId":
				return ec.fieldContext_Domain_userId(ctx, field)
			case "user":
				return ec.fieldContext_Domain_user(ctx, field)
			case "createdAt":
				return ec.fieldContext_Domain_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Domain_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Domain_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Domain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDomains(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDomains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDomains(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.DomainList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.DomainList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DomainList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.DomainList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DomainList)
	fc.Result = res
	return ec.marshalNDomainList2githubcomhotbrainygobettingbackendgraphmodelDomainList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDomains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "domains":
				return ec.fieldContext_DomainList_domains(ctx, field)
			case "total":
				return ec.fieldContext_DomainList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DomainList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDomains_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_topEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_topEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TopEvents(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_topEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "title":
				return ec.fieldContext_Event_title(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "status":
				return ec.fieldContext_Event_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Event_orderNum(ctx, field)
			case "user":
				return ec.fieldContext_Event_user(ctx, field)
			case "userId":
				return ec.fieldContext_Event_userId(ctx, field)
			case "domainId":
				return ec.fieldContext_Event_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Event_domain(ctx, field)
			case "showFrom":
				return ec.fieldContext_Event_showFrom(ctx, field)
			case "showTo":
				return ec.fieldContext_Event_showTo(ctx, field)
			case "category":
				return ec.fieldContext_Event_category(ctx, field)
			case "views":
				return ec.fieldContext_Event_views(ctx, field)
			case "mainImage":
				return ec.fieldContext_Event_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Event_imageUpload(ctx, field)
			case "level":
				return ec.fieldContext_Event_level(ctx, field)
			case "createdDate":
				return ec.fieldContext_Event_createdDate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Event_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetEvents(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.EventList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.EventList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.EventList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.EventList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EventList)
	fc.Result = res
	return ec.marshalNEventList2githubcomhotbrainygobettingbackendgraphmodelEventList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_EventList_events(ctx, field)
			case "total":
				return ec.fieldContext_EventList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGameApis(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGameApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGameApis(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.GameAPIList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.GameAPIList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GameAPIList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.GameAPIList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GameAPIList)
	fc.Result = res
	return ec.marshalNGameAPIList2githubcomhotbrainygobettingbackendgraphmodelGameAPIList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGameApis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gameApis":
				return ec.fieldContext_GameAPIList_gameApis(ctx, field)
			case "total":
				return ec.fieldContext_GameAPIList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameAPIList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGameApis_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getInboxes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getInboxes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetInboxes(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.InboxList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.InboxList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.InboxList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.InboxList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.InboxList)
	fc.Result = res
	return ec.marshalNInboxList2githubcomhotbrainygobettingbackendgraphmodelInboxList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getInboxes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "inboxes":
				return ec.fieldContext_InboxList_inboxes(ctx, field)
			case "total":
				return ec.fieldContext_InboxList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InboxList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getInboxes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_logs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Logs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Log)
	fc.Result = res
	return ec.marshalOLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Log_id(ctx, field)
			case "data":
				return ec.fieldContext_Log_data(ctx, field)
			case "path":
				return ec.fieldContext_Log_path(ctx, field)
			case "phone":
				return ec.fieldContext_Log_phone(ctx, field)
			case "method":
				return ec.fieldContext_Log_method(ctx, field)
			case "type":
				return ec.fieldContext_Log_type(ctx, field)
			case "ip":
				return ec.fieldContext_Log_ip(ctx, field)
			case "userId":
				return ec.fieldContext_Log_userId(ctx, field)
			case "user":
				return ec.fieldContext_Log_user(ctx, field)
			case "status":
				return ec.fieldContext_Log_status(ctx, field)
			case "os":
				return ec.fieldContext_Log_os(ctx, field)
			case "device":
				return ec.fieldContext_Log_device(ctx, field)
			case "host":
				return ec.fieldContext_Log_host(ctx, field)
			case "createdAt":
				return ec.fieldContext_Log_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Log_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Log_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Log", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetLogs(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.LogList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.LogList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.LogList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.LogList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LogList)
	fc.Result = res
	return ec.marshalNLogList2githubcomhotbrainygobettingbackendgraphmodelLogList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "logs":
				return ec.fieldContext_LogList_logs(ctx, field)
			case "total":
				return ec.fieldContext_LogList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUserMenus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUserMenus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUserMenus(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Menu)
	fc.Result = res
	return ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUserMenus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Menu_id(ctx, field)
			case "path":
				return ec.fieldContext_Menu_path(ctx, field)
			case "label":
				return ec.fieldContext_Menu_label(ctx, field)
			case "key":
				return ec.fieldContext_Menu_key(ctx, field)
			case "icon":
				return ec.fieldContext_Menu_icon(ctx, field)
			case "description":
				return ec.fieldContext_Menu_description(ctx, field)
			case "status":
				return ec.fieldContext_Menu_status(ctx, field)
			case "parentId":
				return ec.fieldContext_Menu_parentId(ctx, field)
			case "children":
				return ec.fieldContext_Menu_children(ctx, field)
			case "orderNum":
				return ec.fieldContext_Menu_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Menu_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Menu_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Menu_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Menu", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMenus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMenus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMenus(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.MenuList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.MenuList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MenuList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.MenuList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MenuList)
	fc.Result = res
	return ec.marshalNMenuList2githubcomhotbrainygobettingbackendgraphmodelMenuList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMenus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "menus":
				return ec.fieldContext_MenuList_menus(ctx, field)
			case "total":
				return ec.fieldContext_MenuList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MenuList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMenus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_notifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Notifications(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Notification)
	fc.Result = res
	return ec.marshalONotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Notification_id(ctx, field)
			case "title":
				return ec.fieldContext_Notification_title(ctx, field)
			case "description":
				return ec.fieldContext_Notification_description(ctx, field)
			case "status":
				return ec.fieldContext_Notification_status(ctx, field)
			case "orderNum":
				return ec.fieldContext_Notification_orderNum(ctx, field)
			case "showFrom":
				return ec.fieldContext_Notification_showFrom(ctx, field)
			case "mainImage":
				return ec.fieldContext_Notification_mainImage(ctx, field)
			case "imageUpload":
				return ec.fieldContext_Notification_imageUpload(ctx, field)
			case "noticeType":
				return ec.fieldContext_Notification_noticeType(ctx, field)
			case "registerDate":
				return ec.fieldContext_Notification_registerDate(ctx, field)
			case "level":
				return ec.fieldContext_Notification_level(ctx, field)
			case "domainId":
				return ec.fieldContext_Notification_domainId(ctx, field)
			case "domain":
				return ec.fieldContext_Notification_domain(ctx, field)
			case "views":
				return ec.fieldContext_Notification_views(ctx, field)
			case "showTo":
				return ec.fieldContext_Notification_showTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Notification_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Notification_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Notification_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetNotifications(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.NotificationList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.NotificationList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.NotificationList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.NotificationList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NotificationList)
	fc.Result = res
	return ec.marshalNNotificationList2githubcomhotbrainygobettingbackendgraphmodelNotificationList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "notifications":
				return ec.fieldContext_NotificationList_notifications(ctx, field)
			case "total":
				return ec.fieldContext_NotificationList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getNotifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getQnas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getQnas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetQnas(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.QnaList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.QnaList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.QnaList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.QnaList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.QnaList)
	fc.Result = res
	return ec.marshalNQnaList2githubcomhotbrainygobettingbackendgraphmodelQnaList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getQnas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "qnas":
				return ec.fieldContext_QnaList_qnas(ctx, field)
			case "total":
				return ec.fieldContext_QnaList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QnaList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getQnas_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetSetting(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.Setting
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.Setting
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Setting); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.Setting`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Setting)
	fc.Result = res
	return ec.marshalNSetting2githubcomhotbrainygobettingbackendgraphmodelSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Setting_id(ctx, field)
			case "status":
				return ec.fieldContext_Setting_status(ctx, field)
			case "title":
				return ec.fieldContext_Setting_title(ctx, field)
			case "description":
				return ec.fieldContext_Setting_description(ctx, field)
			case "primaryDomain":
				return ec.fieldContext_Setting_primaryDomain(ctx, field)
			case "userId":
				return ec.fieldContext_Setting_userId(ctx, field)
			case "user":
				return ec.fieldContext_Setting_user(ctx, field)
			case "orderNum":
				return ec.fieldContext_Setting_orderNum(ctx, field)
			case "totalExStatus":
				return ec.fieldContext_Setting_totalExStatus(ctx, field)
			case "totalExFrom":
				return ec.fieldContext_Setting_totalExFrom(ctx, field)
			case "totalExTo":
				return ec.fieldContext_Setting_totalExTo(ctx, field)
			case "totalReStatus":
				return ec.fieldContext_Setting_totalReStatus(ctx, field)
			case "totalReFrom":
				return ec.fieldContext_Setting_totalReFrom(ctx, field)
			case "totalReTo":
				return ec.fieldContext_Setting_totalReTo(ctx, field)
			case "userExStatus":
				return ec.fieldContext_Setting_userExStatus(ctx, field)
			case "userExFrom":
				return ec.fieldContext_Setting_userExFrom(ctx, field)
			case "userExTo":
				return ec.fieldContext_Setting_userExTo(ctx, field)
			case "userReStatus":
				return ec.fieldContext_Setting_userReStatus(ctx, field)
			case "userReFrom":
				return ec.fieldContext_Setting_userReFrom(ctx, field)
			case "userReTo":
				return ec.fieldContext_Setting_userReTo(ctx, field)
			case "createdAt":
				return ec.fieldContext_Setting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Setting_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Setting_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Setting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMSApis(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMSApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetSMSApis(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.SMSApiList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.SMSApiList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SMSApiList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.SMSApiList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SMSApiList)
	fc.Result = res
	return ec.marshalNSMSApiList2githubcomhotbrainygobettingbackendgraphmodelSMSApiList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMSApis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "smsApis":
				return ec.fieldContext_SMSApiList_smsApis(ctx, field)
			case "total":
				return ec.fieldContext_SMSApiList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApiList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMSApis_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_todos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_todos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Todos(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Todo)
	fc.Result = res
	return ec.marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_todos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetTransactions(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.TransactionList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.TransactionList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TransactionList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.TransactionList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TransactionList)
	fc.Result = res
	return ec.marshalNTransactionList2githubcomhotbrainygobettingbackendgraphmodelTransactionList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "transactions":
				return ec.fieldContext_TransactionList_transactions(ctx, field)
			case "total":
				return ec.fieldContext_TransactionList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getWeeklyLosingData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getWeeklyLosingData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWeeklyLosingData(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.WeeklyLosingDataList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.WeeklyLosingDataList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WeeklyLosingDataList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.WeeklyLosingDataList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WeeklyLosingDataList)
	fc.Result = res
	return ec.marshalNWeeklyLosingDataList2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingDataList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getWeeklyLosingData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "weeklyLosingData":
				return ec.fieldContext_WeeklyLosingDataList_weeklyLosingData(ctx, field)
			case "total":
				return ec.fieldContext_WeeklyLosingDataList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeeklyLosingDataList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getWeeklyLosingData_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_profile(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Profile(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.Profile
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Profile); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.Profile`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Profile)
	fc.Result = res
	return ec.marshalNProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_profile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Me(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.Auth == nil {
				var zeroVal *models.User
				return zeroVal, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Users(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal []*models.User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*models.User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_filterUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_filterUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FilterUsers(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_filterUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_filterUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectedUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ConnectedUsers(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectedUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().User(rctx, fc.Args["id"].(uint))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *models.User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *models.User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/internal/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDistributors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDistributors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDistributors(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDistributors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDistributors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDistributorDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDistributorDetails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetDistributorDetails(rctx, fc.Args["filters"].([]*model.Filter), fc.Args["orders"].([]*model.Order), fc.Args["pagination"].(*model.Pagination))
		}

		directive1 := func(ctx context.Context) (any, error) {
			role, err := ec.unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx, "A")
			if err != nil {
				var zeroVal *model.UserList
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *model.UserList
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/hotbrainy/go-betting/backend/graph/model.UserList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserList)
	fc.Result = res
	return ec.marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDistributorDetails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_UserList_users(ctx, field)
			case "total":
				return ec.fieldContext_UserList_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserList", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDistributorDetails_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_id(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_name(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_url(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_agent(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_agent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_agent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_password(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_password(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_token(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_status(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApi_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.SMSApi) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApi_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApi_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApi",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApiList_smsApis(ctx context.Context, field graphql.CollectedField, obj *model.SMSApiList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApiList_smsApis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SmsApis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.SMSApi)
	fc.Result = res
	return ec.marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApiList_smsApis(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApiList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMSApi_id(ctx, field)
			case "name":
				return ec.fieldContext_SMSApi_name(ctx, field)
			case "url":
				return ec.fieldContext_SMSApi_url(ctx, field)
			case "agent":
				return ec.fieldContext_SMSApi_agent(ctx, field)
			case "password":
				return ec.fieldContext_SMSApi_password(ctx, field)
			case "token":
				return ec.fieldContext_SMSApi_token(ctx, field)
			case "orderNum":
				return ec.fieldContext_SMSApi_orderNum(ctx, field)
			case "status":
				return ec.fieldContext_SMSApi_status(ctx, field)
			case "createdAt":
				return ec.fieldContext_SMSApi_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_SMSApi_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SMSApi_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMSApi", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMSApiList_total(ctx context.Context, field graphql.CollectedField, obj *model.SMSApiList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMSApiList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMSApiList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMSApiList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_id(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_status(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_title(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_description(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_primaryDomain(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_primaryDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimaryDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_primaryDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userId(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_user(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_orderNum(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalExTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalExTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalExTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_totalReTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_totalReTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalReTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_totalReTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userExTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userExTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userExTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReStatus(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReFrom(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReFrom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_userReTo(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_userReTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_userReTo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Setting_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Setting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Setting_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Setting_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Setting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_time(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_time(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Time(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan string):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNString2string(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_id(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_text(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_done(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Done, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_done(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_user(ctx context.Context, field graphql.CollectedField, obj *model.Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_userId(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_user(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_type(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_amount(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_balanceBefore(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_balanceBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_balanceBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_balanceAfter(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_balanceAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BalanceAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_balanceAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pointBefore(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pointBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pointBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_pointAfter(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_pointAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PointAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_pointAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_status(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_shortcut(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_shortcut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shortcut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_shortcut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_usdtDesc(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_usdtDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.USDTDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_usdtDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_transactionAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_transactionAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_transactionAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_approvedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_approvedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_approvedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionList_transactions(ctx context.Context, field graphql.CollectedField, obj *model.TransactionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionList_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionList_transactions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Transaction_id(ctx, field)
			case "userId":
				return ec.fieldContext_Transaction_userId(ctx, field)
			case "user":
				return ec.fieldContext_Transaction_user(ctx, field)
			case "type":
				return ec.fieldContext_Transaction_type(ctx, field)
			case "amount":
				return ec.fieldContext_Transaction_amount(ctx, field)
			case "balanceBefore":
				return ec.fieldContext_Transaction_balanceBefore(ctx, field)
			case "balanceAfter":
				return ec.fieldContext_Transaction_balanceAfter(ctx, field)
			case "pointBefore":
				return ec.fieldContext_Transaction_pointBefore(ctx, field)
			case "pointAfter":
				return ec.fieldContext_Transaction_pointAfter(ctx, field)
			case "status":
				return ec.fieldContext_Transaction_status(ctx, field)
			case "shortcut":
				return ec.fieldContext_Transaction_shortcut(ctx, field)
			case "usdtDesc":
				return ec.fieldContext_Transaction_usdtDesc(ctx, field)
			case "transactionAt":
				return ec.fieldContext_Transaction_transactionAt(ctx, field)
			case "approvedAt":
				return ec.fieldContext_Transaction_approvedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Transaction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Transaction_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Transaction_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionList_total(ctx context.Context, field graphql.CollectedField, obj *model.TransactionList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalNID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userid(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Userid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_type(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserType)
	fc.Result = res
	return ec.marshalNUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_role(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_usdtAddress(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_usdtAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.USDTAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_usdtAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_currentIP(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_currentIP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_currentIP(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_IP(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_IP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_IP(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rootId(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rootId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rootId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_root(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_root(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Root, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_root(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parentId(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOID2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parentId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parent(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_children(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.User)
	fc.Result = res
	return ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_children(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_childrenCount(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_childrenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildrenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_childrenCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_profile(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Profile)
	fc.Result = res
	return ec.marshalOProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_profile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Profile_id(ctx, field)
			case "userId":
				return ec.fieldContext_Profile_userId(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "nickname":
				return ec.fieldContext_Profile_nickname(ctx, field)
			case "bankName":
				return ec.fieldContext_Profile_bankName(ctx, field)
			case "holderName":
				return ec.fieldContext_Profile_holderName(ctx, field)
			case "accountNumber":
				return ec.fieldContext_Profile_accountNumber(ctx, field)
			case "birthday":
				return ec.fieldContext_Profile_birthday(ctx, field)
			case "phone":
				return ec.fieldContext_Profile_phone(ctx, field)
			case "mobile":
				return ec.fieldContext_Profile_mobile(ctx, field)
			case "phoneVerified":
				return ec.fieldContext_Profile_phoneVerified(ctx, field)
			case "balance":
				return ec.fieldContext_Profile_balance(ctx, field)
			case "roll":
				return ec.fieldContext_Profile_roll(ctx, field)
			case "point":
				return ec.fieldContext_Profile_point(ctx, field)
			case "comp":
				return ec.fieldContext_Profile_comp(ctx, field)
			case "level":
				return ec.fieldContext_Profile_level(ctx, field)
			case "coupon":
				return ec.fieldContext_Profile_coupon(ctx, field)
			case "favorites":
				return ec.fieldContext_Profile_favorites(ctx, field)
			case "referral":
				return ec.fieldContext_Profile_referral(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_Profile_avatarUrl(ctx, field)
			case "bio":
				return ec.fieldContext_Profile_bio(ctx, field)
			case "socialLinks":
				return ec.fieldContext_Profile_socialLinks(ctx, field)
			case "lastDeposit":
				return ec.fieldContext_Profile_lastDeposit(ctx, field)
			case "lastWithdraw":
				return ec.fieldContext_Profile_lastWithdraw(ctx, field)
			case "orderNum":
				return ec.fieldContext_Profile_orderNum(ctx, field)
			case "createdAt":
				return ec.fieldContext_Profile_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Profile_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Profile_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_status(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserStatus)
	fc.Result = res
	return ec.marshalNUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_blackMemo(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_blackMemo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlackMemo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_blackMemo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_orderNum(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_orderNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(uint)
	fc.Result = res
	return ec.marshalOUint2uint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_orderNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_os(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_device(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_device(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Device, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_device(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_fingerPrint(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_fingerPrint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FingerPrint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_fingerPrint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_live(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_live(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Live, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_live(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slot(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_hold(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_hold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_hold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_entireLosing(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_entireLosing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntireLosing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_entireLosing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdLosingBeDang(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdLosingBeDang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldLosingBeDang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdLosingBeDang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingMethod(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5PoleRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5PoleRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5PoleRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5PoleRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_membershipDeposit(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_membershipDeposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MembershipDeposit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_membershipDeposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_membershipWithdrawal(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_membershipWithdrawal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MembershipWithdrawal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_membershipWithdrawal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_totalWithdrawal(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_totalWithdrawal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWithdrawal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_totalWithdrawal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_numberOfMembers(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_numberOfMembers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().NumberOfMembers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int32)
	fc.Result = res
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_numberOfMembers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingHoldings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingHoldings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingHoldings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingHoldings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_liveWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_liveWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_liveWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_slotJackpot(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_slotJackpot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotJackpot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_slotJackpot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniDanpolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniDanpolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniDanpolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniDanpolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_miniCombinationWinnings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_miniCombinationWinnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MiniCombinationWinnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_miniCombinationWinnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDanpolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDanpolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDanpolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDanpolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDupolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDupolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDupolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDupolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports3poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports3poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports3poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports3poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports4poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports4poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports4poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports4poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5poleBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5poleBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5poleBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5poleBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sports5poleWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sports5poleWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sports5poleWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sports5poleWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sportsDapolWinner(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sportsDapolWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SportsDapolWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sportsDapolWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_virtualGameWinnings(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_virtualGameWinnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualGameWinnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_virtualGameWinnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lotusLottery(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lotusLottery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotusLottery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lotusLottery(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mgmWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mgmWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MgmWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mgmWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_touchWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_touchWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TouchWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_touchWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdemBetting(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdemBetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldemBetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdemBetting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_holdemWinning(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_holdemWinning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldemWinning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_holdemWinning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingRate(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_rollingTransition(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_rollingTransition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RollingTransition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_rollingTransition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingRate(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_losingSettlement(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_losingSettlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LosingSettlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_losingSettlement(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_partnershipRolling(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_partnershipRolling(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartnershipRolling, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_partnershipRolling(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_partnershipMoneyInHand(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartnershipMoneyInHand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_partnershipMoneyInHand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gorm.DeletedAt)
	fc.Result = res
	return ec.marshalODeletedAt2gormiogormDeletedAt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeletedAt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserList_users(ctx context.Context, field graphql.CollectedField, obj *model.UserList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserList_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserList_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "userid":
				return ec.fieldContext_User_userid(ctx, field)
			case "type":
				return ec.fieldContext_User_type(ctx, field)
			case "role":
				return ec.fieldContext_User_role(ctx, field)
			case "usdtAddress":
				return ec.fieldContext_User_usdtAddress(ctx, field)
			case "currentIP":
				return ec.fieldContext_User_currentIP(ctx, field)
			case "IP":
				return ec.fieldContext_User_IP(ctx, field)
			case "rootId":
				return ec.fieldContext_User_rootId(ctx, field)
			case "root":
				return ec.fieldContext_User_root(ctx, field)
			case "parentId":
				return ec.fieldContext_User_parentId(ctx, field)
			case "parent":
				return ec.fieldContext_User_parent(ctx, field)
			case "children":
				return ec.fieldContext_User_children(ctx, field)
			case "childrenCount":
				return ec.fieldContext_User_childrenCount(ctx, field)
			case "profile":
				return ec.fieldContext_User_profile(ctx, field)
			case "status":
				return ec.fieldContext_User_status(ctx, field)
			case "blackMemo":
				return ec.fieldContext_User_blackMemo(ctx, field)
			case "orderNum":
				return ec.fieldContext_User_orderNum(ctx, field)
			case "os":
				return ec.fieldContext_User_os(ctx, field)
			case "device":
				return ec.fieldContext_User_device(ctx, field)
			case "fingerPrint":
				return ec.fieldContext_User_fingerPrint(ctx, field)
			case "live":
				return ec.fieldContext_User_live(ctx, field)
			case "slot":
				return ec.fieldContext_User_slot(ctx, field)
			case "hold":
				return ec.fieldContext_User_hold(ctx, field)
			case "entireLosing":
				return ec.fieldContext_User_entireLosing(ctx, field)
			case "liveLosingBeDang":
				return ec.fieldContext_User_liveLosingBeDang(ctx, field)
			case "slotLosingBeDang":
				return ec.fieldContext_User_slotLosingBeDang(ctx, field)
			case "holdLosingBeDang":
				return ec.fieldContext_User_holdLosingBeDang(ctx, field)
			case "losingMethod":
				return ec.fieldContext_User_losingMethod(ctx, field)
			case "miniDanpolRolling":
				return ec.fieldContext_User_miniDanpolRolling(ctx, field)
			case "miniCombinationRolling":
				return ec.fieldContext_User_miniCombinationRolling(ctx, field)
			case "sportsDanpolRolling":
				return ec.fieldContext_User_sportsDanpolRolling(ctx, field)
			case "sportsDupolRolling":
				return ec.fieldContext_User_sportsDupolRolling(ctx, field)
			case "sports3PoleRolling":
				return ec.fieldContext_User_sports3PoleRolling(ctx, field)
			case "sports4PoleRolling":
				return ec.fieldContext_User_sports4PoleRolling(ctx, field)
			case "sports5PoleRolling":
				return ec.fieldContext_User_sports5PoleRolling(ctx, field)
			case "sportsDapolRolling":
				return ec.fieldContext_User_sportsDapolRolling(ctx, field)
			case "virtualGameRolling":
				return ec.fieldContext_User_virtualGameRolling(ctx, field)
			case "lotusRolling":
				return ec.fieldContext_User_lotusRolling(ctx, field)
			case "mgmRolling":
				return ec.fieldContext_User_mgmRolling(ctx, field)
			case "touchRolling":
				return ec.fieldContext_User_touchRolling(ctx, field)
			case "membershipDeposit":
				return ec.fieldContext_User_membershipDeposit(ctx, field)
			case "membershipWithdrawal":
				return ec.fieldContext_User_membershipWithdrawal(ctx, field)
			case "totalWithdrawal":
				return ec.fieldContext_User_totalWithdrawal(ctx, field)
			case "numberOfMembers":
				return ec.fieldContext_User_numberOfMembers(ctx, field)
			case "rollingHoldings":
				return ec.fieldContext_User_rollingHoldings(ctx, field)
			case "liveBetting":
				return ec.fieldContext_User_liveBetting(ctx, field)
			case "liveWinning":
				return ec.fieldContext_User_liveWinning(ctx, field)
			case "slotBetting":
				return ec.fieldContext_User_slotBetting(ctx, field)
			case "slotJackpot":
				return ec.fieldContext_User_slotJackpot(ctx, field)
			case "miniDanpolBetting":
				return ec.fieldContext_User_miniDanpolBetting(ctx, field)
			case "miniDanpolWinner":
				return ec.fieldContext_User_miniDanpolWinner(ctx, field)
			case "miniCombinationBetting":
				return ec.fieldContext_User_miniCombinationBetting(ctx, field)
			case "miniCombinationWinnings":
				return ec.fieldContext_User_miniCombinationWinnings(ctx, field)
			case "sportsDanpolBetting":
				return ec.fieldContext_User_sportsDanpolBetting(ctx, field)
			case "sportsDanpolWinner":
				return ec.fieldContext_User_sportsDanpolWinner(ctx, field)
			case "sportsDupolBetting":
				return ec.fieldContext_User_sportsDupolBetting(ctx, field)
			case "sportsDupolWinner":
				return ec.fieldContext_User_sportsDupolWinner(ctx, field)
			case "sports3poleBetting":
				return ec.fieldContext_User_sports3poleBetting(ctx, field)
			case "sports3poleWinner":
				return ec.fieldContext_User_sports3poleWinner(ctx, field)
			case "sports4poleBetting":
				return ec.fieldContext_User_sports4poleBetting(ctx, field)
			case "sports4poleWinner":
				return ec.fieldContext_User_sports4poleWinner(ctx, field)
			case "sports5poleBetting":
				return ec.fieldContext_User_sports5poleBetting(ctx, field)
			case "sports5poleWinner":
				return ec.fieldContext_User_sports5poleWinner(ctx, field)
			case "sportsDapolBetting":
				return ec.fieldContext_User_sportsDapolBetting(ctx, field)
			case "sportsDapolWinner":
				return ec.fieldContext_User_sportsDapolWinner(ctx, field)
			case "virtualGameBetting":
				return ec.fieldContext_User_virtualGameBetting(ctx, field)
			case "virtualGameWinnings":
				return ec.fieldContext_User_virtualGameWinnings(ctx, field)
			case "lotusBetting":
				return ec.fieldContext_User_lotusBetting(ctx, field)
			case "lotusLottery":
				return ec.fieldContext_User_lotusLottery(ctx, field)
			case "mgmBetting":
				return ec.fieldContext_User_mgmBetting(ctx, field)
			case "mgmWinning":
				return ec.fieldContext_User_mgmWinning(ctx, field)
			case "touchBetting":
				return ec.fieldContext_User_touchBetting(ctx, field)
			case "touchWinning":
				return ec.fieldContext_User_touchWinning(ctx, field)
			case "holdemBetting":
				return ec.fieldContext_User_holdemBetting(ctx, field)
			case "holdemWinning":
				return ec.fieldContext_User_holdemWinning(ctx, field)
			case "rollingRate":
				return ec.fieldContext_User_rollingRate(ctx, field)
			case "rollingTransition":
				return ec.fieldContext_User_rollingTransition(ctx, field)
			case "losingRate":
				return ec.fieldContext_User_losingRate(ctx, field)
			case "losingSettlement":
				return ec.fieldContext_User_losingSettlement(ctx, field)
			case "partnershipRolling":
				return ec.fieldContext_User_partnershipRolling(ctx, field)
			case "partnershipMoneyInHand":
				return ec.fieldContext_User_partnershipMoneyInHand(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserList_total(ctx context.Context, field graphql.CollectedField, obj *model.UserList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_weekStart(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_weekStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeekStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_weekStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_weekEnd(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_weekEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeekEnd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_weekEnd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_site(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_site(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Site, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_site(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorID(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorName(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_distributorLevel(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_distributorLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistributorLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_distributorLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_nickname(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_nickname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_depositor(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_depositor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Depositor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_depositor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_alias(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalBet(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalBet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalBet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalBet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalWinner(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalWinner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_totalLosingMoney(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_totalLosingMoney(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalLosingMoney, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_totalLosingMoney(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_settlementAmount(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_settlementAmount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SettlementAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_settlementAmount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_applicationDate(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_applicationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_applicationDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_processingDate(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_processingDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessingDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_processingDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_situation(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_situation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Situation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_situation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingData_userCount(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingData_userCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingData_userCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingDataList_weeklyLosingData(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingDataList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingDataList_weeklyLosingData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeeklyLosingData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WeeklyLosingData)
	fc.Result = res
	return ec.marshalNWeeklyLosingData2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingDataList_weeklyLosingData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingDataList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "weekStart":
				return ec.fieldContext_WeeklyLosingData_weekStart(ctx, field)
			case "weekEnd":
				return ec.fieldContext_WeeklyLosingData_weekEnd(ctx, field)
			case "site":
				return ec.fieldContext_WeeklyLosingData_site(ctx, field)
			case "distributorID":
				return ec.fieldContext_WeeklyLosingData_distributorID(ctx, field)
			case "distributorName":
				return ec.fieldContext_WeeklyLosingData_distributorName(ctx, field)
			case "distributorLevel":
				return ec.fieldContext_WeeklyLosingData_distributorLevel(ctx, field)
			case "nickname":
				return ec.fieldContext_WeeklyLosingData_nickname(ctx, field)
			case "depositor":
				return ec.fieldContext_WeeklyLosingData_depositor(ctx, field)
			case "alias":
				return ec.fieldContext_WeeklyLosingData_alias(ctx, field)
			case "totalBet":
				return ec.fieldContext_WeeklyLosingData_totalBet(ctx, field)
			case "totalWinner":
				return ec.fieldContext_WeeklyLosingData_totalWinner(ctx, field)
			case "totalLosingMoney":
				return ec.fieldContext_WeeklyLosingData_totalLosingMoney(ctx, field)
			case "settlementAmount":
				return ec.fieldContext_WeeklyLosingData_settlementAmount(ctx, field)
			case "applicationDate":
				return ec.fieldContext_WeeklyLosingData_applicationDate(ctx, field)
			case "processingDate":
				return ec.fieldContext_WeeklyLosingData_processingDate(ctx, field)
			case "situation":
				return ec.fieldContext_WeeklyLosingData_situation(ctx, field)
			case "userCount":
				return ec.fieldContext_WeeklyLosingData_userCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeeklyLosingData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeeklyLosingDataList_total(ctx context.Context, field graphql.CollectedField, obj *model.WeeklyLosingDataList) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeeklyLosingDataList_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeeklyLosingDataList_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeeklyLosingDataList",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputFilter(ctx context.Context, obj any) (model.Filter, error) {
	var it model.Filter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["op"]; !present {
		asMap["op"] = "eq"
	}

	fieldsInOrder := [...]string{"field", "value", "op", "or", "and"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "op":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("op"))
			data, err := ec.unmarshalOOp2githubcomhotbrainygobettingbackendgraphmodelOp(ctx, v)
			if err != nil {
				return it, err
			}
			it.Op = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAdminPermission(ctx context.Context, obj any) (model.NewAdminPermission, error) {
	var it model.NewAdminPermission
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "membership", "financials", "qna", "game", "settlement", "sale", "status", "statistical", "ip", "dwdelete"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "membership":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("membership"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Membership = data
		case "financials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financials"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Financials = data
		case "qna":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qna"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Qna = data
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "settlement":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlement"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Settlement = data
		case "sale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sale"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sale = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "statistical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statistical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statistical = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "dwdelete":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dwdelete"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dwdelete = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAnnouncementInput(ctx context.Context, obj any) (model.NewAnnouncementInput, error) {
	var it model.NewAnnouncementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewBankInput(ctx context.Context, obj any) (model.NewBankInput, error) {
	var it model.NewBankInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewDomainInput(ctx context.Context, obj any) (model.NewDomainInput, error) {
	var it model.NewDomainInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "status", "userId", "autoReg", "orderNum", "useTelegram", "telegram", "telegramLink", "useKakaoTalk", "kakaoTalk", "kakaoTalkLink", "useServiceCenter", "serviceCenter", "serviceCenterLink", "useLiveDomain", "liveDomain", "liveDomainLink", "memberLevel", "distributorLevel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "autoReg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoReg"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoReg = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "useTelegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTelegram"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTelegram = data
		case "telegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegram"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Telegram = data
		case "telegramLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegramLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TelegramLink = data
		case "useKakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useKakaoTalk"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseKakaoTalk = data
		case "kakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalk"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalk = data
		case "kakaoTalkLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalkLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalkLink = data
		case "useServiceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useServiceCenter"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceCenter = data
		case "serviceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenter"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenter = data
		case "serviceCenterLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenterLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenterLink = data
		case "useLiveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useLiveDomain"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseLiveDomain = data
		case "liveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomain"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomain = data
		case "liveDomainLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomainLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomainLink = data
		case "memberLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberLevel"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemberLevel = data
		case "distributorLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distributorLevel"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistributorLevel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewEventInput(ctx context.Context, obj any) (model.NewEventInput, error) {
	var it model.NewEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "author", "category", "views", "createdDate", "showFrom", "showTo", "description", "mainImage", "imageUpload"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "author":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("author"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Author = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		case "createdDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedDate = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewGameApiInput(ctx context.Context, obj any) (model.NewGameAPIInput, error) {
	var it model.NewGameAPIInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiCompanyName", "gameApiName", "gameCompanyName", "gameType", "other", "whetherToUse", "order", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiCompanyName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APICompanyName = data
		case "gameApiName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameApiName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameAPIName = data
		case "gameCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameCompanyName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameCompanyName = data
		case "gameType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameType = data
		case "other":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("other"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Other = data
		case "whetherToUse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whetherToUse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WhetherToUse = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewInboxInput(ctx context.Context, obj any) (model.NewInboxInput, error) {
	var it model.NewInboxInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "title", "description", "status", "userId", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewLogInput(ctx context.Context, obj any) (model.NewLogInput, error) {
	var it model.NewLogInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "path", "method", "ip", "type", "phone", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewMenuInput(ctx context.Context, obj any) (model.NewMenuInput, error) {
	var it model.NewMenuInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"label", "key", "path", "icon", "parentId", "description", "status", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewNotificationInput(ctx context.Context, obj any) (model.NewNotificationInput, error) {
	var it model.NewNotificationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "mainImage", "imageUpload", "noticeType", "registerDate", "views"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		case "noticeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noticeType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoticeType = data
		case "registerDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registerDate"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegisterDate = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewProfile(ctx context.Context, obj any) (model.NewProfile, error) {
	var it model.NewProfile
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "name", "nickname", "bankName", "holderName", "accountNumber", "birthday", "phone", "mobile", "balance", "roll", "point", "comp", "level", "favorites", "referral", "avatarUrl", "bio", "socialLinks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "bankName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankName = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "accountNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountNumber"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountNumber = data
		case "birthday":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthday"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthday = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "mobile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Balance = data
		case "roll":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roll"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roll = data
		case "point":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("point"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Point = data
		case "comp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comp"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comp = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "favorites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorites"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorites = data
		case "referral":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referral"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Referral = data
		case "avatarUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "socialLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialLinks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SocialLinks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewQnaInput(ctx context.Context, obj any) (model.NewQnaInput, error) {
	var it model.NewQnaInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"question", "questionTitle", "type", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "question":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("question"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Question = data
		case "questionTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questionTitle"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestionTitle = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSMSApiInput(ctx context.Context, obj any) (model.NewSMSApiInput, error) {
	var it model.NewSMSApiInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "url", "agent", "password", "token", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "agent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agent"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Agent = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSettingInput(ctx context.Context, obj any) (model.NewSettingInput, error) {
	var it model.NewSettingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"status", "title", "description", "primaryDomain", "userId", "orderNum", "totalExStatus", "totalExFrom", "totalExTo", "totalReStatus", "totalReFrom", "totalReTo", "userExStatus", "userExFrom", "userExTo", "userReStatus", "userReFrom", "userReTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "primaryDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("primaryDomain"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryDomain = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "totalExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExStatus = data
		case "totalExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExFrom = data
		case "totalExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExTo = data
		case "totalReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReStatus = data
		case "totalReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReFrom = data
		case "totalReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReTo = data
		case "userExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExStatus = data
		case "userExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExFrom = data
		case "userExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExTo = data
		case "userReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReStatus = data
		case "userReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReFrom = data
		case "userReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTodo(ctx context.Context, obj any) (model.NewTodo, error) {
	var it model.NewTodo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTransactionInput(ctx context.Context, obj any) (model.NewTransactionInput, error) {
	var it model.NewTransactionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "type", "amount", "balanceBefore", "balanceAfter", "pointBefore", "pointAfter", "status", "shortcut", "usdtDesc"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "balanceBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceBefore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceBefore = data
		case "balanceAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAfter"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceAfter = data
		case "pointBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointBefore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointBefore = data
		case "pointAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointAfter"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointAfter = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "shortcut":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortcut"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Shortcut = data
		case "usdtDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtDesc = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUser(ctx context.Context, obj any) (model.NewUser, error) {
	var it model.NewUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userid", "type", "role", "password", "usdtAddress", "currentIP", "IP", "rootId", "parentId", "childrenCount", "status", "blackMemo", "orderNum", "os", "device", "fingerPrint", "domainId", "bankId", "holderName", "nickname", "phone", "settlementId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "usdtAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtAddress"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtAddress = data
		case "currentIP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentIP"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrentIP = data
		case "IP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("IP"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "rootId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootID = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "childrenCount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childrenCount"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildrenCount = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "blackMemo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blackMemo"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlackMemo = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "os":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("os"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Os = data
		case "device":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("device"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Device = data
		case "fingerPrint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerPrint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FingerPrint = data
		case "domainId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domainId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DomainID = data
		case "bankId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankID = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "settlementId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlementId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettlementID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrder(ctx context.Context, obj any) (model.Order, error) {
	var it model.Order
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"field", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOOrderDirection2githubcomhotbrainygobettingbackendgraphmodelOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj any) (model.Pagination, error) {
	var it model.Pagination
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 10
	}
	if _, present := asMap["offset"]; !present {
		asMap["offset"] = 0
	}

	fieldsInOrder := [...]string{"limit", "offset"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAdminPermissionInput(ctx context.Context, obj any) (model.UpdateAdminPermissionInput, error) {
	var it model.UpdateAdminPermissionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"membership", "financials", "qna", "game", "settlement", "sale", "statistical", "status", "ip", "dwdelete"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "membership":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("membership"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Membership = data
		case "financials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financials"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Financials = data
		case "qna":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("qna"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Qna = data
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "settlement":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settlement"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Settlement = data
		case "sale":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sale"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sale = data
		case "statistical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statistical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statistical = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "ip":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ip"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IP = data
		case "dwdelete":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dwdelete"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dwdelete = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAnnouncementInput(ctx context.Context, obj any) (model.UpdateAnnouncementInput, error) {
	var it model.UpdateAnnouncementInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo", "level"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBankInput(ctx context.Context, obj any) (model.UpdateBankInput, error) {
	var it model.UpdateBankInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDomainInput(ctx context.Context, obj any) (model.UpdateDomainInput, error) {
	var it model.UpdateDomainInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "status", "userId", "autoReg", "orderNum", "useTelegram", "telegram", "telegramLink", "useKakaoTalk", "kakaoTalk", "kakaoTalkLink", "useServiceCenter", "serviceCenter", "serviceCenterLink", "useLiveDomain", "liveDomain", "liveDomainLink", "memberLevel", "distributorLevel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "autoReg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoReg"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoReg = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "useTelegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTelegram"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTelegram = data
		case "telegram":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegram"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Telegram = data
		case "telegramLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("telegramLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TelegramLink = data
		case "useKakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useKakaoTalk"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseKakaoTalk = data
		case "kakaoTalk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalk"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalk = data
		case "kakaoTalkLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kakaoTalkLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KakaoTalkLink = data
		case "useServiceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useServiceCenter"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceCenter = data
		case "serviceCenter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenter"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenter = data
		case "serviceCenterLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceCenterLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceCenterLink = data
		case "useLiveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useLiveDomain"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseLiveDomain = data
		case "liveDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomain"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomain = data
		case "liveDomainLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveDomainLink"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveDomainLink = data
		case "memberLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memberLevel"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemberLevel = data
		case "distributorLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distributorLevel"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistributorLevel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj any) (model.UpdateEventInput, error) {
	var it model.UpdateEventInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "type", "description", "status", "orderNum", "domainId", "showFrom", "showTo", "level", "author", "category", "views", "createdDate", "mainImage", "imageUpload"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "domainId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domainId"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DomainID = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "author":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("author"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Author = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		case "createdDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedDate = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGameApiInput(ctx context.Context, obj any) (model.UpdateGameAPIInput, error) {
	var it model.UpdateGameAPIInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiCompanyName", "gameApiName", "gameCompanyName", "gameType", "other", "whetherToUse", "order", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiCompanyName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APICompanyName = data
		case "gameApiName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameApiName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameAPIName = data
		case "gameCompanyName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameCompanyName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameCompanyName = data
		case "gameType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gameType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GameType = data
		case "other":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("other"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Other = data
		case "whetherToUse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whetherToUse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WhetherToUse = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateInboxInput(ctx context.Context, obj any) (model.UpdateInboxInput, error) {
	var it model.UpdateInboxInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "title", "description", "status", "userId", "orderNum", "openedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "openedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMenuInput(ctx context.Context, obj any) (model.UpdateMenuInput, error) {
	var it model.UpdateMenuInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"label", "key", "icon", "path", "parentId", "description", "status", "orderNum"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "label":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("label"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Label = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "icon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("icon"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Icon = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "parentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentId"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateNotificationInput(ctx context.Context, obj any) (model.UpdateNotificationInput, error) {
	var it model.UpdateNotificationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "description", "status", "orderNum", "showFrom", "showTo", "level", "mainImage", "imageUpload", "noticeType", "registerDate", "views"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "showFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowFrom = data
		case "showTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("showTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShowTo = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "mainImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainImage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainImage = data
		case "imageUpload":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageUpload"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageUpload = data
		case "noticeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noticeType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoticeType = data
		case "registerDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("registerDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegisterDate = data
		case "views":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("views"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Views = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateProfile(ctx context.Context, obj any) (model.UpdateProfile, error) {
	var it model.UpdateProfile
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userid", "name", "nickname", "bankName", "holderName", "accountNumber", "birthday", "phone", "mobile", "balance", "roll", "point", "comp", "level", "favorites", "referral", "avatarUrl", "bio", "socialLinks", "currentPassword", "confirmPassword", "newPassword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nickname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nickname"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nickname = data
		case "bankName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bankName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankName = data
		case "holderName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holderName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HolderName = data
		case "accountNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountNumber"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AccountNumber = data
		case "birthday":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthday"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthday = data
		case "phone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phone = data
		case "mobile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Balance = data
		case "roll":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roll"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roll = data
		case "point":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("point"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Point = data
		case "comp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comp"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comp = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "favorites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorites"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorites = data
		case "referral":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referral"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Referral = data
		case "avatarUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "socialLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialLinks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SocialLinks = data
		case "currentPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CurrentPassword = data
		case "confirmPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirmPassword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfirmPassword = data
		case "newPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewPassword = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateQnaInput(ctx context.Context, obj any) (model.UpdateQnaInput, error) {
	var it model.UpdateQnaInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "question", "questionTitle", "answer", "answerTitle", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "question":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("question"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Question = data
		case "questionTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questionTitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestionTitle = data
		case "answer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("answer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Answer = data
		case "answerTitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("answerTitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AnswerTitle = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSMSApiInput(ctx context.Context, obj any) (model.UpdateSMSApiInput, error) {
	var it model.UpdateSMSApiInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "url", "agent", "password", "token", "orderNum", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "agent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agent"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Agent = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSettingInput(ctx context.Context, obj any) (model.UpdateSettingInput, error) {
	var it model.UpdateSettingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"status", "title", "description", "primaryDomain", "userId", "orderNum", "totalExStatus", "totalExFrom", "totalExTo", "totalReStatus", "totalReFrom", "totalReTo", "userExStatus", "userExFrom", "userExTo", "userReStatus", "userReFrom", "userReTo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "primaryDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("primaryDomain"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryDomain = data
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "totalExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExStatus = data
		case "totalExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExFrom = data
		case "totalExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalExTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalExTo = data
		case "totalReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReStatus = data
		case "totalReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReFrom = data
		case "totalReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalReTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalReTo = data
		case "userExStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExStatus = data
		case "userExFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExFrom = data
		case "userExTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userExTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserExTo = data
		case "userReStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReStatus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReStatus = data
		case "userReFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReFrom"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReFrom = data
		case "userReTo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userReTo"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserReTo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTransactionInput(ctx context.Context, obj any) (model.UpdateTransactionInput, error) {
	var it model.UpdateTransactionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "amount", "balanceBefore", "balanceAfter", "pointBefore", "pointAfter", "status", "shortcut", "usdtDesc"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "balanceBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceBefore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceBefore = data
		case "balanceAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceAfter"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceAfter = data
		case "pointBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointBefore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointBefore = data
		case "pointAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointAfter"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointAfter = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "shortcut":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shortcut"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Shortcut = data
		case "usdtDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtDesc = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUser(ctx context.Context, obj any) (model.UpdateUser, error) {
	var it model.UpdateUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "userid", "rootId", "partentId", "type", "role", "usdtAddress", "status", "orderNum", "live", "slot", "hold", "entireLosing", "liveLosingBeDang", "slotLosingBeDang", "holdLosingBeDang", "losingMethod"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "userid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userid"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Userid = data
		case "rootId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootID = data
		case "partentId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("partentId"))
			data, err := ec.unmarshalOID2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartentID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "usdtAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usdtAddress"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsdtAddress = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "orderNum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNum"))
			data, err := ec.unmarshalOUint2uint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNum = data
		case "live":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("live"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Live = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "hold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hold"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hold = data
		case "entireLosing":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entireLosing"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntireLosing = data
		case "liveLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("liveLosingBeDang"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LiveLosingBeDang = data
		case "slotLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slotLosingBeDang"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlotLosingBeDang = data
		case "holdLosingBeDang":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("holdLosingBeDang"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.HoldLosingBeDang = data
		case "losingMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("losingMethod"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LosingMethod = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adminPermissionImplementors = []string{"AdminPermission"}

func (ec *executionContext) _AdminPermission(ctx context.Context, sel ast.SelectionSet, obj *models.AdminPermission) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminPermissionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminPermission")
		case "id":
			out.Values[i] = ec._AdminPermission_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._AdminPermission_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AdminPermission_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "membership":
			out.Values[i] = ec._AdminPermission_membership(ctx, field, obj)
		case "financials":
			out.Values[i] = ec._AdminPermission_financials(ctx, field, obj)
		case "qna":
			out.Values[i] = ec._AdminPermission_qna(ctx, field, obj)
		case "game":
			out.Values[i] = ec._AdminPermission_game(ctx, field, obj)
		case "settlement":
			out.Values[i] = ec._AdminPermission_settlement(ctx, field, obj)
		case "sale":
			out.Values[i] = ec._AdminPermission_sale(ctx, field, obj)
		case "statistical":
			out.Values[i] = ec._AdminPermission_statistical(ctx, field, obj)
		case "ip":
			out.Values[i] = ec._AdminPermission_ip(ctx, field, obj)
		case "dwdelete":
			out.Values[i] = ec._AdminPermission_dwdelete(ctx, field, obj)
		case "status":
			out.Values[i] = ec._AdminPermission_status(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._AdminPermission_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._AdminPermission_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._AdminPermission_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminPermissionListImplementors = []string{"AdminPermissionList"}

func (ec *executionContext) _AdminPermissionList(ctx context.Context, sel ast.SelectionSet, obj *model.AdminPermissionList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminPermissionListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminPermissionList")
		case "adminPermissions":
			out.Values[i] = ec._AdminPermissionList_adminPermissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._AdminPermissionList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var announcementImplementors = []string{"Announcement"}

func (ec *executionContext) _Announcement(ctx context.Context, sel ast.SelectionSet, obj *models.Announcement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Announcement")
		case "id":
			out.Values[i] = ec._Announcement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Announcement_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Announcement_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Announcement_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._Announcement_orderNum(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Announcement_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Announcement_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "showFrom":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Announcement_showFrom(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "showTo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Announcement_showTo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Announcement_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Announcement_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Announcement_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var announcementListImplementors = []string{"AnnouncementList"}

func (ec *executionContext) _AnnouncementList(ctx context.Context, sel ast.SelectionSet, obj *model.AnnouncementList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnouncementList")
		case "announcements":
			out.Values[i] = ec._AnnouncementList_announcements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._AnnouncementList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bankImplementors = []string{"Bank"}

func (ec *executionContext) _Bank(ctx context.Context, sel ast.SelectionSet, obj *models.Bank) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bankImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bank")
		case "id":
			out.Values[i] = ec._Bank_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Bank_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Bank_orderNum(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Bank_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Bank_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Bank_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Bank_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bankListImplementors = []string{"BankList"}

func (ec *executionContext) _BankList(ctx context.Context, sel ast.SelectionSet, obj *model.BankList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bankListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BankList")
		case "banks":
			out.Values[i] = ec._BankList_banks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._BankList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var domainImplementors = []string{"Domain"}

func (ec *executionContext) _Domain(ctx context.Context, sel ast.SelectionSet, obj *models.Domain) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, domainImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Domain")
		case "id":
			out.Values[i] = ec._Domain_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Domain_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Domain_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Domain_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoReg":
			out.Values[i] = ec._Domain_autoReg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "useTelegram":
			out.Values[i] = ec._Domain_useTelegram(ctx, field, obj)
		case "telegram":
			out.Values[i] = ec._Domain_telegram(ctx, field, obj)
		case "telegramLink":
			out.Values[i] = ec._Domain_telegramLink(ctx, field, obj)
		case "useKakaoTalk":
			out.Values[i] = ec._Domain_useKakaoTalk(ctx, field, obj)
		case "kakaoTalk":
			out.Values[i] = ec._Domain_kakaoTalk(ctx, field, obj)
		case "kakaoTalkLink":
			out.Values[i] = ec._Domain_kakaoTalkLink(ctx, field, obj)
		case "useServiceCenter":
			out.Values[i] = ec._Domain_useServiceCenter(ctx, field, obj)
		case "serviceCenter":
			out.Values[i] = ec._Domain_serviceCenter(ctx, field, obj)
		case "serviceCenterLink":
			out.Values[i] = ec._Domain_serviceCenterLink(ctx, field, obj)
		case "useLiveDomain":
			out.Values[i] = ec._Domain_useLiveDomain(ctx, field, obj)
		case "liveDomain":
			out.Values[i] = ec._Domain_liveDomain(ctx, field, obj)
		case "liveDomainLink":
			out.Values[i] = ec._Domain_liveDomainLink(ctx, field, obj)
		case "memberLevel":
			out.Values[i] = ec._Domain_memberLevel(ctx, field, obj)
		case "distributorLevel":
			out.Values[i] = ec._Domain_distributorLevel(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Domain_orderNum(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Domain_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Domain_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Domain_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Domain_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Domain_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var domainListImplementors = []string{"DomainList"}

func (ec *executionContext) _DomainList(ctx context.Context, sel ast.SelectionSet, obj *model.DomainList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, domainListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DomainList")
		case "domains":
			out.Values[i] = ec._DomainList_domains(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._DomainList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *models.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Event_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Event_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Event_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Event_orderNum(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Event_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Event_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "domainId":
			out.Values[i] = ec._Event_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Event_domain(ctx, field, obj)
		case "showFrom":
			out.Values[i] = ec._Event_showFrom(ctx, field, obj)
		case "showTo":
			out.Values[i] = ec._Event_showTo(ctx, field, obj)
		case "category":
			out.Values[i] = ec._Event_category(ctx, field, obj)
		case "views":
			out.Values[i] = ec._Event_views(ctx, field, obj)
		case "mainImage":
			out.Values[i] = ec._Event_mainImage(ctx, field, obj)
		case "imageUpload":
			out.Values[i] = ec._Event_imageUpload(ctx, field, obj)
		case "level":
			out.Values[i] = ec._Event_level(ctx, field, obj)
		case "createdDate":
			out.Values[i] = ec._Event_createdDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Event_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventListImplementors = []string{"EventList"}

func (ec *executionContext) _EventList(ctx context.Context, sel ast.SelectionSet, obj *model.EventList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventList")
		case "events":
			out.Values[i] = ec._EventList_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._EventList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameAPIImplementors = []string{"GameAPI"}

func (ec *executionContext) _GameAPI(ctx context.Context, sel ast.SelectionSet, obj *model.GameAPI) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameAPIImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameAPI")
		case "id":
			out.Values[i] = ec._GameAPI_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apiCompanyName":
			out.Values[i] = ec._GameAPI_apiCompanyName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameApiName":
			out.Values[i] = ec._GameAPI_gameApiName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameCompanyName":
			out.Values[i] = ec._GameAPI_gameCompanyName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gameType":
			out.Values[i] = ec._GameAPI_gameType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "other":
			out.Values[i] = ec._GameAPI_other(ctx, field, obj)
		case "whetherToUse":
			out.Values[i] = ec._GameAPI_whetherToUse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "order":
			out.Values[i] = ec._GameAPI_order(ctx, field, obj)
		case "type":
			out.Values[i] = ec._GameAPI_type(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._GameAPI_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._GameAPI_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._GameAPI_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameAPIListImplementors = []string{"GameAPIList"}

func (ec *executionContext) _GameAPIList(ctx context.Context, sel ast.SelectionSet, obj *model.GameAPIList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameAPIListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameAPIList")
		case "gameApis":
			out.Values[i] = ec._GameAPIList_gameApis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._GameAPIList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboxImplementors = []string{"Inbox"}

func (ec *executionContext) _Inbox(ctx context.Context, sel ast.SelectionSet, obj *models.Inbox) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboxImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Inbox")
		case "id":
			out.Values[i] = ec._Inbox_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Inbox_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._Inbox_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Inbox_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Inbox_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "orderNum":
			out.Values[i] = ec._Inbox_orderNum(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Inbox_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Inbox_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fromId":
			out.Values[i] = ec._Inbox_fromId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FromUser":
			out.Values[i] = ec._Inbox_FromUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "openedAt":
			out.Values[i] = ec._Inbox_openedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Inbox_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Inbox_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Inbox_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inboxListImplementors = []string{"InboxList"}

func (ec *executionContext) _InboxList(ctx context.Context, sel ast.SelectionSet, obj *model.InboxList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inboxListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InboxList")
		case "inboxes":
			out.Values[i] = ec._InboxList_inboxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._InboxList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logImplementors = []string{"Log"}

func (ec *executionContext) _Log(ctx context.Context, sel ast.SelectionSet, obj *models.Log) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Log")
		case "id":
			out.Values[i] = ec._Log_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._Log_data(ctx, field, obj)
		case "path":
			out.Values[i] = ec._Log_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "phone":
			out.Values[i] = ec._Log_phone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "method":
			out.Values[i] = ec._Log_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Log_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ip":
			out.Values[i] = ec._Log_ip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userId":
			out.Values[i] = ec._Log_userId(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Log_user(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Log_status(ctx, field, obj)
		case "os":
			out.Values[i] = ec._Log_os(ctx, field, obj)
		case "device":
			out.Values[i] = ec._Log_device(ctx, field, obj)
		case "host":
			out.Values[i] = ec._Log_host(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Log_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Log_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Log_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logListImplementors = []string{"LogList"}

func (ec *executionContext) _LogList(ctx context.Context, sel ast.SelectionSet, obj *model.LogList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogList")
		case "logs":
			out.Values[i] = ec._LogList_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._LogList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var menuImplementors = []string{"Menu"}

func (ec *executionContext) _Menu(ctx context.Context, sel ast.SelectionSet, obj *models.Menu) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, menuImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Menu")
		case "id":
			out.Values[i] = ec._Menu_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Menu_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "label":
			out.Values[i] = ec._Menu_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._Menu_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "icon":
			out.Values[i] = ec._Menu_icon(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Menu_description(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Menu_status(ctx, field, obj)
		case "parentId":
			out.Values[i] = ec._Menu_parentId(ctx, field, obj)
		case "children":
			out.Values[i] = ec._Menu_children(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Menu_orderNum(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Menu_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Menu_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Menu_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var menuListImplementors = []string{"MenuList"}

func (ec *executionContext) _MenuList(ctx context.Context, sel ast.SelectionSet, obj *model.MenuList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, menuListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MenuList")
		case "menus":
			out.Values[i] = ec._MenuList_menus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._MenuList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "time":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_time(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadFile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadFile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createAdminPermission":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAdminPermission(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAdminPermission":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAdminPermission(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteBank":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBank(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDomain":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDomain(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGameApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGameApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteInbox":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteInbox(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLog":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLog(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteLog":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteLog(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMenu":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMenu(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteNotification":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteNotification(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "replyQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_replyQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completeQna":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_completeQna(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSMSApi":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSMSApi(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTodo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTodo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "blockTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_blockTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "waitingTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_waitingTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelTransaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelTransaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateProfile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateProfile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteProfile":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProfile(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "blockUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_blockUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationImplementors = []string{"Notification"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *models.Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "id":
			out.Values[i] = ec._Notification_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Notification_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Notification_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Notification_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._Notification_orderNum(ctx, field, obj)
		case "showFrom":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_showFrom(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mainImage":
			out.Values[i] = ec._Notification_mainImage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageUpload":
			out.Values[i] = ec._Notification_imageUpload(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "noticeType":
			out.Values[i] = ec._Notification_noticeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "registerDate":
			out.Values[i] = ec._Notification_registerDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level":
			out.Values[i] = ec._Notification_level(ctx, field, obj)
		case "domainId":
			out.Values[i] = ec._Notification_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Notification_domain(ctx, field, obj)
		case "views":
			out.Values[i] = ec._Notification_views(ctx, field, obj)
		case "showTo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_showTo(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Notification_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Notification_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Notification_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationListImplementors = []string{"NotificationList"}

func (ec *executionContext) _NotificationList(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationList")
		case "notifications":
			out.Values[i] = ec._NotificationList_notifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._NotificationList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var profileImplementors = []string{"Profile"}

func (ec *executionContext) _Profile(ctx context.Context, sel ast.SelectionSet, obj *models.Profile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, profileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Profile")
		case "id":
			out.Values[i] = ec._Profile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Profile_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Profile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._Profile_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bankName":
			out.Values[i] = ec._Profile_bankName(ctx, field, obj)
		case "holderName":
			out.Values[i] = ec._Profile_holderName(ctx, field, obj)
		case "accountNumber":
			out.Values[i] = ec._Profile_accountNumber(ctx, field, obj)
		case "birthday":
			out.Values[i] = ec._Profile_birthday(ctx, field, obj)
		case "phone":
			out.Values[i] = ec._Profile_phone(ctx, field, obj)
		case "mobile":
			out.Values[i] = ec._Profile_mobile(ctx, field, obj)
		case "phoneVerified":
			out.Values[i] = ec._Profile_phoneVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "balance":
			out.Values[i] = ec._Profile_balance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roll":
			out.Values[i] = ec._Profile_roll(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "point":
			out.Values[i] = ec._Profile_point(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "comp":
			out.Values[i] = ec._Profile_comp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level":
			out.Values[i] = ec._Profile_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "coupon":
			out.Values[i] = ec._Profile_coupon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "favorites":
			out.Values[i] = ec._Profile_favorites(ctx, field, obj)
		case "referral":
			out.Values[i] = ec._Profile_referral(ctx, field, obj)
		case "avatarUrl":
			out.Values[i] = ec._Profile_avatarUrl(ctx, field, obj)
		case "bio":
			out.Values[i] = ec._Profile_bio(ctx, field, obj)
		case "socialLinks":
			out.Values[i] = ec._Profile_socialLinks(ctx, field, obj)
		case "lastDeposit":
			out.Values[i] = ec._Profile_lastDeposit(ctx, field, obj)
		case "lastWithdraw":
			out.Values[i] = ec._Profile_lastWithdraw(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Profile_orderNum(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Profile_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Profile_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Profile_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qnaImplementors = []string{"Qna"}

func (ec *executionContext) _Qna(ctx context.Context, sel ast.SelectionSet, obj *models.Qna) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qnaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Qna")
		case "id":
			out.Values[i] = ec._Qna_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Qna_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Qna_user(ctx, field, obj)
		case "domainId":
			out.Values[i] = ec._Qna_domainId(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._Qna_domain(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Qna_type(ctx, field, obj)
		case "question":
			out.Values[i] = ec._Qna_question(ctx, field, obj)
		case "questionTitle":
			out.Values[i] = ec._Qna_questionTitle(ctx, field, obj)
		case "answer":
			out.Values[i] = ec._Qna_answer(ctx, field, obj)
		case "answerTitle":
			out.Values[i] = ec._Qna_answerTitle(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Qna_status(ctx, field, obj)
		case "repliedAt":
			out.Values[i] = ec._Qna_repliedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Qna_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Qna_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._Qna_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var qnaListImplementors = []string{"QnaList"}

func (ec *executionContext) _QnaList(ctx context.Context, sel ast.SelectionSet, obj *model.QnaList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, qnaListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QnaList")
		case "qnas":
			out.Values[i] = ec._QnaList_qnas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._QnaList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "time":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_time(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminPermissions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "announcements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_announcements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getBanks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBanks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "domains":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_domains(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDomains":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDomains(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "topEvents":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_topEvents(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGameApis":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGameApis(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getInboxes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getInboxes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "logs":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getLogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUserMenus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUserMenus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMenus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMenus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_notifications(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getNotifications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getNotifications(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getQnas":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getQnas(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSetting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSetting(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMSApis":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMSApis(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "todos":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_todos(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTransactions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTransactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getWeeklyLosingData":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWeeklyLosingData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "profile":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_profile(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "filterUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_filterUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectedUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectedUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDistributors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDistributors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDistributorDetails":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDistributorDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMSApiImplementors = []string{"SMSApi"}

func (ec *executionContext) _SMSApi(ctx context.Context, sel ast.SelectionSet, obj *models.SMSApi) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMSApiImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMSApi")
		case "id":
			out.Values[i] = ec._SMSApi_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._SMSApi_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._SMSApi_url(ctx, field, obj)
		case "agent":
			out.Values[i] = ec._SMSApi_agent(ctx, field, obj)
		case "password":
			out.Values[i] = ec._SMSApi_password(ctx, field, obj)
		case "token":
			out.Values[i] = ec._SMSApi_token(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._SMSApi_orderNum(ctx, field, obj)
		case "status":
			out.Values[i] = ec._SMSApi_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._SMSApi_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._SMSApi_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletedAt":
			out.Values[i] = ec._SMSApi_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMSApiListImplementors = []string{"SMSApiList"}

func (ec *executionContext) _SMSApiList(ctx context.Context, sel ast.SelectionSet, obj *model.SMSApiList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMSApiListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMSApiList")
		case "smsApis":
			out.Values[i] = ec._SMSApiList_smsApis(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._SMSApiList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var settingImplementors = []string{"Setting"}

func (ec *executionContext) _Setting(ctx context.Context, sel ast.SelectionSet, obj *model.Setting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, settingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Setting")
		case "id":
			out.Values[i] = ec._Setting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Setting_status(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Setting_title(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Setting_description(ctx, field, obj)
		case "primaryDomain":
			out.Values[i] = ec._Setting_primaryDomain(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Setting_userId(ctx, field, obj)
		case "user":
			out.Values[i] = ec._Setting_user(ctx, field, obj)
		case "orderNum":
			out.Values[i] = ec._Setting_orderNum(ctx, field, obj)
		case "totalExStatus":
			out.Values[i] = ec._Setting_totalExStatus(ctx, field, obj)
		case "totalExFrom":
			out.Values[i] = ec._Setting_totalExFrom(ctx, field, obj)
		case "totalExTo":
			out.Values[i] = ec._Setting_totalExTo(ctx, field, obj)
		case "totalReStatus":
			out.Values[i] = ec._Setting_totalReStatus(ctx, field, obj)
		case "totalReFrom":
			out.Values[i] = ec._Setting_totalReFrom(ctx, field, obj)
		case "totalReTo":
			out.Values[i] = ec._Setting_totalReTo(ctx, field, obj)
		case "userExStatus":
			out.Values[i] = ec._Setting_userExStatus(ctx, field, obj)
		case "userExFrom":
			out.Values[i] = ec._Setting_userExFrom(ctx, field, obj)
		case "userExTo":
			out.Values[i] = ec._Setting_userExTo(ctx, field, obj)
		case "userReStatus":
			out.Values[i] = ec._Setting_userReStatus(ctx, field, obj)
		case "userReFrom":
			out.Values[i] = ec._Setting_userReFrom(ctx, field, obj)
		case "userReTo":
			out.Values[i] = ec._Setting_userReTo(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Setting_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Setting_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Setting_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "time":
		return ec._Subscription_time(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var todoImplementors = []string{"Todo"}

func (ec *executionContext) _Todo(ctx context.Context, sel ast.SelectionSet, obj *model.Todo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, todoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Todo")
		case "id":
			out.Values[i] = ec._Todo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._Todo_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "done":
			out.Values[i] = ec._Todo_done(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Todo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *models.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			out.Values[i] = ec._Transaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userId":
			out.Values[i] = ec._Transaction_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Transaction_user(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Transaction_type(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._Transaction_amount(ctx, field, obj)
		case "balanceBefore":
			out.Values[i] = ec._Transaction_balanceBefore(ctx, field, obj)
		case "balanceAfter":
			out.Values[i] = ec._Transaction_balanceAfter(ctx, field, obj)
		case "pointBefore":
			out.Values[i] = ec._Transaction_pointBefore(ctx, field, obj)
		case "pointAfter":
			out.Values[i] = ec._Transaction_pointAfter(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Transaction_status(ctx, field, obj)
		case "shortcut":
			out.Values[i] = ec._Transaction_shortcut(ctx, field, obj)
		case "usdtDesc":
			out.Values[i] = ec._Transaction_usdtDesc(ctx, field, obj)
		case "transactionAt":
			out.Values[i] = ec._Transaction_transactionAt(ctx, field, obj)
		case "approvedAt":
			out.Values[i] = ec._Transaction_approvedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Transaction_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._Transaction_updatedAt(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Transaction_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionListImplementors = []string{"TransactionList"}

func (ec *executionContext) _TransactionList(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionList")
		case "transactions":
			out.Values[i] = ec._TransactionList_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._TransactionList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userid":
			out.Values[i] = ec._User_userid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "role":
			out.Values[i] = ec._User_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "usdtAddress":
			out.Values[i] = ec._User_usdtAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currentIP":
			out.Values[i] = ec._User_currentIP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "IP":
			out.Values[i] = ec._User_IP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rootId":
			out.Values[i] = ec._User_rootId(ctx, field, obj)
		case "root":
			out.Values[i] = ec._User_root(ctx, field, obj)
		case "parentId":
			out.Values[i] = ec._User_parentId(ctx, field, obj)
		case "parent":
			out.Values[i] = ec._User_parent(ctx, field, obj)
		case "children":
			out.Values[i] = ec._User_children(ctx, field, obj)
		case "childrenCount":
			out.Values[i] = ec._User_childrenCount(ctx, field, obj)
		case "profile":
			out.Values[i] = ec._User_profile(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "blackMemo":
			out.Values[i] = ec._User_blackMemo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "orderNum":
			out.Values[i] = ec._User_orderNum(ctx, field, obj)
		case "os":
			out.Values[i] = ec._User_os(ctx, field, obj)
		case "device":
			out.Values[i] = ec._User_device(ctx, field, obj)
		case "fingerPrint":
			out.Values[i] = ec._User_fingerPrint(ctx, field, obj)
		case "live":
			out.Values[i] = ec._User_live(ctx, field, obj)
		case "slot":
			out.Values[i] = ec._User_slot(ctx, field, obj)
		case "hold":
			out.Values[i] = ec._User_hold(ctx, field, obj)
		case "entireLosing":
			out.Values[i] = ec._User_entireLosing(ctx, field, obj)
		case "liveLosingBeDang":
			out.Values[i] = ec._User_liveLosingBeDang(ctx, field, obj)
		case "slotLosingBeDang":
			out.Values[i] = ec._User_slotLosingBeDang(ctx, field, obj)
		case "holdLosingBeDang":
			out.Values[i] = ec._User_holdLosingBeDang(ctx, field, obj)
		case "losingMethod":
			out.Values[i] = ec._User_losingMethod(ctx, field, obj)
		case "miniDanpolRolling":
			out.Values[i] = ec._User_miniDanpolRolling(ctx, field, obj)
		case "miniCombinationRolling":
			out.Values[i] = ec._User_miniCombinationRolling(ctx, field, obj)
		case "sportsDanpolRolling":
			out.Values[i] = ec._User_sportsDanpolRolling(ctx, field, obj)
		case "sportsDupolRolling":
			out.Values[i] = ec._User_sportsDupolRolling(ctx, field, obj)
		case "sports3PoleRolling":
			out.Values[i] = ec._User_sports3PoleRolling(ctx, field, obj)
		case "sports4PoleRolling":
			out.Values[i] = ec._User_sports4PoleRolling(ctx, field, obj)
		case "sports5PoleRolling":
			out.Values[i] = ec._User_sports5PoleRolling(ctx, field, obj)
		case "sportsDapolRolling":
			out.Values[i] = ec._User_sportsDapolRolling(ctx, field, obj)
		case "virtualGameRolling":
			out.Values[i] = ec._User_virtualGameRolling(ctx, field, obj)
		case "lotusRolling":
			out.Values[i] = ec._User_lotusRolling(ctx, field, obj)
		case "mgmRolling":
			out.Values[i] = ec._User_mgmRolling(ctx, field, obj)
		case "touchRolling":
			out.Values[i] = ec._User_touchRolling(ctx, field, obj)
		case "membershipDeposit":
			out.Values[i] = ec._User_membershipDeposit(ctx, field, obj)
		case "membershipWithdrawal":
			out.Values[i] = ec._User_membershipWithdrawal(ctx, field, obj)
		case "totalWithdrawal":
			out.Values[i] = ec._User_totalWithdrawal(ctx, field, obj)
		case "numberOfMembers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_numberOfMembers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rollingHoldings":
			out.Values[i] = ec._User_rollingHoldings(ctx, field, obj)
		case "liveBetting":
			out.Values[i] = ec._User_liveBetting(ctx, field, obj)
		case "liveWinning":
			out.Values[i] = ec._User_liveWinning(ctx, field, obj)
		case "slotBetting":
			out.Values[i] = ec._User_slotBetting(ctx, field, obj)
		case "slotJackpot":
			out.Values[i] = ec._User_slotJackpot(ctx, field, obj)
		case "miniDanpolBetting":
			out.Values[i] = ec._User_miniDanpolBetting(ctx, field, obj)
		case "miniDanpolWinner":
			out.Values[i] = ec._User_miniDanpolWinner(ctx, field, obj)
		case "miniCombinationBetting":
			out.Values[i] = ec._User_miniCombinationBetting(ctx, field, obj)
		case "miniCombinationWinnings":
			out.Values[i] = ec._User_miniCombinationWinnings(ctx, field, obj)
		case "sportsDanpolBetting":
			out.Values[i] = ec._User_sportsDanpolBetting(ctx, field, obj)
		case "sportsDanpolWinner":
			out.Values[i] = ec._User_sportsDanpolWinner(ctx, field, obj)
		case "sportsDupolBetting":
			out.Values[i] = ec._User_sportsDupolBetting(ctx, field, obj)
		case "sportsDupolWinner":
			out.Values[i] = ec._User_sportsDupolWinner(ctx, field, obj)
		case "sports3poleBetting":
			out.Values[i] = ec._User_sports3poleBetting(ctx, field, obj)
		case "sports3poleWinner":
			out.Values[i] = ec._User_sports3poleWinner(ctx, field, obj)
		case "sports4poleBetting":
			out.Values[i] = ec._User_sports4poleBetting(ctx, field, obj)
		case "sports4poleWinner":
			out.Values[i] = ec._User_sports4poleWinner(ctx, field, obj)
		case "sports5poleBetting":
			out.Values[i] = ec._User_sports5poleBetting(ctx, field, obj)
		case "sports5poleWinner":
			out.Values[i] = ec._User_sports5poleWinner(ctx, field, obj)
		case "sportsDapolBetting":
			out.Values[i] = ec._User_sportsDapolBetting(ctx, field, obj)
		case "sportsDapolWinner":
			out.Values[i] = ec._User_sportsDapolWinner(ctx, field, obj)
		case "virtualGameBetting":
			out.Values[i] = ec._User_virtualGameBetting(ctx, field, obj)
		case "virtualGameWinnings":
			out.Values[i] = ec._User_virtualGameWinnings(ctx, field, obj)
		case "lotusBetting":
			out.Values[i] = ec._User_lotusBetting(ctx, field, obj)
		case "lotusLottery":
			out.Values[i] = ec._User_lotusLottery(ctx, field, obj)
		case "mgmBetting":
			out.Values[i] = ec._User_mgmBetting(ctx, field, obj)
		case "mgmWinning":
			out.Values[i] = ec._User_mgmWinning(ctx, field, obj)
		case "touchBetting":
			out.Values[i] = ec._User_touchBetting(ctx, field, obj)
		case "touchWinning":
			out.Values[i] = ec._User_touchWinning(ctx, field, obj)
		case "holdemBetting":
			out.Values[i] = ec._User_holdemBetting(ctx, field, obj)
		case "holdemWinning":
			out.Values[i] = ec._User_holdemWinning(ctx, field, obj)
		case "rollingRate":
			out.Values[i] = ec._User_rollingRate(ctx, field, obj)
		case "rollingTransition":
			out.Values[i] = ec._User_rollingTransition(ctx, field, obj)
		case "losingRate":
			out.Values[i] = ec._User_losingRate(ctx, field, obj)
		case "losingSettlement":
			out.Values[i] = ec._User_losingSettlement(ctx, field, obj)
		case "partnershipRolling":
			out.Values[i] = ec._User_partnershipRolling(ctx, field, obj)
		case "partnershipMoneyInHand":
			out.Values[i] = ec._User_partnershipMoneyInHand(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._User_deletedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userListImplementors = []string{"UserList"}

func (ec *executionContext) _UserList(ctx context.Context, sel ast.SelectionSet, obj *model.UserList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserList")
		case "users":
			out.Values[i] = ec._UserList_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._UserList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var weeklyLosingDataImplementors = []string{"WeeklyLosingData"}

func (ec *executionContext) _WeeklyLosingData(ctx context.Context, sel ast.SelectionSet, obj *model.WeeklyLosingData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weeklyLosingDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeeklyLosingData")
		case "weekStart":
			out.Values[i] = ec._WeeklyLosingData_weekStart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weekEnd":
			out.Values[i] = ec._WeeklyLosingData_weekEnd(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "site":
			out.Values[i] = ec._WeeklyLosingData_site(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorID":
			out.Values[i] = ec._WeeklyLosingData_distributorID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorName":
			out.Values[i] = ec._WeeklyLosingData_distributorName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distributorLevel":
			out.Values[i] = ec._WeeklyLosingData_distributorLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nickname":
			out.Values[i] = ec._WeeklyLosingData_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "depositor":
			out.Values[i] = ec._WeeklyLosingData_depositor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._WeeklyLosingData_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalBet":
			out.Values[i] = ec._WeeklyLosingData_totalBet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalWinner":
			out.Values[i] = ec._WeeklyLosingData_totalWinner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalLosingMoney":
			out.Values[i] = ec._WeeklyLosingData_totalLosingMoney(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "settlementAmount":
			out.Values[i] = ec._WeeklyLosingData_settlementAmount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applicationDate":
			out.Values[i] = ec._WeeklyLosingData_applicationDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "processingDate":
			out.Values[i] = ec._WeeklyLosingData_processingDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "situation":
			out.Values[i] = ec._WeeklyLosingData_situation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userCount":
			out.Values[i] = ec._WeeklyLosingData_userCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var weeklyLosingDataListImplementors = []string{"WeeklyLosingDataList"}

func (ec *executionContext) _WeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, obj *model.WeeklyLosingDataList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weeklyLosingDataListImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeeklyLosingDataList")
		case "weeklyLosingData":
			out.Values[i] = ec._WeeklyLosingDataList_weeklyLosingData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total":
			out.Values[i] = ec._WeeklyLosingDataList_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx context.Context, sel ast.SelectionSet, v models.AdminPermission) graphql.Marshaler {
	return ec._AdminPermission(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx context.Context, sel ast.SelectionSet, v []*models.AdminPermission) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminPermission2githubcomhotbrainygobettingbackendinternalmodelsAdminPermission(ctx context.Context, sel ast.SelectionSet, v *models.AdminPermission) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminPermission(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminPermissionList2githubcomhotbrainygobettingbackendgraphmodelAdminPermissionList(ctx context.Context, sel ast.SelectionSet, v model.AdminPermissionList) graphql.Marshaler {
	return ec._AdminPermissionList(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminPermissionList2githubcomhotbrainygobettingbackendgraphmodelAdminPermissionList(ctx context.Context, sel ast.SelectionSet, v *model.AdminPermissionList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminPermissionList(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx context.Context, sel ast.SelectionSet, v models.Announcement) graphql.Marshaler {
	return ec._Announcement(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx context.Context, sel ast.SelectionSet, v []*models.Announcement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAnnouncement2githubcomhotbrainygobettingbackendinternalmodelsAnnouncement(ctx context.Context, sel ast.SelectionSet, v *models.Announcement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnouncementList2githubcomhotbrainygobettingbackendgraphmodelAnnouncementList(ctx context.Context, sel ast.SelectionSet, v model.AnnouncementList) graphql.Marshaler {
	return ec._AnnouncementList(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncementList2githubcomhotbrainygobettingbackendgraphmodelAnnouncementList(ctx context.Context, sel ast.SelectionSet, v *model.AnnouncementList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AnnouncementList(ctx, sel, v)
}

func (ec *executionContext) marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx context.Context, sel ast.SelectionSet, v models.Bank) graphql.Marshaler {
	return ec._Bank(ctx, sel, &v)
}

func (ec *executionContext) marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx context.Context, sel ast.SelectionSet, v []*models.Bank) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBank2githubcomhotbrainygobettingbackendinternalmodelsBank(ctx context.Context, sel ast.SelectionSet, v *models.Bank) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Bank(ctx, sel, v)
}

func (ec *executionContext) marshalNBankList2githubcomhotbrainygobettingbackendgraphmodelBankList(ctx context.Context, sel ast.SelectionSet, v model.BankList) graphql.Marshaler {
	return ec._BankList(ctx, sel, &v)
}

func (ec *executionContext) marshalNBankList2githubcomhotbrainygobettingbackendgraphmodelBankList(ctx context.Context, sel ast.SelectionSet, v *model.BankList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BankList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v models.Domain) graphql.Marshaler {
	return ec._Domain(ctx, sel, &v)
}

func (ec *executionContext) marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v []*models.Domain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v *models.Domain) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Domain(ctx, sel, v)
}

func (ec *executionContext) marshalNDomainList2githubcomhotbrainygobettingbackendgraphmodelDomainList(ctx context.Context, sel ast.SelectionSet, v model.DomainList) graphql.Marshaler {
	return ec._DomainList(ctx, sel, &v)
}

func (ec *executionContext) marshalNDomainList2githubcomhotbrainygobettingbackendgraphmodelDomainList(ctx context.Context, sel ast.SelectionSet, v *model.DomainList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DomainList(ctx, sel, v)
}

func (ec *executionContext) marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx context.Context, sel ast.SelectionSet, v models.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) marshalNEventList2githubcomhotbrainygobettingbackendgraphmodelEventList(ctx context.Context, sel ast.SelectionSet, v model.EventList) graphql.Marshaler {
	return ec._EventList(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventList2githubcomhotbrainygobettingbackendgraphmodelEventList(ctx context.Context, sel ast.SelectionSet, v *model.EventList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx context.Context, v any) (*model.Filter, error) {
	res, err := ec.unmarshalInputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx context.Context, sel ast.SelectionSet, v model.GameAPI) graphql.Marshaler {
	return ec._GameAPI(ctx, sel, &v)
}

func (ec *executionContext) marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx context.Context, sel ast.SelectionSet, v []*model.GameAPI) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGameAPI2githubcomhotbrainygobettingbackendgraphmodelGameAPI(ctx context.Context, sel ast.SelectionSet, v *model.GameAPI) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameAPI(ctx, sel, v)
}

func (ec *executionContext) marshalNGameAPIList2githubcomhotbrainygobettingbackendgraphmodelGameAPIList(ctx context.Context, sel ast.SelectionSet, v model.GameAPIList) graphql.Marshaler {
	return ec._GameAPIList(ctx, sel, &v)
}

func (ec *executionContext) marshalNGameAPIList2githubcomhotbrainygobettingbackendgraphmodelGameAPIList(ctx context.Context, sel ast.SelectionSet, v *model.GameAPIList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameAPIList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx context.Context, sel ast.SelectionSet, v models.Inbox) graphql.Marshaler {
	return ec._Inbox(ctx, sel, &v)
}

func (ec *executionContext) marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx context.Context, sel ast.SelectionSet, v []*models.Inbox) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInbox2githubcomhotbrainygobettingbackendinternalmodelsInbox(ctx context.Context, sel ast.SelectionSet, v *models.Inbox) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Inbox(ctx, sel, v)
}

func (ec *executionContext) marshalNInboxList2githubcomhotbrainygobettingbackendgraphmodelInboxList(ctx context.Context, sel ast.SelectionSet, v model.InboxList) graphql.Marshaler {
	return ec._InboxList(ctx, sel, &v)
}

func (ec *executionContext) marshalNInboxList2githubcomhotbrainygobettingbackendgraphmodelInboxList(ctx context.Context, sel ast.SelectionSet, v *model.InboxList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InboxList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v any) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx context.Context, sel ast.SelectionSet, v models.Log) graphql.Marshaler {
	return ec._Log(ctx, sel, &v)
}

func (ec *executionContext) marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx context.Context, sel ast.SelectionSet, v []*models.Log) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx context.Context, sel ast.SelectionSet, v *models.Log) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Log(ctx, sel, v)
}

func (ec *executionContext) marshalNLogList2githubcomhotbrainygobettingbackendgraphmodelLogList(ctx context.Context, sel ast.SelectionSet, v model.LogList) graphql.Marshaler {
	return ec._LogList(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogList2githubcomhotbrainygobettingbackendgraphmodelLogList(ctx context.Context, sel ast.SelectionSet, v *model.LogList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogList(ctx, sel, v)
}

func (ec *executionContext) marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v models.Menu) graphql.Marshaler {
	return ec._Menu(ctx, sel, &v)
}

func (ec *executionContext) marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v []*models.Menu) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v []*models.Menu) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v *models.Menu) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Menu(ctx, sel, v)
}

func (ec *executionContext) marshalNMenuList2githubcomhotbrainygobettingbackendgraphmodelMenuList(ctx context.Context, sel ast.SelectionSet, v model.MenuList) graphql.Marshaler {
	return ec._MenuList(ctx, sel, &v)
}

func (ec *executionContext) marshalNMenuList2githubcomhotbrainygobettingbackendgraphmodelMenuList(ctx context.Context, sel ast.SelectionSet, v *model.MenuList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MenuList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNewAdminPermission2githubcomhotbrainygobettingbackendgraphmodelNewAdminPermission(ctx context.Context, v any) (model.NewAdminPermission, error) {
	res, err := ec.unmarshalInputNewAdminPermission(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewAnnouncementInput2githubcomhotbrainygobettingbackendgraphmodelNewAnnouncementInput(ctx context.Context, v any) (model.NewAnnouncementInput, error) {
	res, err := ec.unmarshalInputNewAnnouncementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewBankInput2githubcomhotbrainygobettingbackendgraphmodelNewBankInput(ctx context.Context, v any) (model.NewBankInput, error) {
	res, err := ec.unmarshalInputNewBankInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewDomainInput2githubcomhotbrainygobettingbackendgraphmodelNewDomainInput(ctx context.Context, v any) (model.NewDomainInput, error) {
	res, err := ec.unmarshalInputNewDomainInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewEventInput2githubcomhotbrainygobettingbackendgraphmodelNewEventInput(ctx context.Context, v any) (model.NewEventInput, error) {
	res, err := ec.unmarshalInputNewEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewGameApiInput2githubcomhotbrainygobettingbackendgraphmodelNewGameAPIInput(ctx context.Context, v any) (model.NewGameAPIInput, error) {
	res, err := ec.unmarshalInputNewGameApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewInboxInput2githubcomhotbrainygobettingbackendgraphmodelNewInboxInput(ctx context.Context, v any) (model.NewInboxInput, error) {
	res, err := ec.unmarshalInputNewInboxInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewLogInput2githubcomhotbrainygobettingbackendgraphmodelNewLogInput(ctx context.Context, v any) (model.NewLogInput, error) {
	res, err := ec.unmarshalInputNewLogInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewMenuInput2githubcomhotbrainygobettingbackendgraphmodelNewMenuInput(ctx context.Context, v any) (model.NewMenuInput, error) {
	res, err := ec.unmarshalInputNewMenuInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewNotificationInput2githubcomhotbrainygobettingbackendgraphmodelNewNotificationInput(ctx context.Context, v any) (model.NewNotificationInput, error) {
	res, err := ec.unmarshalInputNewNotificationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewQnaInput2githubcomhotbrainygobettingbackendgraphmodelNewQnaInput(ctx context.Context, v any) (model.NewQnaInput, error) {
	res, err := ec.unmarshalInputNewQnaInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSMSApiInput2githubcomhotbrainygobettingbackendgraphmodelNewSMSApiInput(ctx context.Context, v any) (model.NewSMSApiInput, error) {
	res, err := ec.unmarshalInputNewSMSApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSettingInput2githubcomhotbrainygobettingbackendgraphmodelNewSettingInput(ctx context.Context, v any) (model.NewSettingInput, error) {
	res, err := ec.unmarshalInputNewSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewTodo2githubcomhotbrainygobettingbackendgraphmodelNewTodo(ctx context.Context, v any) (model.NewTodo, error) {
	res, err := ec.unmarshalInputNewTodo(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewTransactionInput2githubcomhotbrainygobettingbackendgraphmodelNewTransactionInput(ctx context.Context, v any) (model.NewTransactionInput, error) {
	res, err := ec.unmarshalInputNewTransactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx context.Context, sel ast.SelectionSet, v models.Notification) graphql.Marshaler {
	return ec._Notification(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx context.Context, sel ast.SelectionSet, v []*models.Notification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx context.Context, sel ast.SelectionSet, v *models.Notification) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalNNotificationList2githubcomhotbrainygobettingbackendgraphmodelNotificationList(ctx context.Context, sel ast.SelectionSet, v model.NotificationList) graphql.Marshaler {
	return ec._NotificationList(ctx, sel, &v)
}

func (ec *executionContext) marshalNNotificationList2githubcomhotbrainygobettingbackendgraphmodelNotificationList(ctx context.Context, sel ast.SelectionSet, v *model.NotificationList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NotificationList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx context.Context, v any) (*model.Order, error) {
	res, err := ec.unmarshalInputOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx context.Context, sel ast.SelectionSet, v models.Profile) graphql.Marshaler {
	return ec._Profile(ctx, sel, &v)
}

func (ec *executionContext) marshalNProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx context.Context, sel ast.SelectionSet, v *models.Profile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Profile(ctx, sel, v)
}

func (ec *executionContext) marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx context.Context, sel ast.SelectionSet, v models.Qna) graphql.Marshaler {
	return ec._Qna(ctx, sel, &v)
}

func (ec *executionContext) marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx context.Context, sel ast.SelectionSet, v []*models.Qna) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNQna2githubcomhotbrainygobettingbackendinternalmodelsQna(ctx context.Context, sel ast.SelectionSet, v *models.Qna) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Qna(ctx, sel, v)
}

func (ec *executionContext) marshalNQnaList2githubcomhotbrainygobettingbackendgraphmodelQnaList(ctx context.Context, sel ast.SelectionSet, v model.QnaList) graphql.Marshaler {
	return ec._QnaList(ctx, sel, &v)
}

func (ec *executionContext) marshalNQnaList2githubcomhotbrainygobettingbackendgraphmodelQnaList(ctx context.Context, sel ast.SelectionSet, v *model.QnaList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QnaList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx context.Context, v any) (model.Role, error) {
	var res model.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubcomhotbrainygobettingbackendgraphmodelRole(ctx context.Context, sel ast.SelectionSet, v model.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx context.Context, sel ast.SelectionSet, v models.SMSApi) graphql.Marshaler {
	return ec._SMSApi(ctx, sel, &v)
}

func (ec *executionContext) marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx context.Context, sel ast.SelectionSet, v []*models.SMSApi) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSMSApi2githubcomhotbrainygobettingbackendinternalmodelsSMSApi(ctx context.Context, sel ast.SelectionSet, v *models.SMSApi) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMSApi(ctx, sel, v)
}

func (ec *executionContext) marshalNSMSApiList2githubcomhotbrainygobettingbackendgraphmodelSMSApiList(ctx context.Context, sel ast.SelectionSet, v model.SMSApiList) graphql.Marshaler {
	return ec._SMSApiList(ctx, sel, &v)
}

func (ec *executionContext) marshalNSMSApiList2githubcomhotbrainygobettingbackendgraphmodelSMSApiList(ctx context.Context, sel ast.SelectionSet, v *model.SMSApiList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMSApiList(ctx, sel, v)
}

func (ec *executionContext) marshalNSetting2githubcomhotbrainygobettingbackendgraphmodelSetting(ctx context.Context, sel ast.SelectionSet, v model.Setting) graphql.Marshaler {
	return ec._Setting(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetting2githubcomhotbrainygobettingbackendgraphmodelSetting(ctx context.Context, sel ast.SelectionSet, v *model.Setting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Setting(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx context.Context, sel ast.SelectionSet, v model.Todo) graphql.Marshaler {
	return ec._Todo(ctx, sel, &v)
}

func (ec *executionContext) marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx context.Context, sel ast.SelectionSet, v []*model.Todo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTodo2githubcomhotbrainygobettingbackendgraphmodelTodo(ctx context.Context, sel ast.SelectionSet, v *model.Todo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Todo(ctx, sel, v)
}

func (ec *executionContext) marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v models.Transaction) graphql.Marshaler {
	return ec._Transaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v []*models.Transaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransaction2githubcomhotbrainygobettingbackendinternalmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v *models.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionList2githubcomhotbrainygobettingbackendgraphmodelTransactionList(ctx context.Context, sel ast.SelectionSet, v model.TransactionList) graphql.Marshaler {
	return ec._TransactionList(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionList2githubcomhotbrainygobettingbackendgraphmodelTransactionList(ctx context.Context, sel ast.SelectionSet, v *model.TransactionList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateAdminPermissionInput2githubcomhotbrainygobettingbackendgraphmodelUpdateAdminPermissionInput(ctx context.Context, v any) (model.UpdateAdminPermissionInput, error) {
	res, err := ec.unmarshalInputUpdateAdminPermissionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateAnnouncementInput2githubcomhotbrainygobettingbackendgraphmodelUpdateAnnouncementInput(ctx context.Context, v any) (model.UpdateAnnouncementInput, error) {
	res, err := ec.unmarshalInputUpdateAnnouncementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateBankInput2githubcomhotbrainygobettingbackendgraphmodelUpdateBankInput(ctx context.Context, v any) (model.UpdateBankInput, error) {
	res, err := ec.unmarshalInputUpdateBankInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateDomainInput2githubcomhotbrainygobettingbackendgraphmodelUpdateDomainInput(ctx context.Context, v any) (model.UpdateDomainInput, error) {
	res, err := ec.unmarshalInputUpdateDomainInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEventInput2githubcomhotbrainygobettingbackendgraphmodelUpdateEventInput(ctx context.Context, v any) (model.UpdateEventInput, error) {
	res, err := ec.unmarshalInputUpdateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGameApiInput2githubcomhotbrainygobettingbackendgraphmodelUpdateGameAPIInput(ctx context.Context, v any) (model.UpdateGameAPIInput, error) {
	res, err := ec.unmarshalInputUpdateGameApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateInboxInput2githubcomhotbrainygobettingbackendgraphmodelUpdateInboxInput(ctx context.Context, v any) (model.UpdateInboxInput, error) {
	res, err := ec.unmarshalInputUpdateInboxInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMenuInput2githubcomhotbrainygobettingbackendgraphmodelUpdateMenuInput(ctx context.Context, v any) (model.UpdateMenuInput, error) {
	res, err := ec.unmarshalInputUpdateMenuInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateNotificationInput2githubcomhotbrainygobettingbackendgraphmodelUpdateNotificationInput(ctx context.Context, v any) (model.UpdateNotificationInput, error) {
	res, err := ec.unmarshalInputUpdateNotificationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateProfile2githubcomhotbrainygobettingbackendgraphmodelUpdateProfile(ctx context.Context, v any) (model.UpdateProfile, error) {
	res, err := ec.unmarshalInputUpdateProfile(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateQnaInput2githubcomhotbrainygobettingbackendgraphmodelUpdateQnaInput(ctx context.Context, v any) (model.UpdateQnaInput, error) {
	res, err := ec.unmarshalInputUpdateQnaInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSMSApiInput2githubcomhotbrainygobettingbackendgraphmodelUpdateSMSApiInput(ctx context.Context, v any) (model.UpdateSMSApiInput, error) {
	res, err := ec.unmarshalInputUpdateSMSApiInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSettingInput2githubcomhotbrainygobettingbackendgraphmodelUpdateSettingInput(ctx context.Context, v any) (model.UpdateSettingInput, error) {
	res, err := ec.unmarshalInputUpdateSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTransactionInput2githubcomhotbrainygobettingbackendgraphmodelUpdateTransactionInput(ctx context.Context, v any) (model.UpdateTransactionInput, error) {
	res, err := ec.unmarshalInputUpdateTransactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUser2githubcomhotbrainygobettingbackendgraphmodelUpdateUser(ctx context.Context, v any) (model.UpdateUser, error) {
	res, err := ec.unmarshalInputUpdateUser(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v any) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx context.Context, sel ast.SelectionSet, v model.UserList) graphql.Marshaler {
	return ec._UserList(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserList2githubcomhotbrainygobettingbackendgraphmodelUserList(ctx context.Context, sel ast.SelectionSet, v *model.UserList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserList(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx context.Context, v any) (model.UserStatus, error) {
	var res model.UserStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx context.Context, sel ast.SelectionSet, v model.UserStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx context.Context, v any) (model.UserType, error) {
	var res model.UserType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx context.Context, sel ast.SelectionSet, v model.UserType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeeklyLosingData2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingData(ctx context.Context, sel ast.SelectionSet, v []*model.WeeklyLosingData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeeklyLosingData2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWeeklyLosingData2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingData(ctx context.Context, sel ast.SelectionSet, v *model.WeeklyLosingData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeeklyLosingData(ctx, sel, v)
}

func (ec *executionContext) marshalNWeeklyLosingDataList2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, v model.WeeklyLosingDataList) graphql.Marshaler {
	return ec._WeeklyLosingDataList(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeeklyLosingDataList2githubcomhotbrainygobettingbackendgraphmodelWeeklyLosingDataList(ctx context.Context, sel ast.SelectionSet, v *model.WeeklyLosingDataList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeeklyLosingDataList(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODeletedAt2gormiogormDeletedAt(ctx context.Context, v any) (*gorm.DeletedAt, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalDeletedAt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeletedAt2gormiogormDeletedAt(ctx context.Context, sel ast.SelectionSet, v *gorm.DeletedAt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := scalar.MarshalDeletedAt(*v)
	return res
}

func (ec *executionContext) marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v models.Domain) graphql.Marshaler {
	return ec._Domain(ctx, sel, &v)
}

func (ec *executionContext) marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v []*models.Domain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODomain2githubcomhotbrainygobettingbackendinternalmodelsDomain(ctx context.Context, sel ast.SelectionSet, v *models.Domain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Domain(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2githubcomhotbrainygobettingbackendinternalmodelsEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx context.Context, v any) ([]*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Filter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx context.Context, v any) ([]*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Filter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilter2githubcomhotbrainygobettingbackendgraphmodelFilter(ctx context.Context, v any) (*model.Filter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	return res
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOID2uint(ctx context.Context, v any) (*uint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2uint(ctx context.Context, sel ast.SelectionSet, v *uint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int32(ctx context.Context, v any) (*int32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int32(ctx context.Context, sel ast.SelectionSet, v *int32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt32(*v)
	return res
}

func (ec *executionContext) marshalOLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx context.Context, sel ast.SelectionSet, v []*models.Log) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLog2githubcomhotbrainygobettingbackendinternalmodelsLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v []models.Menu) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMenu2githubcomhotbrainygobettingbackendinternalmodelsMenu(ctx context.Context, sel ast.SelectionSet, v *models.Menu) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Menu(ctx, sel, v)
}

func (ec *executionContext) unmarshalONewUser2githubcomhotbrainygobettingbackendgraphmodelNewUser(ctx context.Context, v any) (*model.NewUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNewUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx context.Context, sel ast.SelectionSet, v []*models.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2githubcomhotbrainygobettingbackendinternalmodelsNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOp2githubcomhotbrainygobettingbackendgraphmodelOp(ctx context.Context, v any) (*model.Op, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Op)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOp2githubcomhotbrainygobettingbackendgraphmodelOp(ctx context.Context, sel ast.SelectionSet, v *model.Op) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx context.Context, v any) ([]*model.Order, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Order, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrder2githubcomhotbrainygobettingbackendgraphmodelOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrderDirection2githubcomhotbrainygobettingbackendgraphmodelOrderDirection(ctx context.Context, v any) (*model.OrderDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.OrderDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderDirection2githubcomhotbrainygobettingbackendgraphmodelOrderDirection(ctx context.Context, sel ast.SelectionSet, v *model.OrderDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPagination2githubcomhotbrainygobettingbackendgraphmodelPagination(ctx context.Context, v any) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPagination(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProfile2githubcomhotbrainygobettingbackendinternalmodelsProfile(ctx context.Context, sel ast.SelectionSet, v models.Profile) graphql.Marshaler {
	return ec._Profile(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOUint2uint(ctx context.Context, v any) (uint, error) {
	res, err := graphql.UnmarshalUint(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2uint(ctx context.Context, sel ast.SelectionSet, v uint) graphql.Marshaler {
	res := graphql.MarshalUint(v)
	return res
}

func (ec *executionContext) unmarshalOUint2uint(ctx context.Context, v any) (*uint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2uint(ctx context.Context, sel ast.SelectionSet, v *uint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v []models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUser2githubcomhotbrainygobettingbackendinternalmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx context.Context, v any) (*model.UserStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.UserStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserStatus2githubcomhotbrainygobettingbackendgraphmodelUserStatus(ctx context.Context, sel ast.SelectionSet, v *model.UserStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx context.Context, v any) (*model.UserType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.UserType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserType2githubcomhotbrainygobettingbackendgraphmodelUserType(ctx context.Context, sel ast.SelectionSet, v *model.UserType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
